{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _buffer = require(\"./buffer\");\nvar n = require(\"./node\");\nvar _t = require(\"@babel/types\");\nvar generatorFunctions = require(\"./generators\");\nvar isFunction = _t.isFunction,\n  isStatement = _t.isStatement,\n  isClassBody = _t.isClassBody,\n  isTSInterfaceBody = _t.isTSInterfaceBody,\n  isTSEnumDeclaration = _t.isTSEnumDeclaration;\nvar SCIENTIFIC_NOTATION = /e/i;\nvar ZERO_DECIMAL_INTEGER = /\\.0+$/;\nvar NON_DECIMAL_LITERAL = /^0[box]/;\nvar PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nvar HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nvar HAS_BlOCK_COMMENT_END = /\\*\\//;\nvar needsParens = n.needsParens;\nvar Printer = /*#__PURE__*/function () {\n  function Printer(format, map) {\n    _classCallCheck(this, Printer);\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._indentChar = 0;\n    this._indentRepeat = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new Set();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this._lastCommentLine = 0;\n    this._endsWithInnerRaw = false;\n    this._indentInnerComments = true;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n    this._inputMap = map == null ? void 0 : map._inputMap;\n  }\n  _createClass(Printer, [{\n    key: \"generate\",\n    value: function generate(ast) {\n      this.print(ast);\n      this._maybeAddAuxComment();\n      return this._buf.get();\n    }\n  }, {\n    key: \"indent\",\n    value: function indent() {\n      if (this.format.compact || this.format.concise) return;\n      this._indent++;\n    }\n  }, {\n    key: \"dedent\",\n    value: function dedent() {\n      if (this.format.compact || this.format.concise) return;\n      this._indent--;\n    }\n  }, {\n    key: \"semicolon\",\n    value: function semicolon() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this._maybeAddAuxComment();\n      if (force) {\n        this._appendChar(59);\n      } else {\n        this._queue(59);\n      }\n      this._noLineTerminator = false;\n    }\n  }, {\n    key: \"rightBrace\",\n    value: function rightBrace() {\n      if (this.format.minified) {\n        this._buf.removeLastSemicolon();\n      }\n      this.tokenChar(125);\n    }\n  }, {\n    key: \"space\",\n    value: function space() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.format.compact) return;\n      if (force) {\n        this._space();\n      } else if (this._buf.hasContent()) {\n        var lastCp = this.getLastChar();\n        if (lastCp !== 32 && lastCp !== 10) {\n          this._space();\n        }\n      }\n    }\n  }, {\n    key: \"word\",\n    value: function word(str) {\n      var noLineTerminatorAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._maybePrintInnerComments();\n      if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {\n        this._space();\n      }\n      this._maybeAddAuxComment();\n      this._append(str, false);\n      this._endsWithWord = true;\n      this._noLineTerminator = noLineTerminatorAfter;\n    }\n  }, {\n    key: \"number\",\n    value: function number(str) {\n      this.word(str);\n      this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n    }\n  }, {\n    key: \"token\",\n    value: function token(str) {\n      var maybeNewline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._maybePrintInnerComments();\n      var lastChar = this.getLastChar();\n      var strFirst = str.charCodeAt(0);\n      if (lastChar === 33 && str === \"--\" || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n        this._space();\n      }\n      this._maybeAddAuxComment();\n      this._append(str, maybeNewline);\n      this._noLineTerminator = false;\n    }\n  }, {\n    key: \"tokenChar\",\n    value: function tokenChar(char) {\n      this._maybePrintInnerComments();\n      var lastChar = this.getLastChar();\n      if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {\n        this._space();\n      }\n      this._maybeAddAuxComment();\n      this._appendChar(char);\n      this._noLineTerminator = false;\n    }\n  }, {\n    key: \"newline\",\n    value: function newline() {\n      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var force = arguments.length > 1 ? arguments[1] : undefined;\n      if (i <= 0) return;\n      if (!force) {\n        if (this.format.retainLines || this.format.compact) return;\n        if (this.format.concise) {\n          this.space();\n          return;\n        }\n      }\n      if (i > 2) i = 2;\n      i -= this._buf.getNewlineCount();\n      for (var j = 0; j < i; j++) {\n        this._newline();\n      }\n      return;\n    }\n  }, {\n    key: \"endsWith\",\n    value: function endsWith(char) {\n      return this.getLastChar() === char;\n    }\n  }, {\n    key: \"getLastChar\",\n    value: function getLastChar() {\n      return this._buf.getLastChar();\n    }\n  }, {\n    key: \"endsWithCharAndNewline\",\n    value: function endsWithCharAndNewline() {\n      return this._buf.endsWithCharAndNewline();\n    }\n  }, {\n    key: \"removeTrailingNewline\",\n    value: function removeTrailingNewline() {\n      this._buf.removeTrailingNewline();\n    }\n  }, {\n    key: \"exactSource\",\n    value: function exactSource(loc, cb) {\n      if (!loc) return cb();\n      this._catchUp(\"start\", loc);\n      this._buf.exactSource(loc, cb);\n    }\n  }, {\n    key: \"source\",\n    value: function source(prop, loc) {\n      if (!loc) return;\n      this._catchUp(prop, loc);\n      this._buf.source(prop, loc);\n    }\n  }, {\n    key: \"sourceWithOffset\",\n    value: function sourceWithOffset(prop, loc, lineOffset, columnOffset) {\n      if (!loc) return;\n      this._catchUp(prop, loc);\n      this._buf.sourceWithOffset(prop, loc, lineOffset, columnOffset);\n    }\n  }, {\n    key: \"withSource\",\n    value: function withSource(prop, loc, cb) {\n      if (!loc) return cb();\n      this._catchUp(prop, loc);\n      this._buf.withSource(prop, loc, cb);\n    }\n  }, {\n    key: \"sourceIdentifierName\",\n    value: function sourceIdentifierName(identifierName, pos) {\n      if (!this._buf._canMarkIdName) return;\n      var sourcePosition = this._buf._sourcePosition;\n      sourcePosition.identifierNamePos = pos;\n      sourcePosition.identifierName = identifierName;\n    }\n  }, {\n    key: \"_space\",\n    value: function _space() {\n      this._queue(32);\n    }\n  }, {\n    key: \"_newline\",\n    value: function _newline() {\n      this._queue(10);\n    }\n  }, {\n    key: \"_append\",\n    value: function _append(str, maybeNewline) {\n      this._maybeAddParen(str);\n      this._maybeIndent(str.charCodeAt(0));\n      this._buf.append(str, maybeNewline);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n    }\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(char) {\n      this._maybeAddParenChar(char);\n      this._maybeIndent(char);\n      this._buf.appendChar(char);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n    }\n  }, {\n    key: \"_queue\",\n    value: function _queue(char) {\n      this._maybeAddParenChar(char);\n      this._maybeIndent(char);\n      this._buf.queue(char);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n    }\n  }, {\n    key: \"_maybeIndent\",\n    value: function _maybeIndent(firstChar) {\n      if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n        this._buf.queueIndentation(this._indentChar, this._getIndent());\n      }\n    }\n  }, {\n    key: \"_shouldIndent\",\n    value: function _shouldIndent(firstChar) {\n      if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n        return true;\n      }\n    }\n  }, {\n    key: \"_maybeAddParenChar\",\n    value: function _maybeAddParenChar(char) {\n      var parenPushNewlineState = this._parenPushNewlineState;\n      if (!parenPushNewlineState) return;\n      if (char === 32) {\n        return;\n      }\n      if (char !== 10) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n      this.tokenChar(40);\n      this.indent();\n      parenPushNewlineState.printed = true;\n    }\n  }, {\n    key: \"_maybeAddParen\",\n    value: function _maybeAddParen(str) {\n      var parenPushNewlineState = this._parenPushNewlineState;\n      if (!parenPushNewlineState) return;\n      var len = str.length;\n      var i;\n      for (i = 0; i < len && str.charCodeAt(i) === 32; i++) continue;\n      if (i === len) {\n        return;\n      }\n      var cha = str.charCodeAt(i);\n      if (cha !== 10) {\n        if (cha !== 47 || i + 1 === len) {\n          this._parenPushNewlineState = null;\n          return;\n        }\n        var chaPost = str.charCodeAt(i + 1);\n        if (chaPost === 42) {\n          if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n            return;\n          }\n        } else if (chaPost !== 47) {\n          this._parenPushNewlineState = null;\n          return;\n        }\n      }\n      this.tokenChar(40);\n      this.indent();\n      parenPushNewlineState.printed = true;\n    }\n  }, {\n    key: \"catchUp\",\n    value: function catchUp(line) {\n      if (!this.format.retainLines) return;\n      var count = line - this._buf.getCurrentLine();\n      for (var i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }, {\n    key: \"_catchUp\",\n    value: function _catchUp(prop, loc) {\n      if (!this.format.retainLines) return;\n      var pos = loc ? loc[prop] : null;\n      if ((pos == null ? void 0 : pos.line) != null) {\n        var count = pos.line - this._buf.getCurrentLine();\n        for (var i = 0; i < count; i++) {\n          this._newline();\n        }\n      }\n    }\n  }, {\n    key: \"_getIndent\",\n    value: function _getIndent() {\n      return this._indentRepeat * this._indent;\n    }\n  }, {\n    key: \"printTerminatorless\",\n    value: function printTerminatorless(node, parent, isLabel) {\n      if (isLabel) {\n        this._noLineTerminator = true;\n        this.print(node, parent);\n      } else {\n        var terminatorState = {\n          printed: false\n        };\n        this._parenPushNewlineState = terminatorState;\n        this.print(node, parent);\n        if (terminatorState.printed) {\n          this.dedent();\n          this.newline();\n          this.tokenChar(41);\n        }\n      }\n    }\n  }, {\n    key: \"print\",\n    value: function print(node, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {\n      if (!node) return;\n      this._endsWithInnerRaw = false;\n      var nodeType = node.type;\n      var format = this.format;\n      var oldConcise = format.concise;\n      if (node._compact) {\n        format.concise = true;\n      }\n      var printMethod = this[nodeType];\n      if (printMethod === undefined) {\n        throw new ReferenceError(\"unknown node of type \".concat(JSON.stringify(nodeType), \" with constructor \").concat(JSON.stringify(node.constructor.name)));\n      }\n      this._printStack.push(node);\n      var oldInAux = this._insideAux;\n      this._insideAux = node.loc == undefined;\n      this._maybeAddAuxComment(this._insideAux && !oldInAux);\n      var shouldPrintParens = false;\n      if (forceParens) {\n        shouldPrintParens = true;\n      } else if (format.retainFunctionParens && nodeType === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n        shouldPrintParens = true;\n      } else {\n        shouldPrintParens = needsParens(node, parent, this._printStack);\n      }\n      if (shouldPrintParens) {\n        this.tokenChar(40);\n        this._endsWithInnerRaw = false;\n      }\n      this._lastCommentLine = 0;\n      this._printLeadingComments(node, parent);\n      var loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n      this.exactSource(loc, printMethod.bind(this, node, parent));\n      if (shouldPrintParens) {\n        this._printTrailingComments(node, parent);\n        this.tokenChar(41);\n        this._noLineTerminator = noLineTerminatorAfter;\n      } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n        this._noLineTerminator = true;\n        this._printTrailingComments(node, parent);\n      } else {\n        this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n      }\n      this._printStack.pop();\n      format.concise = oldConcise;\n      this._insideAux = oldInAux;\n      this._endsWithInnerRaw = false;\n    }\n  }, {\n    key: \"_maybeAddAuxComment\",\n    value: function _maybeAddAuxComment(enteredPositionlessNode) {\n      if (enteredPositionlessNode) this._printAuxBeforeComment();\n      if (!this._insideAux) this._printAuxAfterComment();\n    }\n  }, {\n    key: \"_printAuxBeforeComment\",\n    value: function _printAuxBeforeComment() {\n      if (this._printAuxAfterOnNextUserNode) return;\n      this._printAuxAfterOnNextUserNode = true;\n      var comment = this.format.auxiliaryCommentBefore;\n      if (comment) {\n        this._printComment({\n          type: \"CommentBlock\",\n          value: comment\n        }, 0);\n      }\n    }\n  }, {\n    key: \"_printAuxAfterComment\",\n    value: function _printAuxAfterComment() {\n      if (!this._printAuxAfterOnNextUserNode) return;\n      this._printAuxAfterOnNextUserNode = false;\n      var comment = this.format.auxiliaryCommentAfter;\n      if (comment) {\n        this._printComment({\n          type: \"CommentBlock\",\n          value: comment\n        }, 0);\n      }\n    }\n  }, {\n    key: \"getPossibleRaw\",\n    value: function getPossibleRaw(node) {\n      var extra = node.extra;\n      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n        return extra.raw;\n      }\n    }\n  }, {\n    key: \"printJoin\",\n    value: function printJoin(nodes, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!(nodes != null && nodes.length)) return;\n      if (opts.indent) this.indent();\n      var newlineOpts = {\n        addNewlines: opts.addNewlines,\n        nextNodeStartLine: 0\n      };\n      var separator = opts.separator ? opts.separator.bind(this) : null;\n      var len = nodes.length;\n      for (var i = 0; i < len; i++) {\n        var node = nodes[i];\n        if (!node) continue;\n        if (opts.statement) this._printNewline(i === 0, newlineOpts);\n        this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n        opts.iterator == null ? void 0 : opts.iterator(node, i);\n        if (i < len - 1) separator == null ? void 0 : separator();\n        if (opts.statement) {\n          if (i + 1 === len) {\n            this.newline(1);\n          } else {\n            var _nextNode$loc;\n            var nextNode = nodes[i + 1];\n            newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;\n            this._printNewline(true, newlineOpts);\n          }\n        }\n      }\n      if (opts.indent) this.dedent();\n    }\n  }, {\n    key: \"printAndIndentOnComments\",\n    value: function printAndIndentOnComments(node, parent) {\n      var indent = node.leadingComments && node.leadingComments.length > 0;\n      if (indent) this.indent();\n      this.print(node, parent);\n      if (indent) this.dedent();\n    }\n  }, {\n    key: \"printBlock\",\n    value: function printBlock(parent) {\n      var node = parent.body;\n      if (node.type !== \"EmptyStatement\") {\n        this.space();\n      }\n      this.print(node, parent);\n    }\n  }, {\n    key: \"_printTrailingComments\",\n    value: function _printTrailingComments(node, parent, lineOffset) {\n      var innerComments = node.innerComments,\n        trailingComments = node.trailingComments;\n      if (innerComments != null && innerComments.length) {\n        this._printComments(2, innerComments, node, parent, lineOffset);\n      }\n      if (trailingComments != null && trailingComments.length) {\n        this._printComments(2, trailingComments, node, parent, lineOffset);\n      }\n    }\n  }, {\n    key: \"_printLeadingComments\",\n    value: function _printLeadingComments(node, parent) {\n      var comments = node.leadingComments;\n      if (!(comments != null && comments.length)) return;\n      this._printComments(0, comments, node, parent);\n    }\n  }, {\n    key: \"_maybePrintInnerComments\",\n    value: function _maybePrintInnerComments() {\n      if (this._endsWithInnerRaw) this.printInnerComments();\n      this._endsWithInnerRaw = true;\n      this._indentInnerComments = true;\n    }\n  }, {\n    key: \"printInnerComments\",\n    value: function printInnerComments() {\n      var node = this._printStack[this._printStack.length - 1];\n      var comments = node.innerComments;\n      if (!(comments != null && comments.length)) return;\n      var hasSpace = this.endsWith(32);\n      var indent = this._indentInnerComments;\n      var printedCommentsCount = this._printedComments.size;\n      if (indent) this.indent();\n      this._printComments(1, comments, node);\n      if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n        this.space();\n      }\n      if (indent) this.dedent();\n    }\n  }, {\n    key: \"noIndentInnerCommentsHere\",\n    value: function noIndentInnerCommentsHere() {\n      this._indentInnerComments = false;\n    }\n  }, {\n    key: \"printSequence\",\n    value: function printSequence(nodes, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.statement = true;\n      return this.printJoin(nodes, parent, opts);\n    }\n  }, {\n    key: \"printList\",\n    value: function printList(items, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (opts.separator == null) {\n        opts.separator = commaSeparator;\n      }\n      return this.printJoin(items, parent, opts);\n    }\n  }, {\n    key: \"_printNewline\",\n    value: function _printNewline(newLine, opts) {\n      if (this.format.retainLines || this.format.compact) return;\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n      if (!newLine) {\n        return;\n      }\n      var startLine = opts.nextNodeStartLine;\n      var lastCommentLine = this._lastCommentLine;\n      if (startLine > 0 && lastCommentLine > 0) {\n        var offset = startLine - lastCommentLine;\n        if (offset >= 0) {\n          this.newline(offset || 1);\n          return;\n        }\n      }\n      if (this._buf.hasContent()) {\n        this.newline(1);\n      }\n    }\n  }, {\n    key: \"_shouldPrintComment\",\n    value: function _shouldPrintComment(comment) {\n      if (comment.ignore) return 0;\n      if (this._printedComments.has(comment)) return 0;\n      if (this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value))) {\n        return 2;\n      }\n      this._printedComments.add(comment);\n      if (!this.format.shouldPrintComment(comment.value)) {\n        return 0;\n      }\n      return 1;\n    }\n  }, {\n    key: \"_printComment\",\n    value: function _printComment(comment, skipNewLines) {\n      var noLineTerminator = this._noLineTerminator;\n      var isBlockComment = comment.type === \"CommentBlock\";\n      var printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;\n      if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {\n        this.newline(1);\n      }\n      var lastCharCode = this.getLastChar();\n      if (lastCharCode !== 91 && lastCharCode !== 123) {\n        this.space();\n      }\n      var val;\n      if (isBlockComment) {\n        val = \"/*\".concat(comment.value, \"*/\");\n        if (this.format.indent.adjustMultilineComment) {\n          var _comment$loc;\n          var offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n          if (offset) {\n            var newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n            val = val.replace(newlineRegex, \"\\n\");\n          }\n          var indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();\n          if (this._shouldIndent(47) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n          val = val.replace(/\\n(?!$)/g, \"\\n\".concat(\" \".repeat(indentSize)));\n        }\n      } else if (!noLineTerminator) {\n        val = \"//\".concat(comment.value);\n      } else {\n        val = \"/*\".concat(comment.value, \"*/\");\n      }\n      if (this.endsWith(47)) this._space();\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n      if (!isBlockComment && !noLineTerminator) {\n        this.newline(1, true);\n      }\n      if (printNewLines && skipNewLines !== 3) {\n        this.newline(1);\n      }\n    }\n  }, {\n    key: \"_printComments\",\n    value: function _printComments(type, comments, node, parent) {\n      var lineOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var nodeLoc = node.loc;\n      var len = comments.length;\n      var hasLoc = !!nodeLoc;\n      var nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n      var nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n      var lastLine = 0;\n      var leadingCommentNewline = 0;\n      var maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);\n      for (var i = 0; i < len; i++) {\n        var comment = comments[i];\n        var shouldPrint = this._shouldPrintComment(comment);\n        if (shouldPrint === 2) {\n          hasLoc = false;\n          break;\n        }\n        if (hasLoc && comment.loc && shouldPrint === 1) {\n          var commentStartLine = comment.loc.start.line;\n          var commentEndLine = comment.loc.end.line;\n          if (type === 0) {\n            var offset = 0;\n            if (i === 0) {\n              if (this._buf.hasContent() && (comment.type === \"CommentLine\" || commentStartLine != commentEndLine)) {\n                offset = leadingCommentNewline = 1;\n              }\n            } else {\n              offset = commentStartLine - lastLine;\n            }\n            lastLine = commentEndLine;\n            maybeNewline(offset);\n            this._printComment(comment, 1);\n            if (i + 1 === len) {\n              maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));\n              lastLine = nodeStartLine;\n            }\n          } else if (type === 1) {\n            var _offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n            lastLine = commentEndLine;\n            maybeNewline(_offset);\n            this._printComment(comment, 1);\n            if (i + 1 === len) {\n              maybeNewline(Math.min(1, nodeEndLine - lastLine));\n              lastLine = nodeEndLine;\n            }\n          } else {\n            var _offset2 = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n            lastLine = commentEndLine;\n            maybeNewline(_offset2);\n            this._printComment(comment, 1);\n          }\n        } else {\n          hasLoc = false;\n          if (shouldPrint !== 1) {\n            continue;\n          }\n          if (len === 1) {\n            var singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);\n            var shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);\n            if (type === 0) {\n              this._printComment(comment, shouldSkipNewline && node.type !== \"ObjectExpression\" || singleLine && isFunction(parent, {\n                body: node\n              }) ? 1 : 0);\n            } else if (shouldSkipNewline && type === 2) {\n              this._printComment(comment, 1);\n            } else {\n              this._printComment(comment, 0);\n            }\n          } else if (type === 1 && !(node.type === \"ObjectExpression\" && node.properties.length > 1) && node.type !== \"ClassBody\" && node.type !== \"TSInterfaceBody\") {\n            this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);\n          } else {\n            this._printComment(comment, 0);\n          }\n        }\n      }\n      if (type === 2 && hasLoc && lastLine) {\n        this._lastCommentLine = lastLine;\n      }\n    }\n  }]);\n  return Printer;\n}();\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\nfunction commaSeparator() {\n  this.tokenChar(44);\n  this.space();\n}","map":null,"metadata":{},"sourceType":"script"}