{"ast":null,"code":"/*\n * Author: Alex Kocharin <alex@kocharin.ru>\n * GIT: https://github.com/rlidwka/jju\n * License: WTFPL, grab your copy here: http://www.wtfpl.net/txt/copying/\n */\n\n// RTFM: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\n\nvar Uni = require('./unicode');\nfunction isHexDigit(x) {\n  return x >= '0' && x <= '9' || x >= 'A' && x <= 'F' || x >= 'a' && x <= 'f';\n}\nfunction isOctDigit(x) {\n  return x >= '0' && x <= '7';\n}\nfunction isDecDigit(x) {\n  return x >= '0' && x <= '9';\n}\nvar unescapeMap = {\n  '\\'': '\\'',\n  '\"': '\"',\n  '\\\\': '\\\\',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'v': '\\v',\n  '/': '/'\n};\nfunction formatError(input, msg, position, lineno, column, json5) {\n  var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1),\n    tmppos = position - column - 1,\n    srcline = '',\n    underline = '';\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;\n\n  // output no more than 70 characters before the wrong ones\n  if (tmppos < position - 70) {\n    tmppos = position - 70;\n  }\n  while (1) {\n    var chr = input[++tmppos];\n    if (isLineTerminator(chr) || tmppos === input.length) {\n      if (position >= tmppos) {\n        // ending line error, so show it after the last char\n        underline += '^';\n      }\n      break;\n    }\n    srcline += chr;\n    if (position === tmppos) {\n      underline += '^';\n    } else if (position > tmppos) {\n      underline += input[tmppos] === '\\t' ? '\\t' : ' ';\n    }\n\n    // output no more than 78 characters on the string\n    if (srcline.length > 78) break;\n  }\n  return result + '\\n' + srcline + '\\n' + underline;\n}\nfunction parse(input, options) {\n  // parse as a standard JSON mode\n  var json5 = !(options.mode === 'json' || options.legacy);\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;\n  var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON;\n  var length = input.length,\n    lineno = 0,\n    linestart = 0,\n    position = 0,\n    stack = [];\n  var tokenStart = function tokenStart() {};\n  var tokenEnd = function tokenEnd(v) {\n    return v;\n  };\n\n  /* tokenize({\n       raw: '...',\n       type: 'whitespace'|'comment'|'key'|'literal'|'separator'|'newline',\n       value: 'number'|'string'|'whatever',\n       path: [...],\n     })\n  */\n  if (options._tokenize) {\n    ;\n    (function () {\n      var start = null;\n      tokenStart = function tokenStart() {\n        if (start !== null) throw Error('internal error, token overlap');\n        start = position;\n      };\n      tokenEnd = function tokenEnd(v, type) {\n        if (start != position) {\n          var hash = {\n            raw: input.substr(start, position - start),\n            type: type,\n            stack: stack.slice(0)\n          };\n          if (v !== undefined) hash.value = v;\n          options._tokenize.call(null, hash);\n        }\n        start = null;\n        return v;\n      };\n    })();\n  }\n  function fail(msg) {\n    var column = position - linestart;\n    if (!msg) {\n      if (position < length) {\n        var token = '\\'' + JSON.stringify(input[position]).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n        if (!msg) msg = 'Unexpected token ' + token;\n      } else {\n        if (!msg) msg = 'Unexpected end of input';\n      }\n    }\n    var error = SyntaxError(formatError(input, msg, position, lineno, column, json5));\n    error.row = lineno + 1;\n    error.column = column + 1;\n    throw error;\n  }\n  function newline(chr) {\n    // account for <cr><lf>\n    if (chr === '\\r' && input[position] === '\\n') position++;\n    linestart = position;\n    lineno++;\n  }\n  function parseGeneric() {\n    var result;\n    while (position < length) {\n      tokenStart();\n      var chr = input[position++];\n      if (chr === '\"' || chr === '\\'' && json5) {\n        return tokenEnd(parseString(chr), 'literal');\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator');\n        return parseObject();\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator');\n        return parseArray();\n      } else if (chr === '-' || chr === '.' || isDecDigit(chr)\n      //           + number       Infinity          NaN\n      || json5 && (chr === '+' || chr === 'I' || chr === 'N')) {\n        return tokenEnd(parseNumber(), 'literal');\n      } else if (chr === 'n') {\n        parseKeyword('null');\n        return tokenEnd(null, 'literal');\n      } else if (chr === 't') {\n        parseKeyword('true');\n        return tokenEnd(true, 'literal');\n      } else if (chr === 'f') {\n        parseKeyword('false');\n        return tokenEnd(false, 'literal');\n      } else {\n        position--;\n        return tokenEnd(undefined);\n      }\n    }\n  }\n  function parseKey() {\n    var result;\n    while (position < length) {\n      tokenStart();\n      var chr = input[position++];\n      if (chr === '\"' || chr === '\\'' && json5) {\n        return tokenEnd(parseString(chr), 'key');\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator');\n        return parseObject();\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator');\n        return parseArray();\n      } else if (chr === '.' || isDecDigit(chr)) {\n        return tokenEnd(parseNumber(true), 'key');\n      } else if (json5 && Uni.isIdentifierStart(chr) || chr === '\\\\' && input[position] === 'u') {\n        // unicode char or a unicode sequence\n        var rollback = position - 1;\n        var result = parseIdentifier();\n        if (result === undefined) {\n          position = rollback;\n          return tokenEnd(undefined);\n        } else {\n          return tokenEnd(result, 'key');\n        }\n      } else {\n        position--;\n        return tokenEnd(undefined);\n      }\n    }\n  }\n  function skipWhiteSpace() {\n    tokenStart();\n    while (position < length) {\n      var chr = input[position++];\n      if (isLineTerminator(chr)) {\n        position--;\n        tokenEnd(undefined, 'whitespace');\n        tokenStart();\n        position++;\n        newline(chr);\n        tokenEnd(undefined, 'newline');\n        tokenStart();\n      } else if (isWhiteSpace(chr)) {\n        // nothing\n      } else if (chr === '/' && json5 && (input[position] === '/' || input[position] === '*')) {\n        position--;\n        tokenEnd(undefined, 'whitespace');\n        tokenStart();\n        position++;\n        skipComment(input[position++] === '*');\n        tokenEnd(undefined, 'comment');\n        tokenStart();\n      } else {\n        position--;\n        break;\n      }\n    }\n    return tokenEnd(undefined, 'whitespace');\n  }\n  function skipComment(multi) {\n    while (position < length) {\n      var chr = input[position++];\n      if (isLineTerminator(chr)) {\n        // LineTerminator is an end of singleline comment\n        if (!multi) {\n          // let parent function deal with newline\n          position--;\n          return;\n        }\n        newline(chr);\n      } else if (chr === '*' && multi) {\n        // end of multiline comment\n        if (input[position] === '/') {\n          position++;\n          return;\n        }\n      } else {\n        // nothing\n      }\n    }\n    if (multi) {\n      fail('Unclosed multiline comment');\n    }\n  }\n  function parseKeyword(keyword) {\n    // keyword[0] is not checked because it should've checked earlier\n    var _pos = position;\n    var len = keyword.length;\n    for (var i = 1; i < len; i++) {\n      if (position >= length || keyword[i] != input[position]) {\n        position = _pos - 1;\n        fail();\n      }\n      position++;\n    }\n  }\n  function parseObject() {\n    var result = options.null_prototype ? Object.create(null) : {},\n      empty_object = {},\n      is_non_empty = false;\n    while (position < length) {\n      skipWhiteSpace();\n      var item1 = parseKey();\n      skipWhiteSpace();\n      tokenStart();\n      var chr = input[position++];\n      tokenEnd(undefined, 'separator');\n      if (chr === '}' && item1 === undefined) {\n        if (!json5 && is_non_empty) {\n          position--;\n          fail('Trailing comma in object');\n        }\n        return result;\n      } else if (chr === ':' && item1 !== undefined) {\n        skipWhiteSpace();\n        stack.push(item1);\n        var item2 = parseGeneric();\n        stack.pop();\n        if (item2 === undefined) fail('No value found for key ' + item1);\n        if (typeof item1 !== 'string') {\n          if (!json5 || typeof item1 !== 'number') {\n            fail('Wrong key type: ' + item1);\n          }\n        }\n        if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') {\n          if (options.reserved_keys === 'throw') {\n            fail('Reserved key: ' + item1);\n          } else {\n            // silently ignore it\n          }\n        } else {\n          if (typeof options.reviver === 'function') {\n            item2 = options.reviver.call(null, item1, item2);\n          }\n          if (item2 !== undefined) {\n            is_non_empty = true;\n            Object.defineProperty(result, item1, {\n              value: item2,\n              enumerable: true,\n              configurable: true,\n              writable: true\n            });\n          }\n        }\n        skipWhiteSpace();\n        tokenStart();\n        var chr = input[position++];\n        tokenEnd(undefined, 'separator');\n        if (chr === ',') {\n          continue;\n        } else if (chr === '}') {\n          return result;\n        } else {\n          fail();\n        }\n      } else {\n        position--;\n        fail();\n      }\n    }\n    fail();\n  }\n  function parseArray() {\n    var result = [];\n    while (position < length) {\n      skipWhiteSpace();\n      stack.push(result.length);\n      var item = parseGeneric();\n      stack.pop();\n      skipWhiteSpace();\n      tokenStart();\n      var chr = input[position++];\n      tokenEnd(undefined, 'separator');\n      if (item !== undefined) {\n        if (typeof options.reviver === 'function') {\n          item = options.reviver.call(null, String(result.length), item);\n        }\n        if (item === undefined) {\n          result.length++;\n          item = true; // hack for check below, not included into result\n        } else {\n          result.push(item);\n        }\n      }\n      if (chr === ',') {\n        if (item === undefined) {\n          fail('Elisions are not supported');\n        }\n      } else if (chr === ']') {\n        if (!json5 && item === undefined && result.length) {\n          position--;\n          fail('Trailing comma in array');\n        }\n        return result;\n      } else {\n        position--;\n        fail();\n      }\n    }\n  }\n  function parseNumber() {\n    // rewind because we don't know first char\n    position--;\n    var start = position,\n      chr = input[position++],\n      t;\n    var to_num = function to_num(is_octal) {\n      var str = input.substr(start, position - start);\n      if (is_octal) {\n        var result = parseInt(str.replace(/^0o?/, ''), 8);\n      } else {\n        var result = Number(str);\n      }\n      if (Number.isNaN(result)) {\n        position--;\n        fail('Bad numeric literal - \"' + input.substr(start, position - start + 1) + '\"');\n      } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {\n        // additional restrictions imposed by json\n        position--;\n        fail('Non-json numeric literal - \"' + input.substr(start, position - start + 1) + '\"');\n      } else {\n        return result;\n      }\n    };\n\n    // ex: -5982475.249875e+29384\n    //     ^ skipping this\n    if (chr === '-' || chr === '+' && json5) chr = input[position++];\n    if (chr === 'N' && json5) {\n      parseKeyword('NaN');\n      return NaN;\n    }\n    if (chr === 'I' && json5) {\n      parseKeyword('Infinity');\n\n      // returning +inf or -inf\n      return to_num();\n    }\n    if (chr >= '1' && chr <= '9') {\n      // ex: -5982475.249875e+29384\n      //        ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++;\n      chr = input[position++];\n    }\n\n    // special case for leading zero: 0.123456\n    if (chr === '0') {\n      chr = input[position++];\n\n      //             new syntax, \"0o777\"           old syntax, \"0777\"\n      var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr);\n      var is_hex = chr === 'x' || chr === 'X';\n      if (json5 && (is_octal || is_hex)) {\n        while (position < length && (is_hex ? isHexDigit : isOctDigit)(input[position])) position++;\n        var sign = 1;\n        if (input[start] === '-') {\n          sign = -1;\n          start++;\n        } else if (input[start] === '+') {\n          start++;\n        }\n        return sign * to_num(is_octal);\n      }\n    }\n    if (chr === '.') {\n      // ex: -5982475.249875e+29384\n      //                ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++;\n      chr = input[position++];\n    }\n    if (chr === 'e' || chr === 'E') {\n      chr = input[position++];\n      if (chr === '-' || chr === '+') position++;\n      // ex: -5982475.249875e+29384\n      //                       ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++;\n      chr = input[position++];\n    }\n\n    // we have char in the buffer, so count for it\n    position--;\n    return to_num();\n  }\n  function parseIdentifier() {\n    // rewind because we don't know first char\n    position--;\n    var result = '';\n    while (position < length) {\n      var chr = input[position++];\n      if (chr === '\\\\' && input[position] === 'u' && isHexDigit(input[position + 1]) && isHexDigit(input[position + 2]) && isHexDigit(input[position + 3]) && isHexDigit(input[position + 4])) {\n        // UnicodeEscapeSequence\n        chr = String.fromCharCode(parseInt(input.substr(position + 1, 4), 16));\n        position += 5;\n      }\n      if (result.length) {\n        // identifier started\n        if (Uni.isIdentifierPart(chr)) {\n          result += chr;\n        } else {\n          position--;\n          return result;\n        }\n      } else {\n        if (Uni.isIdentifierStart(chr)) {\n          result += chr;\n        } else {\n          return undefined;\n        }\n      }\n    }\n    fail();\n  }\n  function parseString(endChar) {\n    // 7.8.4 of ES262 spec\n    var result = '';\n    while (position < length) {\n      var chr = input[position++];\n      if (chr === endChar) {\n        return result;\n      } else if (chr === '\\\\') {\n        if (position >= length) fail();\n        chr = input[position++];\n        if (unescapeMap[chr] && (json5 || chr != 'v' && chr != \"'\")) {\n          result += unescapeMap[chr];\n        } else if (json5 && isLineTerminator(chr)) {\n          // line continuation\n          newline(chr);\n        } else if (chr === 'u' || chr === 'x' && json5) {\n          // unicode/character escape sequence\n          var off = chr === 'u' ? 4 : 2;\n\n          // validation for \\uXXXX\n          for (var i = 0; i < off; i++) {\n            if (position >= length) fail();\n            if (!isHexDigit(input[position])) fail('Bad escape sequence');\n            position++;\n          }\n          result += String.fromCharCode(parseInt(input.substr(position - off, off), 16));\n        } else if (json5 && isOctDigit(chr)) {\n          if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position + 1])) {\n            // three-digit octal\n            var digits = 3;\n          } else if (isOctDigit(input[position])) {\n            // two-digit octal\n            var digits = 2;\n          } else {\n            var digits = 1;\n          }\n          position += digits - 1;\n          result += String.fromCharCode(parseInt(input.substr(position - digits, digits), 8));\n          /*if (!isOctDigit(input[position])) {\n            // \\0 is allowed still\n            result += '\\0'\n          } else {\n            fail('Octal literals are not supported')\n          }*/\n        } else if (json5) {\n          // \\X -> x\n          result += chr;\n        } else {\n          position--;\n          fail();\n        }\n      } else if (isLineTerminator(chr)) {\n        fail();\n      } else {\n        if (!json5 && chr.charCodeAt(0) < 32) {\n          position--;\n          fail('Unexpected control character');\n        }\n\n        // SourceCharacter but not one of \" or \\ or LineTerminator\n        result += chr;\n      }\n    }\n    fail();\n  }\n  skipWhiteSpace();\n  var return_value = parseGeneric();\n  if (return_value !== undefined || position < length) {\n    skipWhiteSpace();\n    if (position >= length) {\n      if (typeof options.reviver === 'function') {\n        return_value = options.reviver.call(null, '', return_value);\n      }\n      return return_value;\n    } else {\n      fail();\n    }\n  } else {\n    if (position) {\n      fail('No data, only a whitespace');\n    } else {\n      fail('No data, empty input');\n    }\n  }\n}\n\n/*\n * parse(text, options)\n * or\n * parse(text, reviver)\n *\n * where:\n * text - string\n * options - object\n * reviver - function\n */\nmodule.exports.parse = function parseJSON(input, options) {\n  // support legacy functions\n  if (typeof options === 'function') {\n    options = {\n      reviver: options\n    };\n  }\n  if (input === undefined) {\n    // parse(stringify(x)) should be equal x\n    // with JSON functions it is not 'cause of undefined\n    // so we're fixing it\n    return undefined;\n  }\n\n  // JSON.parse compat\n  if (typeof input !== 'string') input = String(input);\n  if (options == null) options = {};\n  if (options.reserved_keys == null) options.reserved_keys = 'ignore';\n  if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') {\n    if (options.null_prototype == null) {\n      options.null_prototype = true;\n    }\n  }\n  try {\n    return parse(input, options);\n  } catch (err) {\n    // jju is a recursive parser, so JSON.parse(\"{{{{{{{\") could blow up the stack\n    //\n    // this catch is used to skip all those internal calls\n    if (err instanceof SyntaxError && err.row != null && err.column != null) {\n      var old_err = err;\n      err = SyntaxError(old_err.message);\n      err.column = old_err.column;\n      err.row = old_err.row;\n    }\n    throw err;\n  }\n};\nmodule.exports.tokenize = function tokenizeJSON(input, options) {\n  if (options == null) options = {};\n  options._tokenize = function (smth) {\n    if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack);\n    tokens.push(smth);\n  };\n  var tokens = [];\n  tokens.data = module.exports.parse(input, options);\n  return tokens;\n};","map":null,"metadata":{},"sourceType":"script"}