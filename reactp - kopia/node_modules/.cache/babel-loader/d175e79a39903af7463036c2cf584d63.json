{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\n\n// add bash completions to your\n//  yargs-powered applications.\nmodule.exports = function completion(yargs, usage, command) {\n  var self = {\n    completionKey: 'get-yargs-completions'\n  };\n\n  // get a list of completion commands.\n  // 'args' is the array of strings from the line to be completed\n  self.getCompletion = function getCompletion(args, done) {\n    var completions = [];\n    var current = args.length ? args[args.length - 1] : '';\n    var argv = yargs.parse(args, true);\n    var aliases = yargs.parsed.aliases;\n\n    // a custom completion function can be provided\n    // to completion().\n    if (completionFunction) {\n      if (completionFunction.length < 3) {\n        var result = completionFunction(current, argv);\n\n        // promise based completion function.\n        if (typeof result.then === 'function') {\n          return result.then(function (list) {\n            process.nextTick(function () {\n              done(list);\n            });\n          }).catch(function (err) {\n            process.nextTick(function () {\n              throw err;\n            });\n          });\n        }\n\n        // synchronous completion function.\n        return done(result);\n      } else {\n        // asynchronous completion function\n        return completionFunction(current, argv, function (completions) {\n          done(completions);\n        });\n      }\n    }\n    var handlers = command.getCommandHandlers();\n    for (var i = 0, ii = args.length; i < ii; ++i) {\n      if (handlers[args[i]] && handlers[args[i]].builder) {\n        var builder = handlers[args[i]].builder;\n        if (typeof builder === 'function') {\n          var y = yargs.reset();\n          builder(y);\n          return y.argv;\n        }\n      }\n    }\n    if (!current.match(/^-/)) {\n      usage.getCommands().forEach(function (usageCommand) {\n        var commandName = command.parseCommand(usageCommand[0]).cmd;\n        if (args.indexOf(commandName) === -1) {\n          completions.push(commandName);\n        }\n      });\n    }\n    if (current.match(/^-/)) {\n      Object.keys(yargs.getOptions().key).forEach(function (key) {\n        // If the key and its aliases aren't in 'args', add the key to 'completions'\n        var keyAndAliases = [key].concat(aliases[key] || []);\n        var notInArgs = keyAndAliases.every(function (val) {\n          return args.indexOf(\"--\".concat(val)) === -1;\n        });\n        if (notInArgs) {\n          completions.push(\"--\".concat(key));\n        }\n      });\n    }\n    done(completions);\n  };\n\n  // generate the completion script to add to your .bashrc.\n  self.generateCompletionScript = function generateCompletionScript($0, cmd) {\n    var script = fs.readFileSync(path.resolve(__dirname, '../completion.sh.hbs'), 'utf-8');\n    var name = path.basename($0);\n\n    // add ./to applications not yet installed as bin.\n    if ($0.match(/\\.js$/)) $0 = \"./\".concat($0);\n    script = script.replace(/{{app_name}}/g, name);\n    script = script.replace(/{{completion_command}}/g, cmd);\n    return script.replace(/{{app_path}}/g, $0);\n  };\n\n  // register a function to perform your own custom\n  // completions., this function can be either\n  // synchrnous or asynchronous.\n  var completionFunction = null;\n  self.registerFunction = function (fn) {\n    completionFunction = fn;\n  };\n  return self;\n};","map":null,"metadata":{},"sourceType":"script"}