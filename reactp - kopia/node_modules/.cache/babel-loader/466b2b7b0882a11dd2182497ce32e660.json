{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(loadPluginDescriptor),\n  _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(loadPresetDescriptor);\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nfunction _gensync() {\n  var data = require(\"gensync\");\n  _gensync = function _gensync() {\n    return data;\n  };\n  return data;\n}\nvar _async = require(\"../gensync-utils/async\");\nvar _util = require(\"./util\");\nvar context = require(\"../index\");\nvar _plugin = require(\"./plugin\");\nvar _item = require(\"./item\");\nvar _configChain = require(\"./config-chain\");\nvar _deepArray = require(\"./helpers/deep-array\");\nfunction _traverse() {\n  var data = require(\"@babel/traverse\");\n  _traverse = function _traverse() {\n    return data;\n  };\n  return data;\n}\nvar _caching = require(\"./caching\");\nvar _options = require(\"./validation/options\");\nvar _plugins = require(\"./validation/plugins\");\nvar _configApi = require(\"./helpers/config-api\");\nvar _partial = require(\"./partial\");\nvar _configError = require(\"../errors/config-error\");\nvar _default = _gensync()( /*#__PURE__*/_regeneratorRuntime().mark(function loadFullConfig(inputOpts) {\n  var _opts$assumptions, result, options, context, fileHandling, optionDefaults, plugins, presets, presetContext, toDescriptor, presetsDescriptors, initialPluginsDescriptors, pluginDescriptorsByPass, passes, externalDependencies, ignored, opts, pluginContext;\n  return _regeneratorRuntime().wrap(function loadFullConfig$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        return _context3.delegateYield((0, _partial.default)(inputOpts), \"t0\", 1);\n      case 1:\n        result = _context3.t0;\n        if (result) {\n          _context3.next = 4;\n          break;\n        }\n        return _context3.abrupt(\"return\", null);\n      case 4:\n        options = result.options, context = result.context, fileHandling = result.fileHandling;\n        if (!(fileHandling === \"ignored\")) {\n          _context3.next = 7;\n          break;\n        }\n        return _context3.abrupt(\"return\", null);\n      case 7:\n        optionDefaults = {};\n        plugins = options.plugins, presets = options.presets;\n        if (!(!plugins || !presets)) {\n          _context3.next = 11;\n          break;\n        }\n        throw new Error(\"Assertion failure - plugins and presets exist\");\n      case 11:\n        presetContext = Object.assign({}, context, {\n          targets: options.targets\n        });\n        toDescriptor = function toDescriptor(item) {\n          var desc = (0, _item.getItemDescriptor)(item);\n          if (!desc) {\n            throw new Error(\"Assertion failure - must be config item\");\n          }\n          return desc;\n        };\n        presetsDescriptors = presets.map(toDescriptor);\n        initialPluginsDescriptors = plugins.map(toDescriptor);\n        pluginDescriptorsByPass = [[]];\n        passes = [];\n        externalDependencies = [];\n        return _context3.delegateYield(enhanceError(context, /*#__PURE__*/_regeneratorRuntime().mark(function recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n          var presets, i, descriptor, preset, _iterator, _step, _step$value, _preset, pass, _ignored;\n          return _regeneratorRuntime().wrap(function recursePresetDescriptors$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                presets = [];\n                i = 0;\n              case 2:\n                if (!(i < rawPresets.length)) {\n                  _context.next = 19;\n                  break;\n                }\n                descriptor = rawPresets[i];\n                if (!(descriptor.options !== false)) {\n                  _context.next = 16;\n                  break;\n                }\n                _context.prev = 5;\n                return _context.delegateYield(loadPresetDescriptor(descriptor, presetContext), \"t0\", 7);\n              case 7:\n                preset = _context.t0;\n                _context.next = 14;\n                break;\n              case 10:\n                _context.prev = 10;\n                _context.t1 = _context[\"catch\"](5);\n                if (_context.t1.code === \"BABEL_UNKNOWN_OPTION\") {\n                  (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", _context.t1);\n                }\n                throw _context.t1;\n              case 14:\n                externalDependencies.push(preset.externalDependencies);\n                if (descriptor.ownPass) {\n                  presets.push({\n                    preset: preset.chain,\n                    pass: []\n                  });\n                } else {\n                  presets.unshift({\n                    preset: preset.chain,\n                    pass: pluginDescriptorsPass\n                  });\n                }\n              case 16:\n                i++;\n                _context.next = 2;\n                break;\n              case 19:\n                if (!(presets.length > 0)) {\n                  _context.next = 44;\n                  break;\n                }\n                pluginDescriptorsByPass.splice.apply(pluginDescriptorsByPass, [1, 0].concat(_toConsumableArray(presets.map(function (o) {\n                  return o.pass;\n                }).filter(function (p) {\n                  return p !== pluginDescriptorsPass;\n                }))));\n                _iterator = _createForOfIteratorHelper(presets);\n                _context.prev = 22;\n                _iterator.s();\n              case 24:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 36;\n                  break;\n                }\n                _step$value = _step.value, _preset = _step$value.preset, pass = _step$value.pass;\n                if (_preset) {\n                  _context.next = 28;\n                  break;\n                }\n                return _context.abrupt(\"return\", true);\n              case 28:\n                pass.push.apply(pass, _toConsumableArray(_preset.plugins));\n                return _context.delegateYield(recursePresetDescriptors(_preset.presets, pass), \"t2\", 30);\n              case 30:\n                _ignored = _context.t2;\n                if (!_ignored) {\n                  _context.next = 33;\n                  break;\n                }\n                return _context.abrupt(\"return\", true);\n              case 33:\n                _preset.options.forEach(function (opts) {\n                  (0, _util.mergeOptions)(optionDefaults, opts);\n                });\n              case 34:\n                _context.next = 24;\n                break;\n              case 36:\n                _context.next = 41;\n                break;\n              case 38:\n                _context.prev = 38;\n                _context.t3 = _context[\"catch\"](22);\n                _iterator.e(_context.t3);\n              case 41:\n                _context.prev = 41;\n                _iterator.f();\n                return _context.finish(41);\n              case 44:\n              case \"end\":\n                return _context.stop();\n            }\n          }, recursePresetDescriptors, null, [[5, 10], [22, 38, 41, 44]]);\n        }))(presetsDescriptors, pluginDescriptorsByPass[0]), \"t1\", 19);\n      case 19:\n        ignored = _context3.t1;\n        if (!ignored) {\n          _context3.next = 22;\n          break;\n        }\n        return _context3.abrupt(\"return\", null);\n      case 22:\n        opts = optionDefaults;\n        (0, _util.mergeOptions)(opts, options);\n        pluginContext = Object.assign({}, presetContext, {\n          assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}\n        });\n        return _context3.delegateYield(enhanceError(context, /*#__PURE__*/_regeneratorRuntime().mark(function loadPluginDescriptors() {\n          var _pluginDescriptorsByP;\n          var _i, _pluginDescriptorsByP2, descs, pass, i, descriptor, plugin;\n          return _regeneratorRuntime().wrap(function loadPluginDescriptors$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                (_pluginDescriptorsByP = pluginDescriptorsByPass[0]).unshift.apply(_pluginDescriptorsByP, _toConsumableArray(initialPluginsDescriptors));\n                _i = 0, _pluginDescriptorsByP2 = pluginDescriptorsByPass;\n              case 2:\n                if (!(_i < _pluginDescriptorsByP2.length)) {\n                  _context2.next = 27;\n                  break;\n                }\n                descs = _pluginDescriptorsByP2[_i];\n                pass = [];\n                passes.push(pass);\n                i = 0;\n              case 7:\n                if (!(i < descs.length)) {\n                  _context2.next = 24;\n                  break;\n                }\n                descriptor = descs[i];\n                if (!(descriptor.options !== false)) {\n                  _context2.next = 21;\n                  break;\n                }\n                _context2.prev = 10;\n                return _context2.delegateYield(loadPluginDescriptor(descriptor, pluginContext), \"t0\", 12);\n              case 12:\n                plugin = _context2.t0;\n                _context2.next = 19;\n                break;\n              case 15:\n                _context2.prev = 15;\n                _context2.t1 = _context2[\"catch\"](10);\n                if (_context2.t1.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n                  (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", _context2.t1);\n                }\n                throw _context2.t1;\n              case 19:\n                pass.push(plugin);\n                externalDependencies.push(plugin.externalDependencies);\n              case 21:\n                i++;\n                _context2.next = 7;\n                break;\n              case 24:\n                _i++;\n                _context2.next = 2;\n                break;\n              case 27:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, loadPluginDescriptors, null, [[10, 15]]);\n        }))(), \"t2\", 26);\n      case 26:\n        opts.plugins = passes[0];\n        opts.presets = passes.slice(1).filter(function (plugins) {\n          return plugins.length > 0;\n        }).map(function (plugins) {\n          return {\n            plugins: plugins\n          };\n        });\n        opts.passPerPreset = opts.presets.length > 0;\n        return _context3.abrupt(\"return\", {\n          options: opts,\n          passes: passes,\n          externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n        });\n      case 30:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, loadFullConfig);\n}));\nexports.default = _default;\nfunction enhanceError(context, fn) {\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee(arg1, arg2) {\n    var _context$filename;\n    return _regeneratorRuntime().wrap(function _callee$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.prev = 0;\n          return _context4.delegateYield(fn(arg1, arg2), \"t0\", 2);\n        case 2:\n          return _context4.abrupt(\"return\", _context4.t0);\n        case 5:\n          _context4.prev = 5;\n          _context4.t1 = _context4[\"catch\"](0);\n          if (!/^\\[BABEL\\]/.test(_context4.t1.message)) {\n            _context4.t1.message = \"[BABEL] \".concat((_context$filename = context.filename) != null ? _context$filename : \"unknown file\", \": \").concat(_context4.t1.message);\n          }\n          throw _context4.t1;\n        case 9:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee, null, [[0, 5]]);\n  });\n}\nvar makeDescriptorLoader = function makeDescriptorLoader(apiFactory) {\n  return (0, _caching.makeWeakCache)(function (_ref, cache) {\n    var value = _ref.value,\n      options = _ref.options,\n      dirname = _ref.dirname,\n      alias = _ref.alias;\n    return /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var externalDependencies, item, factory, api, error;\n      return _regeneratorRuntime().wrap(function _callee2$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!(options === false)) {\n              _context5.next = 2;\n              break;\n            }\n            throw new Error(\"Assertion failure\");\n          case 2:\n            options = options || {};\n            externalDependencies = [];\n            item = value;\n            if (!(typeof value === \"function\")) {\n              _context5.next = 17;\n              break;\n            }\n            factory = (0, _async.maybeAsync)(value, \"You appear to be using an async plugin/preset, but Babel has been called synchronously\");\n            api = Object.assign({}, context, apiFactory(cache, externalDependencies));\n            _context5.prev = 8;\n            return _context5.delegateYield(factory(api, options, dirname), \"t0\", 10);\n          case 10:\n            item = _context5.t0;\n            _context5.next = 17;\n            break;\n          case 13:\n            _context5.prev = 13;\n            _context5.t1 = _context5[\"catch\"](8);\n            if (alias) {\n              _context5.t1.message += \" (While processing: \".concat(JSON.stringify(alias), \")\");\n            }\n            throw _context5.t1;\n          case 17:\n            if (!(!item || typeof item !== \"object\")) {\n              _context5.next = 19;\n              break;\n            }\n            throw new Error(\"Plugin/Preset did not return an object.\");\n          case 19:\n            if (!(0, _async.isThenable)(item)) {\n              _context5.next = 22;\n              break;\n            }\n            return _context5.delegateYield([], \"t2\", 21);\n          case 21:\n            throw new Error(\"You appear to be using a promise as a plugin, \" + \"which your current version of Babel does not support. \" + \"If you're using a published plugin, \" + \"you may need to upgrade your @babel/core version. \" + \"As an alternative, you can prefix the promise with \\\"await\\\". \" + \"(While processing: \".concat(JSON.stringify(alias), \")\"));\n          case 22:\n            if (!(externalDependencies.length > 0 && (!cache.configured() || cache.mode() === \"forever\"))) {\n              _context5.next = 27;\n              break;\n            }\n            error = \"A plugin/preset has external untracked dependencies \" + \"(\".concat(externalDependencies[0], \"), but the cache \");\n            if (!cache.configured()) {\n              error += \"has not been configured to be invalidated when the external dependencies change. \";\n            } else {\n              error += \" has been configured to never be invalidated. \";\n            }\n            error += \"Plugins/presets should configure their cache to be invalidated when the external \" + \"dependencies change, for example using `api.cache.invalidate(() => \" + \"statSync(filepath).mtimeMs)` or `api.cache.never()`\\n\" + \"(While processing: \".concat(JSON.stringify(alias), \")\");\n            throw new Error(error);\n          case 27:\n            return _context5.abrupt(\"return\", {\n              value: item,\n              options: options,\n              dirname: dirname,\n              alias: alias,\n              externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n            });\n          case 28:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee2, null, [[8, 13]]);\n    })();\n  });\n};\nvar pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);\nvar presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);\nvar instantiatePlugin = (0, _caching.makeWeakCache)(function (_ref2, cache) {\n  var value = _ref2.value,\n    options = _ref2.options,\n    dirname = _ref2.dirname,\n    alias = _ref2.alias,\n    externalDependencies = _ref2.externalDependencies;\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var pluginObj, plugin, inheritsDescriptor, inherits;\n    return _regeneratorRuntime().wrap(function _callee3$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          pluginObj = (0, _plugins.validatePluginObject)(value);\n          plugin = Object.assign({}, pluginObj);\n          if (plugin.visitor) {\n            plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n          }\n          if (!plugin.inherits) {\n            _context6.next = 12;\n            break;\n          }\n          inheritsDescriptor = {\n            name: undefined,\n            alias: \"\".concat(alias, \"$inherits\"),\n            value: plugin.inherits,\n            options: options,\n            dirname: dirname\n          };\n          return _context6.delegateYield((0, _async.forwardAsync)(loadPluginDescriptor, function (run) {\n            return cache.invalidate(function (data) {\n              return run(inheritsDescriptor, data);\n            });\n          }), \"t0\", 6);\n        case 6:\n          inherits = _context6.t0;\n          plugin.pre = chain(inherits.pre, plugin.pre);\n          plugin.post = chain(inherits.post, plugin.post);\n          plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n          plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n          if (inherits.externalDependencies.length > 0) {\n            if (externalDependencies.length === 0) {\n              externalDependencies = inherits.externalDependencies;\n            } else {\n              externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);\n            }\n          }\n        case 12:\n          return _context6.abrupt(\"return\", new _plugin.default(plugin, options, alias, externalDependencies));\n        case 13:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee3);\n  })();\n});\nfunction loadPluginDescriptor(descriptor, context) {\n  return _regeneratorRuntime().wrap(function loadPluginDescriptor$(_context7) {\n    while (1) switch (_context7.prev = _context7.next) {\n      case 0:\n        if (!(descriptor.value instanceof _plugin.default)) {\n          _context7.next = 4;\n          break;\n        }\n        if (!descriptor.options) {\n          _context7.next = 3;\n          break;\n        }\n        throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n      case 3:\n        return _context7.abrupt(\"return\", descriptor.value);\n      case 4:\n        _context7.t0 = instantiatePlugin;\n        return _context7.delegateYield(pluginDescriptorLoader(descriptor, context), \"t1\", 6);\n      case 6:\n        _context7.t2 = _context7.t1;\n        _context7.t3 = context;\n        return _context7.delegateYield((0, _context7.t0)(_context7.t2, _context7.t3), \"t4\", 9);\n      case 9:\n        return _context7.abrupt(\"return\", _context7.t4);\n      case 10:\n      case \"end\":\n        return _context7.stop();\n    }\n  }, _marked);\n}\nvar needsFilename = function needsFilename(val) {\n  return val && typeof val !== \"function\";\n};\nvar validateIfOptionNeedsFilename = function validateIfOptionNeedsFilename(options, descriptor) {\n  if (needsFilename(options.test) || needsFilename(options.include) || needsFilename(options.exclude)) {\n    var formattedPresetName = descriptor.name ? \"\\\"\".concat(descriptor.name, \"\\\"\") : \"/* your preset */\";\n    throw new _configError.default([\"Preset \".concat(formattedPresetName, \" requires a filename to be set when babel is called directly,\"), \"```\", \"babel.transformSync(code, { filename: 'file.ts', presets: [\".concat(formattedPresetName, \"] });\"), \"```\", \"See https://babeljs.io/docs/en/options#filename for more information.\"].join(\"\\n\"));\n  }\n};\nvar validatePreset = function validatePreset(preset, context, descriptor) {\n  if (!context.filename) {\n    var options = preset.options;\n    validateIfOptionNeedsFilename(options, descriptor);\n    if (options.overrides) {\n      options.overrides.forEach(function (overrideOptions) {\n        return validateIfOptionNeedsFilename(overrideOptions, descriptor);\n      });\n    }\n  }\n};\nvar instantiatePreset = (0, _caching.makeWeakCacheSync)(function (_ref3) {\n  var value = _ref3.value,\n    dirname = _ref3.dirname,\n    alias = _ref3.alias,\n    externalDependencies = _ref3.externalDependencies;\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias: alias,\n    dirname: dirname,\n    externalDependencies: externalDependencies\n  };\n});\nfunction loadPresetDescriptor(descriptor, context) {\n  var preset;\n  return _regeneratorRuntime().wrap(function loadPresetDescriptor$(_context8) {\n    while (1) switch (_context8.prev = _context8.next) {\n      case 0:\n        _context8.t0 = instantiatePreset;\n        return _context8.delegateYield(presetDescriptorLoader(descriptor, context), \"t1\", 2);\n      case 2:\n        _context8.t2 = _context8.t1;\n        preset = (0, _context8.t0)(_context8.t2);\n        validatePreset(preset, context, descriptor);\n        return _context8.delegateYield((0, _configChain.buildPresetChain)(preset, context), \"t3\", 6);\n      case 6:\n        _context8.t4 = _context8.t3;\n        _context8.t5 = preset.externalDependencies;\n        return _context8.abrupt(\"return\", {\n          chain: _context8.t4,\n          externalDependencies: _context8.t5\n        });\n      case 9:\n      case \"end\":\n        return _context8.stop();\n    }\n  }, _marked2);\n}\nfunction chain(a, b) {\n  var fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var _iterator2 = _createForOfIteratorHelper(fns),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var fn = _step2.value;\n        fn.apply(this, args);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  };\n}\n0 && 0;","map":null,"metadata":{},"sourceType":"script"}