{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = normalize;\nvar _crypto;\nfunction _load_crypto() {\n  return _crypto = _interopRequireDefault(require('crypto'));\n}\nvar _glob;\nfunction _load_glob() {\n  return _glob = _interopRequireDefault(require('glob'));\n}\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _jestValidate;\nfunction _load_jestValidate() {\n  return _jestValidate = require('jest-validate');\n}\nvar _validatePattern;\nfunction _load_validatePattern() {\n  return _validatePattern = _interopRequireDefault(require('./validatePattern'));\n}\nvar _jestUtil;\nfunction _load_jestUtil() {\n  return _jestUtil = require('jest-util');\n}\nvar _chalk;\nfunction _load_chalk() {\n  return _chalk = _interopRequireDefault(require('chalk'));\n}\nvar _getMaxWorkers;\nfunction _load_getMaxWorkers() {\n  return _getMaxWorkers = _interopRequireDefault(require('./getMaxWorkers'));\n}\nvar _micromatch;\nfunction _load_micromatch() {\n  return _micromatch = _interopRequireDefault(require('micromatch'));\n}\nvar _jestResolve;\nfunction _load_jestResolve() {\n  return _jestResolve = _interopRequireDefault(require('jest-resolve'));\n}\nvar _jestRegexUtil;\nfunction _load_jestRegexUtil() {\n  return _jestRegexUtil = require('jest-regex-util');\n}\nvar _utils;\nfunction _load_utils() {\n  return _utils = require('./utils');\n}\nvar _constants;\nfunction _load_constants() {\n  return _constants = require('./constants');\n}\nvar _ReporterValidationErrors;\nfunction _load_ReporterValidationErrors() {\n  return _ReporterValidationErrors = require('./ReporterValidationErrors');\n}\nvar _Defaults;\nfunction _load_Defaults() {\n  return _Defaults = _interopRequireDefault(require('./Defaults'));\n}\nvar _Deprecated;\nfunction _load_Deprecated() {\n  return _Deprecated = _interopRequireDefault(require('./Deprecated'));\n}\nvar _setFromArgv;\nfunction _load_setFromArgv() {\n  return _setFromArgv = _interopRequireDefault(require('./setFromArgv'));\n}\nvar _ValidConfig;\nfunction _load_ValidConfig() {\n  return _ValidConfig = _interopRequireDefault(require('./ValidConfig'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar ERROR = \"\".concat((_utils || _load_utils()).BULLET, \"Validation Error\");\nvar PRESET_EXTENSIONS = ['.json', '.js'];\nvar PRESET_NAME = 'jest-preset';\nvar createConfigError = function createConfigError(message) {\n  return new (_jestValidate || _load_jestValidate()).ValidationError(ERROR, message, (_utils || _load_utils()).DOCUMENTATION_NOTE);\n};\nvar mergeOptionWithPreset = function mergeOptionWithPreset(options, preset, optionName) {\n  if (options[optionName] && preset[optionName]) {\n    options[optionName] = Object.assign({}, options[optionName], preset[optionName], options[optionName]);\n  }\n};\nvar setupPreset = function setupPreset(options, optionsPreset) {\n  var preset;\n  var presetPath = (0, (_utils || _load_utils()).replaceRootDirInPath)(options.rootDir, optionsPreset);\n  var presetModule = (_jestResolve || _load_jestResolve()).default.findNodeModule(presetPath.startsWith('.') ? presetPath : (_path || _load_path()).default.join(presetPath, PRESET_NAME), {\n    basedir: options.rootDir,\n    extensions: PRESET_EXTENSIONS\n  });\n  try {\n    // Force re-evaluation to support multiple projects\n    try {\n      if (presetModule) {\n        delete require.cache[require.resolve(presetModule)];\n      }\n    } catch (e) {}\n\n    // $FlowFixMe\n    preset = require(presetModule);\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      throw createConfigError(\"  Preset \".concat((_chalk || _load_chalk()).default.bold(presetPath), \" is invalid:\\n  \").concat(error.message));\n    }\n    var _preset = (_jestResolve || _load_jestResolve()).default.findNodeModule(presetPath, {\n      basedir: options.rootDir\n    });\n    if (_preset) {\n      throw createConfigError(\"  Module \".concat((_chalk || _load_chalk()).default.bold(presetPath), \" should have \\\"jest-preset.js\\\" or \\\"jest-preset.json\\\" file at the root.\"));\n    }\n    throw createConfigError(\"  Preset \".concat((_chalk || _load_chalk()).default.bold(presetPath), \" not found.\"));\n  }\n  if (options.setupFiles) {\n    options.setupFiles = (preset.setupFiles || []).concat(options.setupFiles);\n  }\n  if (options.modulePathIgnorePatterns && preset.modulePathIgnorePatterns) {\n    options.modulePathIgnorePatterns = preset.modulePathIgnorePatterns.concat(options.modulePathIgnorePatterns);\n  }\n  mergeOptionWithPreset(options, preset, 'moduleNameMapper');\n  mergeOptionWithPreset(options, preset, 'transform');\n  return Object.assign({}, preset, options);\n};\nvar setupBabelJest = function setupBabelJest(options) {\n  var transform = options.transform;\n  var babelJest;\n  if (transform) {\n    var customJSPattern = Object.keys(transform).find(function (pattern) {\n      var regex = new RegExp(pattern);\n      return regex.test('a.js') || regex.test('a.jsx');\n    });\n    if (customJSPattern) {\n      var customJSTransformer = transform[customJSPattern];\n      if (customJSTransformer === 'babel-jest') {\n        babelJest = require.resolve('babel-jest');\n        transform[customJSPattern] = babelJest;\n      } else if (customJSTransformer.includes('babel-jest')) {\n        babelJest = customJSTransformer;\n      }\n    }\n  } else {\n    babelJest = require.resolve('babel-jest');\n    options.transform = _defineProperty({}, (_constants || _load_constants()).DEFAULT_JS_PATTERN, babelJest);\n  }\n  return babelJest;\n};\nvar normalizeCollectCoverageOnlyFrom = function normalizeCollectCoverageOnlyFrom(options, key) {\n  var collectCoverageOnlyFrom = Array.isArray(options[key]) ? options[key] // passed from argv\n  : Object.keys(options[key]); // passed from options\n  return collectCoverageOnlyFrom.reduce(function (map, filePath) {\n    filePath = (_path || _load_path()).default.resolve(options.rootDir, (0, (_utils || _load_utils()).replaceRootDirInPath)(options.rootDir, filePath));\n    map[filePath] = true;\n    return map;\n  }, Object.create(null));\n};\nvar normalizeCollectCoverageFrom = function normalizeCollectCoverageFrom(options, key) {\n  var value;\n  if (!options[key]) {\n    value = [];\n  }\n  if (!Array.isArray(options[key])) {\n    try {\n      value = JSON.parse(options[key]);\n    } catch (e) {}\n    Array.isArray(value) || (value = [options[key]]);\n  } else {\n    value = options[key];\n  }\n  if (value) {\n    value = value.map(function (filePath) {\n      return filePath.replace(/^(!?)(<rootDir>\\/)(.*)/, '$1$3');\n    });\n  }\n  return value;\n};\nvar normalizeUnmockedModulePathPatterns = function normalizeUnmockedModulePathPatterns(options, key\n// _replaceRootDirTags is specifically well-suited for substituting\n// <rootDir> in paths (it deals with properly interpreting relative path\n// separators, etc).\n//\n// For patterns, direct global substitution is far more ideal, so we\n// special case substitutions for patterns here.\n) {\n  return options[key].map(function (pattern) {\n    return (0, (_jestRegexUtil || _load_jestRegexUtil()).replacePathSepForRegex)(pattern.replace(/<rootDir>/g, options.rootDir));\n  });\n};\nvar normalizePreprocessor = function normalizePreprocessor(options) {\n  if (options.scriptPreprocessor && options.transform) {\n    throw createConfigError(\"  Options: \".concat((_chalk || _load_chalk()).default.bold('scriptPreprocessor'), \" and \").concat((_chalk || _load_chalk()).default.bold('transform'), \" cannot be used together.\\n  Please change your configuration to only use \").concat((_chalk || _load_chalk()).default.bold('transform'), \".\"));\n  }\n  if (options.preprocessorIgnorePatterns && options.transformIgnorePatterns) {\n    throw createConfigError(\"  Options \".concat((_chalk || _load_chalk()).default.bold('preprocessorIgnorePatterns'), \" and \").concat((_chalk || _load_chalk()).default.bold('transformIgnorePatterns'), \" cannot be used together.\\n  Please change your configuration to only use \").concat((_chalk || _load_chalk()).default.bold('transformIgnorePatterns'), \".\"));\n  }\n  if (options.scriptPreprocessor) {\n    options.transform = {\n      '.*': options.scriptPreprocessor\n    };\n  }\n  if (options.preprocessorIgnorePatterns) {\n    options.transformIgnorePatterns = options.preprocessorIgnorePatterns;\n  }\n  delete options.scriptPreprocessor;\n  delete options.preprocessorIgnorePatterns;\n  return options;\n};\nvar normalizeMissingOptions = function normalizeMissingOptions(options) {\n  if (!options.name) {\n    options.name = (_crypto || _load_crypto()).default.createHash('md5').update(options.rootDir).digest('hex');\n  }\n  if (!options.setupFiles) {\n    options.setupFiles = [];\n  }\n  return options;\n};\nvar normalizeRootDir = function normalizeRootDir(options) {\n  // Assert that there *is* a rootDir\n  if (!options.hasOwnProperty('rootDir')) {\n    throw createConfigError(\"  Configuration option \".concat((_chalk || _load_chalk()).default.bold('rootDir'), \" must be specified.\"));\n  }\n  options.rootDir = (_path || _load_path()).default.normalize(options.rootDir);\n  return options;\n};\nvar normalizeReporters = function normalizeReporters(options, basedir) {\n  var reporters = options.reporters;\n  if (!reporters || !Array.isArray(reporters)) {\n    return options;\n  }\n  (0, (_ReporterValidationErrors || _load_ReporterValidationErrors()).validateReporters)(reporters);\n  options.reporters = reporters.map(function (reporterConfig) {\n    var normalizedReporterConfig = typeof reporterConfig === 'string' // if reporter config is a string, we wrap it in an array\n    ?\n    // and pass an empty object for options argument, to normalize\n    // the shape.\n    [reporterConfig, {}] : reporterConfig;\n    var reporterPath = (0, (_utils || _load_utils()).replaceRootDirInPath)(options.rootDir, normalizedReporterConfig[0]);\n    if (reporterPath !== (_constants || _load_constants()).DEFAULT_REPORTER_LABEL) {\n      var reporter = (_jestResolve || _load_jestResolve()).default.findNodeModule(reporterPath, {\n        basedir: options.rootDir\n      });\n      if (!reporter) {\n        throw new Error(\"Could not resolve a module for a custom reporter.\\n\" + \"  Module name: \".concat(reporterPath));\n      }\n      normalizedReporterConfig[0] = reporter;\n    }\n    return normalizedReporterConfig;\n  });\n  return options;\n};\nvar buildTestPathPattern = function buildTestPathPattern(argv) {\n  var patterns = [];\n  if (argv._) {\n    patterns.push.apply(patterns, _toConsumableArray(argv._));\n  }\n  if (argv.testPathPattern) {\n    patterns.push.apply(patterns, _toConsumableArray(argv.testPathPattern));\n  }\n  var replacePosixSep = function replacePosixSep(pattern) {\n    if ((_path || _load_path()).default.sep === '/') {\n      return pattern;\n    }\n    return pattern.replace(/\\//g, '\\\\\\\\');\n  };\n  var testPathPattern = patterns.map(replacePosixSep).join('|');\n  if ((0, (_validatePattern || _load_validatePattern()).default)(testPathPattern)) {\n    return testPathPattern;\n  } else {\n    showTestPathPatternError(testPathPattern);\n    return '';\n  }\n};\nvar showTestPathPatternError = function showTestPathPatternError(testPathPattern) {\n  (0, (_jestUtil || _load_jestUtil()).clearLine)(process.stdout);\n  console.log((_chalk || _load_chalk()).default.red(\"  Invalid testPattern \".concat(testPathPattern, \" supplied. \") + \"Running all tests instead.\"));\n};\nfunction normalize(options, argv) {\n  var _validate = (0, (_jestValidate || _load_jestValidate()).validate)(options, {\n    comment: (_utils || _load_utils()).DOCUMENTATION_NOTE,\n    deprecatedConfig: (_Deprecated || _load_Deprecated()).default,\n    exampleConfig: (_ValidConfig || _load_ValidConfig()).default,\n    recursiveBlacklist: ['collectCoverageOnlyFrom',\n    // 'coverageThreshold' allows to use 'global' and glob strings on the same\n    // level, there's currently no way we can deal with such config\n    'coverageThreshold', 'globals', 'moduleNameMapper', 'testEnvironmentOptions', 'transform']\n  });\n  var hasDeprecationWarnings = _validate.hasDeprecationWarnings;\n  options = normalizePreprocessor(normalizeReporters(normalizeMissingOptions(normalizeRootDir((0, (_setFromArgv || _load_setFromArgv()).default)(options, argv)))));\n  if (options.preset) {\n    options = setupPreset(options, options.preset);\n  }\n  if (options.testEnvironment) {\n    options.testEnvironment = (0, (_utils || _load_utils()).getTestEnvironment)(options);\n  }\n  if (!options.roots && options.testPathDirs) {\n    options.roots = options.testPathDirs;\n    delete options.testPathDirs;\n  }\n  if (!options.roots) {\n    options.roots = [options.rootDir];\n  }\n  if (!options.testRunner || options.testRunner === 'jasmine2') {\n    options.testRunner = require.resolve('jest-jasmine2');\n  }\n  if (!options.coverageDirectory) {\n    options.coverageDirectory = (_path || _load_path()).default.resolve(options.rootDir, 'coverage');\n  }\n  var babelJest = setupBabelJest(options);\n  var newOptions = Object.assign({}, (_Defaults || _load_Defaults()).default);\n  // Cast back to exact type\n  options = options;\n  if (options.resolver) {\n    newOptions.resolver = (0, (_utils || _load_utils()).resolve)(null, {\n      filePath: options.resolver,\n      key: 'resolver',\n      rootDir: options.rootDir\n    });\n  }\n  Object.keys(options).reduce(function (newOptions, key) {\n    // The resolver has been resolved separately; skip it\n    if (key === 'resolver') {\n      return newOptions;\n    }\n    var value;\n    switch (key) {\n      case 'collectCoverageOnlyFrom':\n        value = normalizeCollectCoverageOnlyFrom(options, key);\n        break;\n      case 'setupFiles':\n      case 'snapshotSerializers':\n        value = options[key] && options[key].map(function (filePath) {\n          return (0, (_utils || _load_utils()).resolve)(newOptions.resolver, {\n            filePath: filePath,\n            key: key,\n            rootDir: options.rootDir\n          });\n        });\n        break;\n      case 'modulePaths':\n      case 'roots':\n        value = options[key] && options[key].map(function (filePath) {\n          return (_path || _load_path()).default.resolve(options.rootDir, (0, (_utils || _load_utils()).replaceRootDirInPath)(options.rootDir, filePath));\n        });\n        break;\n      case 'collectCoverageFrom':\n        value = normalizeCollectCoverageFrom(options, key);\n        break;\n      case 'cacheDirectory':\n      case 'coverageDirectory':\n        value = options[key] && (_path || _load_path()).default.resolve(options.rootDir, (0, (_utils || _load_utils()).replaceRootDirInPath)(options.rootDir, options[key]));\n        break;\n      case 'globalSetup':\n      case 'globalTeardown':\n      case 'moduleLoader':\n      case 'runner':\n      case 'setupTestFrameworkScriptFile':\n      case 'testResultsProcessor':\n      case 'testRunner':\n      case 'filter':\n        value = options[key] && (0, (_utils || _load_utils()).resolve)(newOptions.resolver, {\n          filePath: options[key],\n          key: key,\n          rootDir: options.rootDir\n        });\n        break;\n      case 'prettierPath':\n        // We only want this to throw if \"prettierPath\" is explicitly passed\n        // from config or CLI, and the requested path isn't found. Otherwise we\n        // set it to null and throw an error lazily when it is used.\n        value = options[key] && (0, (_utils || _load_utils()).resolve)(newOptions.resolver, {\n          filePath: options[key],\n          key: key,\n          optional: options[key] === (_Defaults || _load_Defaults()).default[key],\n          rootDir: options.rootDir\n        });\n        break;\n      case 'moduleNameMapper':\n        var moduleNameMapper = options[key];\n        value = moduleNameMapper && Object.keys(moduleNameMapper).map(function (regex) {\n          var item = moduleNameMapper && moduleNameMapper[regex];\n          return item && [regex, (0, (_utils || _load_utils())._replaceRootDirTags)(options.rootDir, item)];\n        });\n        break;\n      case 'transform':\n        var transform = options[key];\n        value = transform && Object.keys(transform).map(function (regex) {\n          return [regex, (0, (_utils || _load_utils()).resolve)(newOptions.resolver, {\n            filePath: transform[regex],\n            key: key,\n            rootDir: options.rootDir\n          })];\n        });\n        break;\n      case 'coveragePathIgnorePatterns':\n      case 'modulePathIgnorePatterns':\n      case 'testPathIgnorePatterns':\n      case 'transformIgnorePatterns':\n      case 'watchPathIgnorePatterns':\n      case 'unmockedModulePathPatterns':\n        value = normalizeUnmockedModulePathPatterns(options, key);\n        break;\n      case 'haste':\n        value = Object.assign({}, options[key]);\n        if (value.hasteImplModulePath != null) {\n          value.hasteImplModulePath = (0, (_utils || _load_utils()).resolve)(newOptions.resolver, {\n            filePath: (0, (_utils || _load_utils()).replaceRootDirInPath)(options.rootDir, value.hasteImplModulePath),\n            key: 'haste.hasteImplModulePath',\n            rootDir: options.rootDir\n          });\n        }\n        break;\n      case 'projects':\n        value = (options[key] || []).map(function (project) {\n          return typeof project === 'string' ? (0, (_utils || _load_utils())._replaceRootDirTags)(options.rootDir, project) : project;\n        }).reduce(function (projects, project) {\n          // Project can be specified as globs. If a glob matches any files,\n          // We expand it to these paths. If not, we keep the original path\n          // for the future resolution.\n          var globMatches = typeof project === 'string' ? (_glob || _load_glob()).default.sync(project) : [];\n          return projects.concat(globMatches.length ? globMatches : project);\n        }, []);\n        break;\n      case 'moduleDirectories':\n      case 'testMatch':\n        value = (0, (_utils || _load_utils())._replaceRootDirTags)((0, (_utils || _load_utils()).escapeGlobCharacters)(options.rootDir), options[key]);\n        break;\n      case 'testRegex':\n        value = options[key] && (0, (_jestRegexUtil || _load_jestRegexUtil()).replacePathSepForRegex)(options[key]);\n        break;\n      case 'automock':\n      case 'bail':\n      case 'browser':\n      case 'cache':\n      case 'changedSince':\n      case 'changedFilesWithAncestor':\n      case 'clearMocks':\n      case 'collectCoverage':\n      case 'coverageReporters':\n      case 'coverageThreshold':\n      case 'detectLeaks':\n      case 'detectOpenHandles':\n      case 'displayName':\n      case 'errorOnDeprecated':\n      case 'expand':\n      case 'globals':\n      case 'findRelatedTests':\n      case 'forceCoverageMatch':\n      case 'forceExit':\n      case 'lastCommit':\n      case 'listTests':\n      case 'logHeapUsage':\n      case 'mapCoverage':\n      case 'moduleFileExtensions':\n      case 'name':\n      case 'noStackTrace':\n      case 'notify':\n      case 'notifyMode':\n      case 'onlyChanged':\n      case 'outputFile':\n      case 'passWithNoTests':\n      case 'replname':\n      case 'reporters':\n      case 'resetMocks':\n      case 'resetModules':\n      case 'restoreMocks':\n      case 'rootDir':\n      case 'runTestsByPath':\n      case 'silent':\n      case 'skipFilter':\n      case 'skipNodeResolution':\n      case 'testEnvironment':\n      case 'testEnvironmentOptions':\n      case 'testFailureExitCode':\n      case 'testLocationInResults':\n      case 'testNamePattern':\n      case 'testURL':\n      case 'timers':\n      case 'useStderr':\n      case 'verbose':\n      case 'watch':\n      case 'watchAll':\n      case 'watchman':\n        value = options[key];\n        break;\n      case 'watchPlugins':\n        value = (options[key] || []).map(function (watchPlugin) {\n          if (typeof watchPlugin === 'string') {\n            return {\n              config: {},\n              path: (0, (_utils || _load_utils()).resolve)(newOptions.resolver, {\n                filePath: watchPlugin,\n                key: key,\n                rootDir: options.rootDir\n              })\n            };\n          } else {\n            return {\n              config: watchPlugin[1] || {},\n              path: (0, (_utils || _load_utils()).resolve)(newOptions.resolver, {\n                filePath: watchPlugin[0],\n                key: key,\n                rootDir: options.rootDir\n              })\n            };\n          }\n        });\n        break;\n    }\n    newOptions[key] = value;\n    return newOptions;\n  }, newOptions);\n  newOptions.nonFlagArgs = argv._;\n  newOptions.testPathPattern = buildTestPathPattern(argv);\n  newOptions.json = argv.json;\n  newOptions.testFailureExitCode = parseInt(newOptions.testFailureExitCode, 10);\n  for (var _i = 0, _arr = ['lastCommit', 'changedFilesWithAncestor', 'changedSince']; _i < _arr.length; _i++) {\n    var key = _arr[_i];\n    if (newOptions[key]) {\n      newOptions.onlyChanged = true;\n    }\n  }\n  if (argv.all) {\n    newOptions.onlyChanged = false;\n  } else if (newOptions.testPathPattern) {\n    // When passing a test path pattern we don't want to only monitor changed\n    // files unless `--watch` is also passed.\n    newOptions.onlyChanged = newOptions.watch;\n  }\n  newOptions.updateSnapshot = argv.ci && !argv.updateSnapshot ? 'none' : argv.updateSnapshot ? 'all' : 'new';\n  newOptions.maxWorkers = (0, (_getMaxWorkers || _load_getMaxWorkers()).default)(argv);\n  if (babelJest) {\n    var regeneratorRuntimePath = (_jestResolve || _load_jestResolve()).default.findNodeModule('regenerator-runtime/runtime', {\n      basedir: options.rootDir,\n      resolver: newOptions.resolver\n    });\n    if (regeneratorRuntimePath) {\n      newOptions.setupFiles.unshift(regeneratorRuntimePath);\n    }\n  }\n  if (options.testRegex && options.testMatch) {\n    throw createConfigError(\"  Configuration options \".concat((_chalk || _load_chalk()).default.bold('testMatch'), \" and\") + \" \".concat((_chalk || _load_chalk()).default.bold('testRegex'), \" cannot be used together.\"));\n  }\n  if (options.testRegex && !options.testMatch) {\n    // Prevent the default testMatch conflicting with any explicitly\n    // configured `testRegex` value\n    newOptions.testMatch = [];\n  }\n\n  // If argv.json is set, coverageReporters shouldn't print a text report.\n  if (argv.json) {\n    newOptions.coverageReporters = (newOptions.coverageReporters || []).filter(function (reporter) {\n      return reporter !== 'text';\n    });\n  }\n\n  // If collectCoverage is enabled while using --findRelatedTests we need to\n  // avoid having false negatives in the generated coverage report.\n  // The following: `--findRelatedTests '/rootDir/file1.js' --coverage`\n  // Is transformed to: `--findRelatedTests '/rootDir/file1.js' --coverage --collectCoverageFrom 'file1.js'`\n  // where arguments to `--collectCoverageFrom` should be globs (or relative\n  // paths to the rootDir)\n  if (newOptions.collectCoverage && argv.findRelatedTests) {\n    var collectCoverageFrom = argv._.map(function (filename) {\n      filename = (0, (_utils || _load_utils()).replaceRootDirInPath)(options.rootDir, filename);\n      return (_path || _load_path()).default.isAbsolute(filename) ? (_path || _load_path()).default.relative(options.rootDir, filename) : filename;\n    });\n\n    // Don't override existing collectCoverageFrom options\n    if (newOptions.collectCoverageFrom) {\n      collectCoverageFrom = collectCoverageFrom.reduce(function (patterns, filename) {\n        if (!(0, (_micromatch || _load_micromatch()).default)([(_path || _load_path()).default.relative(options.rootDir, filename)], newOptions.collectCoverageFrom).length) {\n          return patterns;\n        }\n        return [].concat(_toConsumableArray(patterns), [filename]);\n      }, newOptions.collectCoverageFrom);\n    }\n    newOptions.collectCoverageFrom = collectCoverageFrom;\n  }\n  return {\n    hasDeprecationWarnings: hasDeprecationWarnings,\n    options: newOptions\n  };\n}","map":null,"metadata":{},"sourceType":"script"}