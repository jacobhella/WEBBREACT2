{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\"use strict\";\n\nvar FileCoverage = require('./file').FileCoverage,\n  CoverageSummary = require('./file').CoverageSummary;\nfunction loadMap(source) {\n  var data = {};\n  Object.keys(source).forEach(function (k) {\n    var cov = source[k];\n    if (cov instanceof FileCoverage) {\n      data[k] = cov;\n    } else {\n      data[k] = new FileCoverage(cov);\n    }\n  });\n  return data;\n}\n/**\n * CoverageMap is a map of `FileCoverage` objects keyed by file paths.\n * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n * map's contents. This can be the raw global coverage object.\n * @constructor\n */\nfunction CoverageMap(obj) {\n  if (!obj) {\n    this.data = {};\n  } else if (obj instanceof CoverageMap) {\n    this.data = obj.data;\n  } else {\n    this.data = loadMap(obj);\n  }\n}\n/**\n * merges a second coverage map into this one\n * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n *  correctly for the same files and additional file coverage keys are created\n *  as needed.\n */\nCoverageMap.prototype.merge = function (obj) {\n  var that = this,\n    other;\n  if (obj instanceof CoverageMap) {\n    other = obj;\n  } else {\n    other = new CoverageMap(obj);\n  }\n  Object.keys(other.data).forEach(function (k) {\n    var fc = other.data[k];\n    if (that.data[k]) {\n      that.data[k].merge(fc);\n    } else {\n      that.data[k] = fc;\n    }\n  });\n};\n/**\n * filter the coveragemap based on the callback provided\n * @param {Function (filename)} callback - Returns true if the path\n *  should be included in the coveragemap. False if it should be\n *  removed.\n */\nCoverageMap.prototype.filter = function (callback) {\n  var that = this;\n  Object.keys(that.data).forEach(function (k) {\n    if (!callback(k)) {\n      delete that.data[k];\n    }\n  });\n};\n/**\n * returns a JSON-serializable POJO for this coverage map\n * @returns {Object}\n */\nCoverageMap.prototype.toJSON = function () {\n  return this.data;\n};\n/**\n * returns an array for file paths for which this map has coverage\n * @returns {Array{string}} - array of files\n */\nCoverageMap.prototype.files = function () {\n  return Object.keys(this.data);\n};\n/**\n * returns the file coverage for the specified file.\n * @param {String} file\n * @returns {FileCoverage}\n */\nCoverageMap.prototype.fileCoverageFor = function (file) {\n  var fc = this.data[file];\n  if (!fc) {\n    throw new Error('No file coverage available for: ' + file);\n  }\n  return fc;\n};\n/**\n * adds a file coverage object to this map. If the path for the object,\n * already exists in the map, it is merged with the existing coverage\n * otherwise a new key is added to the map.\n * @param {FileCoverage} fc the file coverage to add\n */\nCoverageMap.prototype.addFileCoverage = function (fc) {\n  var cov = new FileCoverage(fc),\n    path = cov.path;\n  if (this.data[path]) {\n    this.data[path].merge(cov);\n  } else {\n    this.data[path] = cov;\n  }\n};\n/**\n * returns the coverage summary for all the file coverage objects in this map.\n * @returns {CoverageSummary}\n */\nCoverageMap.prototype.getCoverageSummary = function () {\n  var that = this,\n    ret = new CoverageSummary();\n  this.files().forEach(function (key) {\n    ret.merge(that.fileCoverageFor(key).toSummary());\n  });\n  return ret;\n};\nmodule.exports = {\n  CoverageMap: CoverageMap\n};","map":null,"metadata":{},"sourceType":"script"}