{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\"use strict\";\n\nvar util = require('util');\n/**\n * An object with methods that are called during the traversal of the coverage tree.\n * A visitor has the following methods that are called during tree traversal.\n *\n *   * `onStart(root, state)` - called before traversal begins\n *   * `onSummary(node, state)` - called for every summary node\n *   * `onDetail(node, state)` - called for every detail node\n *   * `onSummaryEnd(node, state)` - called after all children have been visited for\n *      a summary node.\n *   * `onEnd(root, state)` - called after traversal ends\n *\n * @param delegate - a partial visitor that only implements the methods of interest\n *  The visitor object supplies the missing methods as noops. For example, reports\n *  that only need the final coverage summary need implement `onStart` and nothing\n *  else. Reports that use only detailed coverage information need implement `onDetail`\n *  and nothing else.\n * @constructor\n */\nfunction Visitor(delegate) {\n  this.delegate = delegate;\n}\n['Start', 'End', 'Summary', 'SummaryEnd', 'Detail'].forEach(function (k) {\n  var f = 'on' + k;\n  Visitor.prototype[f] = function (node, state) {\n    if (this.delegate[f] && typeof this.delegate[f] === 'function') {\n      this.delegate[f].call(this.delegate, node, state);\n    }\n  };\n});\nfunction CompositeVisitor(visitors) {\n  if (!Array.isArray(visitors)) {\n    visitors = [visitors];\n  }\n  this.visitors = visitors.map(function (v) {\n    if (v instanceof Visitor) {\n      return v;\n    }\n    return new Visitor(v);\n  });\n}\nutil.inherits(CompositeVisitor, Visitor);\n['Start', 'Summary', 'SummaryEnd', 'Detail', 'End'].forEach(function (k) {\n  var f = 'on' + k;\n  CompositeVisitor.prototype[f] = function (node, state) {\n    this.visitors.forEach(function (v) {\n      v[f](node, state);\n    });\n  };\n});\nfunction Node() {}\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getQualifiedName = function () {\n  throw new Error('getQualifiedName must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getRelativeName = function () {\n  throw new Error('getRelativeName must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.isRoot = function () {\n  return !this.getParent();\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getParent = function () {\n  throw new Error('getParent must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getChildren = function () {\n  throw new Error('getChildren must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.isSummary = function () {\n  throw new Error('isSummary must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getCoverageSummary = function /* filesOnly */\n() {\n  throw new Error('getCoverageSummary must be overridden');\n};\n\n/* istanbul ignore next: abstract method */\nNode.prototype.getFileCoverage = function () {\n  throw new Error('getFileCoverage must be overridden');\n};\n/**\n * visit all nodes depth-first from this node down. Note that `onStart`\n * and `onEnd` are never called on the visitor even if the current\n * node is the root of the tree.\n * @param visitor a full visitor that is called during tree traversal\n * @param state optional state that is passed around\n */\nNode.prototype.visit = function (visitor, state) {\n  var that = this,\n    visitChildren = function visitChildren() {\n      that.getChildren().forEach(function (child) {\n        child.visit(visitor, state);\n      });\n    };\n  if (this.isSummary()) {\n    visitor.onSummary(this, state);\n  } else {\n    visitor.onDetail(this, state);\n  }\n  visitChildren();\n  if (this.isSummary()) {\n    visitor.onSummaryEnd(this, state);\n  }\n};\n\n/**\n * abstract base class for a coverage tree.\n * @constructor\n */\nfunction Tree() {}\n\n/**\n * returns the root node of the tree\n */\n/* istanbul ignore next: abstract method */\nTree.prototype.getRoot = function () {\n  throw new Error('getRoot must be overridden');\n};\n\n/**\n * visits the tree depth-first with the supplied partial visitor\n * @param visitor - a potentially partial visitor\n * @param state - the state to be passed around during tree traversal\n */\nTree.prototype.visit = function (visitor, state) {\n  if (!(visitor instanceof Visitor)) {\n    visitor = new Visitor(visitor);\n  }\n  visitor.onStart(this.getRoot(), state);\n  this.getRoot().visit(visitor, state);\n  visitor.onEnd(this.getRoot(), state);\n};\nmodule.exports = {\n  Tree: Tree,\n  Node: Node,\n  Visitor: Visitor,\n  CompositeVisitor: CompositeVisitor\n};","map":null,"metadata":{},"sourceType":"script"}