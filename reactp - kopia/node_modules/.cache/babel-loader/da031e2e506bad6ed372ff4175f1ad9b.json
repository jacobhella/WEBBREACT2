{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeModuleAndLoadMetadata;\nexports.hasExports = hasExports;\nexports.isSideEffectImport = isSideEffectImport;\nexports.validateImportInteropOption = validateImportInteropOption;\nvar _path = require(\"path\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\nfunction hasExports(metadata) {\n  return metadata.hasExports;\n}\nfunction isSideEffectImport(source) {\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\n}\nfunction validateImportInteropOption(importInterop) {\n  if (typeof importInterop !== \"function\" && importInterop !== \"none\" && importInterop !== \"babel\" && importInterop !== \"node\") {\n    throw new Error(\".importInterop must be one of \\\"none\\\", \\\"babel\\\", \\\"node\\\", or a function returning one of those values (received \".concat(importInterop, \").\"));\n  }\n  return importInterop;\n}\nfunction resolveImportInterop(importInterop, source, filename) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n  return importInterop;\n}\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, _ref) {\n  var importInterop = _ref.importInterop,\n    _ref$initializeReexpo = _ref.initializeReexports,\n    initializeReexports = _ref$initializeReexpo === void 0 ? false : _ref$initializeReexpo,\n    _ref$lazy = _ref.lazy,\n    lazy = _ref$lazy === void 0 ? false : _ref$lazy,\n    _ref$esNamespaceOnly = _ref.esNamespaceOnly,\n    esNamespaceOnly = _ref$esNamespaceOnly === void 0 ? false : _ref$esNamespaceOnly,\n    filename = _ref.filename;\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  var stringSpecifiers = new Set();\n  nameAnonymousExports(programPath);\n  var _getModuleMetadata = getModuleMetadata(programPath, {\n      initializeReexports: initializeReexports,\n      lazy: lazy\n    }, stringSpecifiers),\n    local = _getModuleMetadata.local,\n    sources = _getModuleMetadata.sources,\n    hasExports = _getModuleMetadata.hasExports;\n  removeImportExportDeclarations(programPath);\n  var _iterator = _createForOfIteratorHelper(sources),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        source = _step$value[0],\n        metadata = _step$value[1];\n      if (metadata.importsNamespace.size > 0) {\n        metadata.name = metadata.importsNamespace.values().next().value;\n      }\n      var resolvedInterop = resolveImportInterop(importInterop, source, filename);\n      if (resolvedInterop === \"none\") {\n        metadata.interop = \"none\";\n      } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n        metadata.interop = \"node-namespace\";\n      } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n        metadata.interop = \"node-default\";\n      } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n        metadata.interop = \"default\";\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    exportName: exportName,\n    exportNameListName: null,\n    hasExports: hasExports,\n    local: local,\n    source: sources,\n    stringSpecifiers: stringSpecifiers\n  };\n}\nfunction getExportSpecifierName(path, stringSpecifiers) {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    var stringValue = path.node.value;\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\"Expected export specifier to be either Identifier or StringLiteral, got \".concat(path.node.type));\n  }\n}\nfunction assertExportSpecifier(path) {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\");\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\nfunction getModuleMetadata(programPath, _ref2, stringSpecifiers) {\n  var lazy = _ref2.lazy,\n    initializeReexports = _ref2.initializeReexports;\n  var localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);\n  var sourceData = new Map();\n  var getData = function getData(sourceNode) {\n    var source = sourceNode.value;\n    var data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\n        interop: \"none\",\n        loc: null,\n        imports: new Map(),\n        importsNamespace: new Set(),\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n        lazy: false,\n        referenced: false\n      };\n      sourceData.set(source, data);\n    }\n    return data;\n  };\n  var hasExports = false;\n  programPath.get(\"body\").forEach(function (child) {\n    if (child.isImportDeclaration()) {\n      var data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(function (spec) {\n        if (spec.isImportDefaultSpecifier()) {\n          var localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, \"default\");\n          var reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(function (name) {\n              data.reexports.set(name, \"default\");\n            });\n            data.referenced = true;\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          var _localName = spec.get(\"local\").node.name;\n          data.importsNamespace.add(_localName);\n          var _reexport = localData.get(_localName);\n          if (_reexport) {\n            localData.delete(_localName);\n            _reexport.names.forEach(function (name) {\n              data.reexportNamespace.add(name);\n            });\n            data.referenced = true;\n          }\n        } else if (spec.isImportSpecifier()) {\n          var importName = getExportSpecifierName(spec.get(\"imported\"), stringSpecifiers);\n          var _localName2 = spec.get(\"local\").node.name;\n          data.imports.set(_localName2, importName);\n          var _reexport2 = localData.get(_localName2);\n          if (_reexport2) {\n            localData.delete(_localName2);\n            _reexport2.names.forEach(function (name) {\n              data.reexports.set(name, importName);\n            });\n            data.referenced = true;\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      var _data = getData(child.node.source);\n      if (!_data.loc) _data.loc = child.node.loc;\n      _data.reexportAll = {\n        loc: child.node.loc\n      };\n      _data.referenced = true;\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      var _data2 = getData(child.node.source);\n      if (!_data2.loc) _data2.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(function (spec) {\n        assertExportSpecifier(spec);\n        var importName = getExportSpecifierName(spec.get(\"local\"), stringSpecifiers);\n        var exportName = getExportSpecifierName(spec.get(\"exported\"), stringSpecifiers);\n        _data2.reexports.set(exportName, importName);\n        _data2.referenced = true;\n        if (exportName === \"__esModule\") {\n          throw spec.get(\"exported\").buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\n      hasExports = true;\n    }\n  });\n  var _iterator2 = _createForOfIteratorHelper(sourceData.values()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var metadata = _step2.value;\n      var needsDefault = false;\n      var needsNamed = false;\n      if (metadata.importsNamespace.size > 0) {\n        needsDefault = true;\n        needsNamed = true;\n      }\n      if (metadata.reexportAll) {\n        needsNamed = true;\n      }\n      var _iterator4 = _createForOfIteratorHelper(metadata.imports.values()),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var importName = _step4.value;\n          if (importName === \"default\") needsDefault = true;else needsNamed = true;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var _iterator5 = _createForOfIteratorHelper(metadata.reexports.values()),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _importName = _step5.value;\n          if (_importName === \"default\") needsDefault = true;else needsNamed = true;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      if (needsDefault && needsNamed) {\n        metadata.interop = \"namespace\";\n      } else if (needsDefault) {\n        metadata.interop = \"default\";\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var _iterator3 = _createForOfIteratorHelper(sourceData),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n        source = _step3$value[0],\n        _metadata = _step3$value[1];\n      if (lazy !== false && !(isSideEffectImport(_metadata) || _metadata.reexportAll)) {\n        if (lazy === true) {\n          _metadata.lazy = !/\\./.test(source);\n        } else if (Array.isArray(lazy)) {\n          _metadata.lazy = lazy.indexOf(source) !== -1;\n        } else if (typeof lazy === \"function\") {\n          _metadata.lazy = lazy(source);\n        } else {\n          throw new Error(\".lazy must be a boolean, string array, or function\");\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return {\n    hasExports: hasExports,\n    local: localData,\n    sources: sourceData\n  };\n}\nfunction getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {\n  var bindingKindLookup = new Map();\n  programPath.get(\"body\").forEach(function (child) {\n    var kind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (initializeReexports && child.node.source && child.get(\"source\").isStringLiteral()) {\n          child.get(\"specifiers\").forEach(function (spec) {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({\n        kind: \"var\"\n      })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(function (name) {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n  var localMetadata = new Map();\n  var getLocalMetadata = function getLocalMetadata(idPath) {\n    var localName = idPath.node.name;\n    var metadata = localMetadata.get(localName);\n    if (!metadata) {\n      var kind = bindingKindLookup.get(localName);\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(\"Exporting local \\\"\".concat(localName, \"\\\", which is not declared.\"));\n      }\n      metadata = {\n        names: [],\n        kind: kind\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n  programPath.get(\"body\").forEach(function (child) {\n    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {\n      if (child.node.declaration) {\n        var declaration = child.get(\"declaration\");\n        var ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(function (name) {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(function (spec) {\n          var local = spec.get(\"local\");\n          var exported = spec.get(\"exported\");\n          var localMetadata = getLocalMetadata(local);\n          var exportName = getExportSpecifierName(exported, stringSpecifiers);\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      var _declaration = child.get(\"declaration\");\n      if (_declaration.isFunctionDeclaration() || _declaration.isClassDeclaration()) {\n        getLocalMetadata(_declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        throw _declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    }\n  });\n  return localMetadata;\n}\nfunction nameAnonymousExports(programPath) {\n  programPath.get(\"body\").forEach(function (child) {\n    if (!child.isExportDefaultDeclaration()) return;\n    (0, _helperSplitExportDeclaration.default)(child);\n  });\n}\nfunction removeImportExportDeclarations(programPath) {\n  programPath.get(\"body\").forEach(function (child) {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      var declaration = child.get(\"declaration\");\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}