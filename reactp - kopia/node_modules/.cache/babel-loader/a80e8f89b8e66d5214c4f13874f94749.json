{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _util;\nfunction _load_util() {\n  return _util = _interopRequireDefault(require('util'));\n}\nvar _chalk;\nfunction _load_chalk() {\n  return _chalk = _interopRequireDefault(require('chalk'));\n}\nvar _prettyFormat;\nfunction _load_prettyFormat() {\n  return _prettyFormat = _interopRequireDefault(require('pretty-format'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toArray(arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * Copyright (c) 2018-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar EXPECTED_COLOR = (_chalk || _load_chalk()).default.green;\nvar RECEIVED_COLOR = (_chalk || _load_chalk()).default.red;\nvar SUPPORTED_PLACEHOLDERS = /%[sdifjoOp%]/g;\nvar PRETTY_PLACEHOLDER = '%p';\nvar INDEX_PLACEHOLDER = '%#';\nexports.default = function (cb) {\n  var supportsDone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return function eachBind(title, test, timeout) {\n      if (args.length === 1) {\n        var _table = args[0].every(Array.isArray) ? args[0] : args[0].map(function (entry) {\n          return [entry];\n        });\n        return _table.forEach(function (row, i) {\n          return cb(arrayFormat.apply(undefined, [title, i].concat(_toConsumableArray(row))), applyRestParams(supportsDone, row, test), timeout);\n        });\n      }\n      var templateStrings = args[0];\n      var data = args.slice(1);\n      var keys = getHeadingKeys(templateStrings[0]);\n      var table = buildTable(data, keys.length, keys);\n      var missingData = data.length % keys.length;\n      if (missingData > 0) {\n        var error = new Error('Not enough arguments supplied for given headings:\\n' + EXPECTED_COLOR(keys.join(' | ')) + '\\n\\n' + 'Received:\\n' + RECEIVED_COLOR((0, (_prettyFormat || _load_prettyFormat()).default)(data)) + '\\n\\n' + \"Missing \".concat(RECEIVED_COLOR(missingData.toString()), \" \").concat(pluralize('argument', missingData)));\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(error, eachBind);\n        }\n        return cb(title, function () {\n          throw error;\n        });\n      }\n      return table.forEach(function (row) {\n        return cb(interpolate(title, row), applyObjectParams(supportsDone, row, test), timeout);\n      });\n    };\n  };\n};\nvar getPrettyIndexes = function getPrettyIndexes(placeholders) {\n  return placeholders.reduce(function (indexes, placeholder, index) {\n    return placeholder === PRETTY_PLACEHOLDER ? indexes.concat(index) : indexes;\n  }, []);\n};\nvar arrayFormat = function arrayFormat(title, rowIndex) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n  var placeholders = title.match(SUPPORTED_PLACEHOLDERS) || [];\n  var prettyIndexes = getPrettyIndexes(placeholders);\n  var _args$reduce = args.reduce(function (acc, arg, index) {\n    if (prettyIndexes.indexOf(index) !== -1) {\n      return {\n        args: acc.args,\n        title: acc.title.replace(PRETTY_PLACEHOLDER, (0, (_prettyFormat || _load_prettyFormat()).default)(arg, {\n          maxDepth: 1,\n          min: true\n        }))\n      };\n    }\n    return {\n      args: acc.args.concat([arg]),\n      title: acc.title\n    };\n  }, {\n    args: [],\n    title: title\n  });\n  var prettyTitle = _args$reduce.title,\n    remainingArgs = _args$reduce.args;\n  return (_util || _load_util()).default.format.apply((_util || _load_util()).default, [prettyTitle.replace(INDEX_PLACEHOLDER, rowIndex.toString())].concat(_toConsumableArray(remainingArgs.slice(0, placeholders.length - prettyIndexes.length))));\n};\nvar applyRestParams = function applyRestParams(supportsDone, params, test) {\n  return supportsDone && params.length < test.length ? function (done) {\n    return test.apply(undefined, _toConsumableArray(params).concat([done]));\n  } : function () {\n    return test.apply(undefined, _toConsumableArray(params));\n  };\n};\nvar getHeadingKeys = function getHeadingKeys(headings) {\n  return headings.replace(/\\s/g, '').split('|');\n};\nvar buildTable = function buildTable(data, rowSize, keys) {\n  return Array.from({\n    length: data.length / rowSize\n  }).map(function (_, index) {\n    return data.slice(index * rowSize, index * rowSize + rowSize);\n  }).map(function (row) {\n    return row.reduce(function (acc, value, index) {\n      return Object.assign({}, acc, _defineProperty({}, keys[index], value));\n    }, {});\n  });\n};\nvar getMatchingKeyPaths = function getMatchingKeyPaths(title) {\n  return function (matches, key) {\n    return matches.concat(title.match(new RegExp(\"\\\\$\".concat(key, \"[\\\\.\\\\w]*\"), 'g')) || []);\n  };\n};\nvar replaceKeyPathWithValue = function replaceKeyPathWithValue(data) {\n  return function (title, match) {\n    var keyPath = match.replace('$', '').split('.');\n    var value = getPath(data, keyPath);\n    return title.replace(match, (0, (_prettyFormat || _load_prettyFormat()).default)(value, {\n      maxDepth: 1,\n      min: true\n    }));\n  };\n};\nvar interpolate = function interpolate(title, data) {\n  return Object.keys(data).reduce(getMatchingKeyPaths(title), []) // aka flatMap\n  .reduce(replaceKeyPathWithValue(data), title);\n};\nvar applyObjectParams = function applyObjectParams(supportsDone, obj, test) {\n  return supportsDone && test.length > 1 ? function (done) {\n    return test(obj, done);\n  } : function () {\n    return test(obj);\n  };\n};\nvar pluralize = function pluralize(word, count) {\n  return word + (count === 1 ? '' : 's');\n};\nvar getPath = function getPath(o, _ref) {\n  var _ref2 = _toArray(_ref);\n  var head = _ref2[0],\n    tail = _ref2.slice(1);\n  if (!head || !o.hasOwnProperty || !o.hasOwnProperty(head)) return o;\n  return getPath(o[head], tail);\n};","map":null,"metadata":{},"sourceType":"script"}