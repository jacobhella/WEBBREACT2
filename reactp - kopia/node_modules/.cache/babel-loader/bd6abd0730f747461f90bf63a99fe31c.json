{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\"use strict\";\n\nvar debug = require('debug')('istanbuljs'),\n  pathutils = require('./pathutils'),\n  libCoverage = require('istanbul-lib-coverage'),\n  MappedCoverage = require('./mapped').MappedCoverage;\nfunction isInvalidPosition(pos) {\n  return !pos || typeof pos.line !== \"number\" || typeof pos.column !== \"number\" || pos.line < 0 || pos.column < 0;\n}\n\n/**\n * determines the original position for a given location\n * @param  {SourceMapConsumer} sourceMap the source map\n * @param  {Object} location the original location Object\n * @returns {Object} the remapped location Object\n */\nfunction getMapping(sourceMap, location, origFile) {\n  if (!location) {\n    return null;\n  }\n  if (isInvalidPosition(location.start) || isInvalidPosition(location.end)) {\n    return null;\n  }\n  var start = sourceMap.originalPositionFor(location.start),\n    end = sourceMap.originalPositionFor(location.end);\n\n  /* istanbul ignore if: edge case too hard to test for */\n  if (!(start && end)) {\n    return null;\n  }\n  if (!(start.source && end.source)) {\n    return null;\n  }\n  if (start.source !== end.source) {\n    return null;\n  }\n\n  /* istanbul ignore if: edge case too hard to test for */\n  if (start.line === null || start.column === null) {\n    return null;\n  }\n  /* istanbul ignore if: edge case too hard to test for */\n  if (end.line === null || end.column === null) {\n    return null;\n  }\n  if (start.line === end.line && start.column === end.column) {\n    end = sourceMap.originalPositionFor({\n      line: location.end.line,\n      column: location.end.column,\n      bias: 2\n    });\n    end.column = end.column - 1;\n  }\n  return {\n    source: pathutils.relativeTo(start.source, origFile),\n    loc: {\n      start: {\n        line: start.line,\n        column: start.column\n      },\n      end: {\n        line: end.line,\n        column: end.column\n      }\n    }\n  };\n}\nfunction SourceMapTransformer(finder, opts) {\n  opts = opts || {};\n  this.finder = finder;\n  this.baseDir = opts.baseDir || process.cwd();\n}\nSourceMapTransformer.prototype.processFile = function (fc, sourceMap, coverageMapper) {\n  var changes = 0;\n  Object.keys(fc.statementMap).forEach(function (s) {\n    var loc = fc.statementMap[s],\n      hits = fc.s[s],\n      mapping = getMapping(sourceMap, loc, fc.path),\n      mappedCoverage;\n    if (mapping) {\n      changes += 1;\n      mappedCoverage = coverageMapper(mapping.source);\n      mappedCoverage.addStatement(mapping.loc, hits);\n    }\n  });\n  Object.keys(fc.fnMap).forEach(function (f) {\n    var fnMeta = fc.fnMap[f],\n      hits = fc.f[f],\n      mapping = getMapping(sourceMap, fnMeta.decl, fc.path),\n      spanMapping = getMapping(sourceMap, fnMeta.loc, fc.path),\n      mappedCoverage;\n    if (mapping && spanMapping && mapping.source === spanMapping.source) {\n      changes += 1;\n      mappedCoverage = coverageMapper(mapping.source);\n      mappedCoverage.addFunction(fnMeta.name, mapping.loc, spanMapping.loc, hits);\n    }\n  });\n  Object.keys(fc.branchMap).forEach(function (b) {\n    var branchMeta = fc.branchMap[b],\n      source,\n      hits = fc.b[b],\n      mapping,\n      locs = [],\n      mappedHits = [],\n      mappedCoverage,\n      skip,\n      i;\n    for (i = 0; i < branchMeta.locations.length; i += 1) {\n      mapping = getMapping(sourceMap, branchMeta.locations[i], fc.path);\n      if (mapping) {\n        if (!source) {\n          source = mapping.source;\n        }\n        if (mapping.source !== source) {\n          skip = true;\n        }\n        locs.push(mapping.loc);\n        mappedHits.push(hits[i]);\n      }\n    }\n    if (!skip && locs.length > 0) {\n      changes += 1;\n      mappedCoverage = coverageMapper(source);\n      mappedCoverage.addBranch(branchMeta.type, locs[0] /* XXX */, locs, mappedHits);\n    }\n  });\n  return changes > 0;\n};\nSourceMapTransformer.prototype.transform = function (coverageMap) {\n  var that = this,\n    finder = this.finder,\n    output = {},\n    getMappedCoverage = function getMappedCoverage(file) {\n      if (!output[file]) {\n        output[file] = new MappedCoverage(file);\n      }\n      return output[file];\n    };\n  coverageMap.files().forEach(function (file) {\n    var fc = coverageMap.fileCoverageFor(file),\n      sourceMap = finder(file),\n      changed;\n    if (!sourceMap) {\n      output[file] = fc;\n      return;\n    }\n    changed = that.processFile(fc, sourceMap, getMappedCoverage);\n    if (!changed) {\n      debug('File [' + file + '] ignored, nothing could be mapped');\n    }\n  });\n  return libCoverage.createCoverageMap(output);\n};\nmodule.exports = {\n  create: function create(finder, opts) {\n    return new SourceMapTransformer(finder, opts);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}