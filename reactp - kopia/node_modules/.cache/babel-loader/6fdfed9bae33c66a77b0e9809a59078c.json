{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = diffStrings;\nvar _chalk = require('chalk');\nvar _chalk2 = _interopRequireDefault(_chalk);\nvar _diff = require('diff');\nvar _constants = require('./constants.js');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar DIFF_CONTEXT_DEFAULT = 5; // removed | added | equal\n\n// Given diff digit, return array which consists of:\n// if compared line is removed or added: corresponding original line\n// if compared line is equal: original received and expected lines\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n// Given chunk, return diff character.\nvar getDiffChar = function getDiffChar(chunk) {\n  return chunk.removed ? '-' : chunk.added ? '+' : ' ';\n};\n\n// Given diff character in line of hunk or computed from properties of chunk.\nvar getDiffDigit = function getDiffDigit(char) {\n  return char === '-' ? -1 : char === '+' ? 1 : 0;\n};\n\n// Color for text of line.\nvar getColor = function getColor(digit, onlyIndentationChanged) {\n  if (digit === -1) {\n    return _chalk2.default.green; // removed\n  }\n\n  if (digit === 1) {\n    return _chalk2.default.red; // added\n  }\n\n  return onlyIndentationChanged ? _chalk2.default.cyan : _chalk2.default.dim;\n};\n\n// Do NOT color leading or trailing spaces if original lines are equal:\n\n// Background color for leading or trailing spaces.\nvar getBgColor = function getBgColor(digit, onlyIndentationChanged) {\n  return digit === 0 && !onlyIndentationChanged ? _chalk2.default.bgYellow : _chalk2.default.inverse;\n};\n\n// ONLY trailing if expected value is snapshot or multiline string.\nvar highlightTrailingSpaces = function highlightTrailingSpaces(line, bgColor) {\n  return line.replace(/\\s+$/, bgColor('$&'));\n};\n\n// BOTH leading AND trailing if expected value is data structure.\nvar highlightLeadingTrailingSpaces = function highlightLeadingTrailingSpaces(line, bgColor\n// If line consists of ALL spaces: highlight all of them.\n) {\n  return highlightTrailingSpaces(line, bgColor).replace(\n  // If line has an ODD length of leading spaces: highlight only the LAST.\n  /^(\\s\\s)*(\\s)(?=[^\\s])/, '$1' + bgColor('$2'));\n};\nvar getAnnotation = function getAnnotation(options) {\n  return _chalk2.default.green('- ' + (options && options.aAnnotation || 'Expected')) + '\\n' + _chalk2.default.red('+ ' + (options && options.bAnnotation || 'Received')) + '\\n\\n';\n};\n\n// Given string, return array of its lines.\nvar splitIntoLines = function splitIntoLines(string) {\n  var lines = string.split('\\n');\n  if (lines.length !== 0 && lines[lines.length - 1] === '') {\n    lines.pop();\n  }\n  return lines;\n};\n\n// Given diff character and compared line, return original line with colors.\nvar formatLine = function formatLine(char, lineCompared, getOriginal) {\n  var digit = getDiffDigit(char);\n  if (getOriginal) {\n    // Compared without indentation if expected value is data structure.\n    var lineArray = getOriginal(digit);\n    var lineOriginal = lineArray[0];\n    var onlyIndentationChanged = digit === 0 && lineOriginal.length !== lineArray[1].length;\n    return getColor(digit, onlyIndentationChanged)(char + ' ' +\n    // Prepend indentation spaces from original to compared line.\n    lineOriginal.slice(0, lineOriginal.length - lineCompared.length) + highlightLeadingTrailingSpaces(lineCompared, getBgColor(digit, onlyIndentationChanged)));\n  }\n\n  // Format compared line when expected is snapshot or multiline string.\n  return getColor(digit)(char + ' ' + highlightTrailingSpaces(lineCompared, getBgColor(digit)));\n};\n\n// Given original lines, return callback function\n// which given diff digit, returns array.\nvar getterForChunks = function getterForChunks(original) {\n  var linesExpected = splitIntoLines(original.a);\n  var linesReceived = splitIntoLines(original.b);\n  var iExpected = 0;\n  var iReceived = 0;\n  return function (digit) {\n    if (digit === -1) {\n      return [linesExpected[iExpected++]];\n    }\n    if (digit === 1) {\n      return [linesReceived[iReceived++]];\n    }\n    // Because compared line is equal: original received and expected lines.\n    return [linesReceived[iReceived++], linesExpected[iExpected++]];\n  };\n};\n\n// jest --expand\nvar formatChunks = function formatChunks(a, b, original) {\n  var chunks = (0, _diff.diffLines)(a, b);\n  if (chunks.every(function (chunk) {\n    return !chunk.removed && !chunk.added;\n  })) {\n    return null;\n  }\n  var getOriginal = original && getterForChunks(original);\n  return chunks.reduce(function (lines, chunk) {\n    var char = getDiffChar(chunk);\n    splitIntoLines(chunk.value).forEach(function (line) {\n      lines.push(formatLine(char, line, getOriginal));\n    });\n    return lines;\n  }, []).join('\\n');\n};\n\n// Only show patch marks (\"@@ ... @@\") if the diff is big.\n// To determine this, we need to compare either the original string (a) to\n// `hunk.oldLines` or a new string to `hunk.newLines`.\n// If the `oldLinesCount` is greater than `hunk.oldLines`\n// we can be sure that at least 1 line has been \"hidden\".\nvar shouldShowPatchMarks = function shouldShowPatchMarks(hunk, oldLinesCount) {\n  return oldLinesCount > hunk.oldLines;\n};\nvar createPatchMark = function createPatchMark(hunk) {\n  var markOld = \"-\".concat(hunk.oldStart, \",\").concat(hunk.oldLines);\n  var markNew = \"+\".concat(hunk.newStart, \",\").concat(hunk.newLines);\n  return _chalk2.default.yellow(\"@@ \".concat(markOld, \" \").concat(markNew, \" @@\"));\n};\n\n// Given original lines, return callback function which given indexes for hunk,\n// returns another callback function which given diff digit, returns array.\nvar getterForHunks = function getterForHunks(original) {\n  var linesExpected = splitIntoLines(original.a);\n  var linesReceived = splitIntoLines(original.b);\n  return function (iExpected, iReceived) {\n    return function (digit) {\n      if (digit === -1) {\n        return [linesExpected[iExpected++]];\n      }\n      if (digit === 1) {\n        return [linesReceived[iReceived++]];\n      }\n      // Because compared line is equal: original received and expected lines.\n      return [linesReceived[iReceived++], linesExpected[iExpected++]];\n    };\n  };\n};\n\n// jest --no-expand\nvar formatHunks = function formatHunks(a, b, contextLines, original) {\n  var options = {\n    context: typeof contextLines === 'number' && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT\n  };\n  var _structuredPatch = (0, _diff.structuredPatch)('', '', a, b, '', '', options);\n  var hunks = _structuredPatch.hunks;\n  if (hunks.length === 0) {\n    return null;\n  }\n  var getter = original && getterForHunks(original);\n  var oldLinesCount = (a.match(/\\n/g) || []).length;\n  return hunks.reduce(function (lines, hunk) {\n    if (shouldShowPatchMarks(hunk, oldLinesCount)) {\n      lines.push(createPatchMark(hunk));\n    }\n\n    // Hunk properties are one-based but index args are zero-based.\n    var getOriginal = getter && getter(hunk.oldStart - 1, hunk.newStart - 1);\n    hunk.lines.forEach(function (line) {\n      lines.push(formatLine(line[0], line.slice(1), getOriginal));\n    });\n    return lines;\n  }, []).join('\\n');\n};\nfunction diffStrings(a, b, options, original) {\n  // Because `formatHunks` and `formatChunks` ignore one trailing newline,\n  // always append newline to strings:\n  a += '\\n';\n  b += '\\n';\n\n  // `diff` uses the Myers LCS diff algorithm which runs in O(n+d^2) time\n  // (where \"d\" is the edit distance) and can get very slow for large edit\n  // distances. Mitigate the cost by switching to a lower-resolution diff\n  // whenever linebreaks are involved.\n  var result = options && options.expand === false ? formatHunks(a, b, options && options.contextLines, original) : formatChunks(a, b, original);\n  return result === null ? _constants.NO_DIFF_MESSAGE : getAnnotation(options) + result;\n}","map":null,"metadata":{},"sourceType":"script"}