{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _fs;\nfunction _load_fs() {\n  return _fs = _interopRequireDefault(require('fs'));\n}\nvar _jestHasteMap;\nfunction _load_jestHasteMap() {\n  return _jestHasteMap = require('jest-haste-map');\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar FAIL = 0;\n// $FlowFixMe: Missing ESM export\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar SUCCESS = 1;\nvar TestSequencer = /*#__PURE__*/function () {\n  function TestSequencer() {\n    _classCallCheck(this, TestSequencer);\n    this._cache = new Map();\n  }\n  _createClass(TestSequencer, [{\n    key: \"_getCachePath\",\n    value: function _getCachePath(context) {\n      var config = context.config;\n      return (0, (_jestHasteMap || _load_jestHasteMap()).getCacheFilePath)(config.cacheDirectory, 'perf-cache-' + config.name);\n    }\n  }, {\n    key: \"_getCache\",\n    value: function _getCache(test) {\n      var context = test.context;\n      if (!this._cache.has(context) && context.config.cache) {\n        var cachePath = this._getCachePath(context);\n        if ((_fs || _load_fs()).default.existsSync(cachePath)) {\n          try {\n            this._cache.set(context, JSON.parse((_fs || _load_fs()).default.readFileSync(cachePath, 'utf8')));\n          } catch (e) {}\n        }\n      }\n      var cache = this._cache.get(context);\n      if (!cache) {\n        cache = {};\n        this._cache.set(context, cache);\n      }\n      return cache;\n    } // When running more tests than we have workers available, sort the tests\n    // by size - big test files usually take longer to complete, so we run\n    // them first in an effort to minimize worker idle time at the end of a\n    // long test run.\n    //\n    // After a test run we store the time it took to run a test and on\n    // subsequent runs we use that to run the slowest tests first, yielding the\n    // fastest results.\n  }, {\n    key: \"sort\",\n    value: function sort(tests) {\n      var _this = this;\n      var stats = {};\n      var fileSize = function fileSize(test) {\n        return stats[test.path] || (stats[test.path] = (_fs || _load_fs()).default.statSync(test.path).size);\n      };\n      var hasFailed = function hasFailed(cache, test) {\n        return cache[test.path] && cache[test.path][0] === FAIL;\n      };\n      var time = function time(cache, test) {\n        return cache[test.path] && cache[test.path][1];\n      };\n      tests.forEach(function (test) {\n        return test.duration = time(_this._getCache(test), test);\n      });\n      return tests.sort(function (testA, testB) {\n        var cacheA = _this._getCache(testA);\n        var cacheB = _this._getCache(testB);\n        var failedA = hasFailed(cacheA, testA);\n        var failedB = hasFailed(cacheB, testB);\n        var hasTimeA = testA.duration != null;\n        if (failedA !== failedB) {\n          return failedA ? -1 : 1;\n        } else if (hasTimeA != (testB.duration != null)) {\n          // Check if only one of two tests has timing information\n          return hasTimeA != null ? 1 : -1;\n        } else if (testA.duration != null && testB.duration != null) {\n          return testA.duration < testB.duration ? 1 : -1;\n        } else {\n          return fileSize(testA) < fileSize(testB) ? 1 : -1;\n        }\n      });\n    }\n  }, {\n    key: \"cacheResults\",\n    value: function cacheResults(tests, results) {\n      var _this2 = this;\n      var map = Object.create(null);\n      tests.forEach(function (test) {\n        return map[test.path] = test;\n      });\n      results.testResults.forEach(function (testResult) {\n        if (testResult && map[testResult.testFilePath] && !testResult.skipped) {\n          var cache = _this2._getCache(map[testResult.testFilePath]);\n          var perf = testResult.perfStats;\n          cache[testResult.testFilePath] = [testResult.numFailingTests ? FAIL : SUCCESS, perf.end - perf.start || 0];\n        }\n      });\n      this._cache.forEach(function (cache, context) {\n        return (_fs || _load_fs()).default.writeFileSync(_this2._getCachePath(context), JSON.stringify(cache));\n      });\n    }\n  }]);\n  return TestSequencer;\n}();\nexports.default = TestSequencer;","map":null,"metadata":{},"sourceType":"script"}