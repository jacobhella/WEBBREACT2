{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar niceTry = require('nice-try');\nvar resolveCommand = require('./util/resolveCommand');\nvar escape = require('./util/escape');\nvar readShebang = require('./util/readShebang');\nvar semver = require('semver');\nvar isWin = process.platform === 'win32';\nvar isExecutableRegExp = /\\.(?:com|exe)$/i;\nvar isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\n// `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0\nvar supportsShellOption = niceTry(function () {\n  return semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true);\n}) || false;\nfunction detectShebang(parsed) {\n  parsed.file = resolveCommand(parsed);\n  var shebang = parsed.file && readShebang(parsed.file);\n  if (shebang) {\n    parsed.args.unshift(parsed.file);\n    parsed.command = shebang;\n    return resolveCommand(parsed);\n  }\n  return parsed.file;\n}\nfunction parseNonShell(parsed) {\n  if (!isWin) {\n    return parsed;\n  }\n\n  // Detect & add support for shebangs\n  var commandFile = detectShebang(parsed);\n\n  // We don't need a shell if the command filename is an executable\n  var needsShell = !isExecutableRegExp.test(commandFile);\n\n  // If a shell is required, use cmd.exe and take care of escaping everything correctly\n  // Note that `forceShell` is an hidden option used only in tests\n  if (parsed.options.forceShell || needsShell) {\n    // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n    // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n    // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n    // we need to double escape them\n    var needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n    // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n    // This is necessary otherwise it will always fail with ENOENT in those cases\n    parsed.command = path.normalize(parsed.command);\n\n    // Escape command & arguments\n    parsed.command = escape.command(parsed.command);\n    parsed.args = parsed.args.map(function (arg) {\n      return escape.argument(arg, needsDoubleEscapeMetaChars);\n    });\n    var shellCommand = [parsed.command].concat(parsed.args).join(' ');\n    parsed.args = ['/d', '/s', '/c', \"\\\"\".concat(shellCommand, \"\\\"\")];\n    parsed.command = process.env.comspec || 'cmd.exe';\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  }\n\n  return parsed;\n}\nfunction parseShell(parsed) {\n  // If node supports the shell option, there's no need to mimic its behavior\n  if (supportsShellOption) {\n    return parsed;\n  }\n\n  // Mimic node shell option\n  // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n  var shellCommand = [parsed.command].concat(parsed.args).join(' ');\n  if (isWin) {\n    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n    parsed.args = ['/d', '/s', '/c', \"\\\"\".concat(shellCommand, \"\\\"\")];\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  } else {\n    if (typeof parsed.options.shell === 'string') {\n      parsed.command = parsed.options.shell;\n    } else if (process.platform === 'android') {\n      parsed.command = '/system/bin/sh';\n    } else {\n      parsed.command = '/bin/sh';\n    }\n    parsed.args = ['-c', shellCommand];\n  }\n  return parsed;\n}\nfunction parse(command, args, options) {\n  // Normalize arguments, similar to nodejs\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n  options = Object.assign({}, options); // Clone object to avoid changing the original\n\n  // Build our parsed object\n  var parsed = {\n    command: command,\n    args: args,\n    options: options,\n    file: undefined,\n    original: {\n      command: command,\n      args: args\n    }\n  };\n\n  // Delegate further parsing to shell or non-shell\n  return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\nmodule.exports = parse;","map":null,"metadata":{},"sourceType":"script"}