{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _crypto;\nfunction _load_crypto() {\n  return _crypto = _interopRequireDefault(require('crypto'));\n}\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _vm;\nfunction _load_vm() {\n  return _vm = _interopRequireDefault(require('vm'));\n}\nvar _jestUtil;\nfunction _load_jestUtil() {\n  return _jestUtil = require('jest-util');\n}\nvar _gracefulFs;\nfunction _load_gracefulFs() {\n  return _gracefulFs = _interopRequireDefault(require('graceful-fs'));\n}\nvar _babelCore;\nfunction _load_babelCore() {\n  return _babelCore = require('babel-core');\n}\nvar _babelPluginIstanbul;\nfunction _load_babelPluginIstanbul() {\n  return _babelPluginIstanbul = _interopRequireDefault(require('babel-plugin-istanbul'));\n}\nvar _convertSourceMap;\nfunction _load_convertSourceMap() {\n  return _convertSourceMap = _interopRequireDefault(require('convert-source-map'));\n}\nvar _jestHasteMap;\nfunction _load_jestHasteMap() {\n  return _jestHasteMap = _interopRequireDefault(require('jest-haste-map'));\n}\nvar _fastJsonStableStringify;\nfunction _load_fastJsonStableStringify() {\n  return _fastJsonStableStringify = _interopRequireDefault(require('fast-json-stable-stringify'));\n}\nvar _slash;\nfunction _load_slash() {\n  return _slash = _interopRequireDefault(require('slash'));\n}\nvar _package;\nfunction _load_package() {\n  return _package = require('../package.json');\n}\nvar _should_instrument;\nfunction _load_should_instrument() {\n  return _should_instrument = _interopRequireDefault(require('./should_instrument'));\n}\nvar _writeFileAtomic;\nfunction _load_writeFileAtomic() {\n  return _writeFileAtomic = _interopRequireDefault(require('write-file-atomic'));\n}\nvar _realpathNative;\nfunction _load_realpathNative() {\n  return _realpathNative = require('realpath-native');\n}\nvar _helpers;\nfunction _load_helpers() {\n  return _helpers = require('./helpers');\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar cache = new Map();\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar configToJsonMap = new Map();\n// Cache regular expressions to test whether the file needs to be preprocessed\nvar ignoreCache = new WeakMap();\n\n// To reset the cache for specific changesets (rather than package version).\nvar CACHE_VERSION = '1';\nvar ScriptTransformer = /*#__PURE__*/function () {\n  function ScriptTransformer(config) {\n    _classCallCheck(this, ScriptTransformer);\n    this._config = config;\n    this._transformCache = new Map();\n  }\n  _createClass(ScriptTransformer, [{\n    key: \"_getCacheKey\",\n    value: function _getCacheKey(fileData, filename, instrument) {\n      if (!configToJsonMap.has(this._config)) {\n        // We only need this set of config options that can likely influence\n        // cached output instead of all config options.\n        configToJsonMap.set(this._config, (0, (_fastJsonStableStringify || _load_fastJsonStableStringify()).default)(this._config));\n      }\n      var configString = configToJsonMap.get(this._config) || '';\n      var transformer = this._getTransformer(filename);\n      if (transformer && typeof transformer.getCacheKey === 'function') {\n        return (_crypto || _load_crypto()).default.createHash('md5').update(transformer.getCacheKey(fileData, filename, configString, {\n          instrument: instrument,\n          rootDir: this._config.rootDir\n        })).update(CACHE_VERSION).digest('hex');\n      } else {\n        return (_crypto || _load_crypto()).default.createHash('md5').update(fileData).update(configString).update(instrument ? 'instrument' : '').update(CACHE_VERSION).digest('hex');\n      }\n    }\n  }, {\n    key: \"_getFileCachePath\",\n    value: function _getFileCachePath(filename, content, instrument) {\n      var baseCacheDir = (_jestHasteMap || _load_jestHasteMap()).default.getCacheFilePath(this._config.cacheDirectory, 'jest-transform-cache-' + this._config.name, (_package || _load_package()).version);\n      var cacheKey = this._getCacheKey(content, filename, instrument);\n      // Create sub folders based on the cacheKey to avoid creating one\n      // directory with many files.\n      var cacheDir = (_path || _load_path()).default.join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n      var cachePath = (0, (_slash || _load_slash()).default)((_path || _load_path()).default.join(cacheDir, (_path || _load_path()).default.basename(filename, (_path || _load_path()).default.extname(filename)) + '_' + cacheKey));\n      (0, (_jestUtil || _load_jestUtil()).createDirectory)(cacheDir);\n      return cachePath;\n    }\n  }, {\n    key: \"_getTransformPath\",\n    value: function _getTransformPath(filename) {\n      for (var i = 0; i < this._config.transform.length; i++) {\n        if (new RegExp(this._config.transform[i][0]).test(filename)) {\n          return this._config.transform[i][1];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_getTransformer\",\n    value: function _getTransformer(filename) {\n      var transform;\n      if (!this._config.transform || !this._config.transform.length) {\n        return null;\n      }\n      var transformPath = this._getTransformPath(filename);\n      if (transformPath) {\n        var transformer = this._transformCache.get(transformPath);\n        if (transformer != null) {\n          return transformer;\n        }\n\n        // $FlowFixMe\n        transform = require(transformPath);\n        if (typeof transform.createTransformer === 'function') {\n          transform = transform.createTransformer();\n        }\n        if (typeof transform.process !== 'function') {\n          throw new TypeError('Jest: a transform must export a `process` function.');\n        }\n        this._transformCache.set(transformPath, transform);\n      }\n      return transform;\n    }\n  }, {\n    key: \"_instrumentFile\",\n    value: function _instrumentFile(filename, content) {\n      return (0, (_babelCore || _load_babelCore()).transform)(content, {\n        auxiliaryCommentBefore: ' istanbul ignore next ',\n        babelrc: false,\n        filename: filename,\n        plugins: [[(_babelPluginIstanbul || _load_babelPluginIstanbul()).default, {\n          compact: false,\n          // files outside `cwd` will not be instrumented\n          cwd: this._config.rootDir,\n          exclude: [],\n          useInlineSourceMaps: false\n        }]]\n      }).code;\n    }\n  }, {\n    key: \"_getRealPath\",\n    value: function _getRealPath(filepath) {\n      try {\n        return (0, (_realpathNative || _load_realpathNative()).sync)(filepath) || filepath;\n      } catch (err) {\n        return filepath;\n      }\n    }\n  }, {\n    key: \"transformSource\",\n    value: function transformSource(filepath, content, instrument) {\n      var filename = this._getRealPath(filepath);\n      var transform = this._getTransformer(filename);\n      var cacheFilePath = this._getFileCachePath(filename, content, instrument);\n      var sourceMapPath = cacheFilePath + '.map';\n      // Ignore cache if `config.cache` is set (--no-cache)\n      var code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n      var shouldCallTransform = transform && shouldTransform(filename, this._config);\n\n      // That means that the transform has a custom instrumentation\n      // logic and will handle it based on `config.collectCoverage` option\n      var transformWillInstrument = shouldCallTransform && transform && transform.canInstrument;\n\n      // If we handle the coverage instrumentation, we should try to map code\n      // coverage against original source with any provided source map\n      var mapCoverage = instrument && !transformWillInstrument;\n      if (code) {\n        // This is broken: we return the code, and a path for the source map\n        // directly from the cache. But, nothing ensures the source map actually\n        // matches that source code. They could have gotten out-of-sync in case\n        // two separate processes write concurrently to the same cache files.\n        return {\n          code: code,\n          mapCoverage: mapCoverage,\n          sourceMapPath: sourceMapPath\n        };\n      }\n      var transformed = {\n        code: content,\n        map: null\n      };\n      if (transform && shouldCallTransform) {\n        var processed = transform.process(content, filename, this._config, {\n          instrument: instrument\n        });\n        if (typeof processed === 'string') {\n          transformed.code = processed;\n        } else if (processed != null && typeof processed.code === 'string') {\n          transformed = processed;\n        } else {\n          throw new TypeError(\"Jest: a transform's `process` function must return a string, \" + 'or an object with `code` key containing this string.');\n        }\n      }\n      if (!transformed.map) {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        var inlineSourceMap = (_convertSourceMap || _load_convertSourceMap()).default.fromSource(transformed.code);\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toJSON();\n        }\n      }\n      if (!transformWillInstrument && instrument) {\n        code = this._instrumentFile(filename, transformed.code);\n      } else {\n        code = transformed.code;\n      }\n      if (transformed.map) {\n        var sourceMapContent = typeof transformed.map === 'string' ? transformed.map : JSON.stringify(transformed.map);\n        writeCacheFile(sourceMapPath, sourceMapContent);\n      } else {\n        sourceMapPath = null;\n      }\n      writeCodeCacheFile(cacheFilePath, code);\n      return {\n        code: code,\n        mapCoverage: mapCoverage,\n        sourceMapPath: sourceMapPath\n      };\n    }\n  }, {\n    key: \"_transformAndBuildScript\",\n    value: function _transformAndBuildScript(filename, options, instrument, fileSource) {\n      var isInternalModule = !!(options && options.isInternalModule);\n      var isCoreModule = !!(options && options.isCoreModule);\n      var content = stripShebang(fileSource || (_gracefulFs || _load_gracefulFs()).default.readFileSync(filename, 'utf8'));\n      var wrappedCode;\n      var sourceMapPath = null;\n      var mapCoverage = false;\n      var willTransform = !isInternalModule && !isCoreModule && (shouldTransform(filename, this._config) || instrument);\n      try {\n        if (willTransform) {\n          var transformedSource = this.transformSource(filename, content, instrument);\n          wrappedCode = wrap(transformedSource.code);\n          sourceMapPath = transformedSource.sourceMapPath;\n          mapCoverage = transformedSource.mapCoverage;\n        } else {\n          wrappedCode = wrap(content);\n        }\n        return {\n          mapCoverage: mapCoverage,\n          script: new (_vm || _load_vm()).default.Script(wrappedCode, {\n            displayErrors: true,\n            filename: isCoreModule ? 'jest-nodejs-core-' + filename : filename\n          }),\n          sourceMapPath: sourceMapPath\n        };\n      } catch (e) {\n        if (e.codeFrame) {\n          e.stack = e.codeFrame;\n        }\n        if (e instanceof SyntaxError && e.message.includes('Unexpected token') && !e.message.includes(' expected')) {\n          throw (0, (_helpers || _load_helpers()).enhanceUnexpectedTokenMessage)(e);\n        }\n        throw e;\n      }\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(filename, options, fileSource) {\n      var scriptCacheKey = null;\n      var instrument = false;\n      var result = '';\n      if (!options.isCoreModule) {\n        instrument = (0, (_should_instrument || _load_should_instrument()).default)(filename, options, this._config);\n        scriptCacheKey = getScriptCacheKey(filename, instrument);\n        result = cache.get(scriptCacheKey);\n      }\n      if (result) {\n        return result;\n      }\n      result = this._transformAndBuildScript(filename, options, instrument, fileSource);\n      if (scriptCacheKey) {\n        cache.set(scriptCacheKey, result);\n      }\n      return result;\n    }\n  }]);\n  return ScriptTransformer;\n}();\nexports.default = ScriptTransformer;\nvar removeFile = function removeFile(path) {\n  try {\n    (_gracefulFs || _load_gracefulFs()).default.unlinkSync(path);\n  } catch (e) {}\n};\nvar stripShebang = function stripShebang(content) {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\nfunction writeCodeCacheFile(cachePath, code) {\n  var checksum = (_crypto || _load_crypto()).default.createHash('md5').update(code).digest('hex');\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\nfunction readCodeCacheFile(cachePath) {\n  var content = readCacheFile(cachePath);\n  if (content == null) {\n    return null;\n  }\n  var code = content.substr(33);\n  var checksum = (_crypto || _load_crypto()).default.createHash('md5').update(code).digest('hex');\n  if (checksum === content.substr(0, 32)) {\n    return code;\n  }\n  return null;\n}\n\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\nvar writeCacheFile = function writeCacheFile(cachePath, fileData) {\n  try {\n    (_writeFileAtomic || _load_writeFileAtomic()).default.sync(cachePath, fileData, {\n      encoding: 'utf8'\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n    e.message = 'jest: failed to cache transform results in: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\nvar cacheWriteErrorSafeToIgnore = function cacheWriteErrorSafeToIgnore(e, cachePath) {\n  return process.platform === 'win32' && e.code === 'EPERM' && (_gracefulFs || _load_gracefulFs()).default.existsSync(cachePath);\n};\nvar readCacheFile = function readCacheFile(cachePath) {\n  if (!(_gracefulFs || _load_gracefulFs()).default.existsSync(cachePath)) {\n    return null;\n  }\n  var fileData;\n  try {\n    fileData = (_gracefulFs || _load_gracefulFs()).default.readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = 'jest: failed to read cache file: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n  return fileData;\n};\nvar getScriptCacheKey = function getScriptCacheKey(filename, instrument) {\n  var mtime = (_gracefulFs || _load_gracefulFs()).default.statSync(filename).mtime;\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\nvar shouldTransform = function shouldTransform(filename, config) {\n  if (!ignoreCache.has(config)) {\n    if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {\n      ignoreCache.set(config, null);\n    } else {\n      ignoreCache.set(config, new RegExp(config.transformIgnorePatterns.join('|')));\n    }\n  }\n  var ignoreRegexp = ignoreCache.get(config);\n  var isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n  return !!config.transform && !!config.transform.length && !isIgnored;\n};\nvar wrap = function wrap(content) {\n  return '({\"' + ScriptTransformer.EVAL_RESULT_VARIABLE + '\":function(module,exports,require,__dirname,__filename,global,jest){' + content + '\\n}});';\n};\nScriptTransformer.EVAL_RESULT_VARIABLE = 'Object.<anonymous>';","map":null,"metadata":{},"sourceType":"script"}