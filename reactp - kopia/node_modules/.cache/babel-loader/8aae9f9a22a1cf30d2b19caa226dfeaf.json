{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar _fs;\nfunction _load_fs() {\n  return _fs = _interopRequireDefault(require('fs'));\n}\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _node_modules_paths;\nfunction _load_node_modules_paths() {\n  return _node_modules_paths = _interopRequireDefault(require('./node_modules_paths'));\n}\nvar _is_builtin_module;\nfunction _load_is_builtin_module() {\n  return _is_builtin_module = _interopRequireDefault(require('./is_builtin_module'));\n}\nvar _default_resolver;\nfunction _load_default_resolver() {\n  return _default_resolver = _interopRequireDefault(require('./default_resolver.js'));\n}\nvar _chalk;\nfunction _load_chalk() {\n  return _chalk = _interopRequireDefault(require('chalk'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar NATIVE_PLATFORM = 'native';\n\n// We might be inside a symlink.\nvar cwd = process.cwd();\nvar resolvedCwd = (_fs || _load_fs()).default.realpathSync(cwd) || cwd;\nvar nodePaths = process.env.NODE_PATH ? process.env.NODE_PATH.split((_path || _load_path()).default.delimiter).filter(Boolean)\n// The resolver expects absolute paths.\n.map(function (p) {\n  return (_path || _load_path()).default.resolve(resolvedCwd, p);\n}) : null;\nvar Resolver = /*#__PURE__*/function () {\n  function Resolver(moduleMap, options) {\n    _classCallCheck(this, Resolver);\n    this._options = {\n      browser: options.browser,\n      defaultPlatform: options.defaultPlatform,\n      extensions: options.extensions,\n      hasCoreModules: options.hasCoreModules === undefined ? true : options.hasCoreModules,\n      moduleDirectories: options.moduleDirectories || ['node_modules'],\n      moduleNameMapper: options.moduleNameMapper,\n      modulePaths: options.modulePaths,\n      platforms: options.platforms,\n      resolver: options.resolver,\n      rootDir: options.rootDir\n    };\n    this._moduleMap = moduleMap;\n    this._moduleIDCache = Object.create(null);\n    this._moduleNameCache = Object.create(null);\n    this._modulePathCache = Object.create(null);\n  }\n  _createClass(Resolver, [{\n    key: \"resolveModuleFromDirIfExists\",\n    value: function resolveModuleFromDirIfExists(dirname, moduleName, options) {\n      var _this = this;\n      var paths = options && options.paths || this._options.modulePaths;\n      var moduleDirectory = this._options.moduleDirectories;\n      var key = dirname + (_path || _load_path()).default.delimiter + moduleName;\n      var defaultPlatform = this._options.defaultPlatform;\n      var extensions = this._options.extensions.slice();\n      if (this._supportsNativePlatform()) {\n        extensions.unshift.apply(extensions, _toConsumableArray(this._options.extensions.map(function (ext) {\n          return '.' + NATIVE_PLATFORM + ext;\n        })));\n      }\n      if (defaultPlatform) {\n        extensions.unshift.apply(extensions, _toConsumableArray(this._options.extensions.map(function (ext) {\n          return '.' + defaultPlatform + ext;\n        })));\n      }\n\n      // 0. If we have already resolved this module for this directory name,\n      //    return a value from the cache.\n      if (this._moduleNameCache[key]) {\n        return this._moduleNameCache[key];\n      }\n\n      // 1. Check if the module is a haste module.\n      var module = this.getModule(moduleName);\n      if (module) {\n        return this._moduleNameCache[key] = module;\n      }\n\n      // 2. Check if the module is a node module and resolve it based on\n      //    the node module resolution algorithm.\n      // If skipNodeResolution is given we ignore all modules that look like\n      // node modules (ie. are not relative requires). This enables us to speed\n      // up resolution when we build a dependency graph because we don't have\n      // to look at modules that may not exist and aren't mocked.\n      var skipResolution = options && options.skipNodeResolution && !moduleName.includes((_path || _load_path()).default.sep);\n      var resolveNodeModule = function resolveNodeModule(name) {\n        return Resolver.findNodeModule(name, {\n          basedir: dirname,\n          browser: _this._options.browser,\n          extensions: extensions,\n          moduleDirectory: moduleDirectory,\n          paths: paths,\n          resolver: _this._options.resolver,\n          rootDir: _this._options.rootDir\n        });\n      };\n      if (!skipResolution) {\n        module = resolveNodeModule(moduleName);\n        if (module) {\n          return this._moduleNameCache[key] = module;\n        }\n      }\n\n      // 3. Resolve \"haste packages\" which are `package.json` files outside of\n      // `node_modules` folders anywhere in the file system.\n      var parts = moduleName.split('/');\n      var hastePackage = this.getPackage(parts.shift());\n      if (hastePackage) {\n        try {\n          var _module = (_path || _load_path()).default.join.apply((_path || _load_path()).default, [(_path || _load_path()).default.dirname(hastePackage)].concat(parts));\n          // try resolving with custom resolver first to support extensions,\n          // then fallback to require.resolve\n          return this._moduleNameCache[key] = resolveNodeModule(_module) || require.resolve(_module);\n        } catch (ignoredError) {}\n      }\n      return null;\n    }\n  }, {\n    key: \"resolveModule\",\n    value: function resolveModule(from, moduleName, options) {\n      var dirname = (_path || _load_path()).default.dirname(from);\n      var module = this.resolveModuleFromDirIfExists(dirname, moduleName, options);\n      if (module) return module;\n\n      // (4.) Throw an error if the module could not be found. `resolve.sync`\n      //      only produces an error based on the dirname but we have the actual\n      //      current module name available.\n      var relativePath = (_path || _load_path()).default.relative(dirname, from);\n      var err = new Error(\"Cannot find module '\".concat(moduleName, \"' from '\").concat(relativePath || '.', \"'\"));\n      err.code = 'MODULE_NOT_FOUND';\n      throw err;\n    }\n  }, {\n    key: \"isCoreModule\",\n    value: function isCoreModule(moduleName) {\n      return this._options.hasCoreModules && (0, (_is_builtin_module || _load_is_builtin_module()).default)(moduleName);\n    }\n  }, {\n    key: \"getModule\",\n    value: function getModule(name) {\n      return this._moduleMap.getModule(name, this._options.defaultPlatform, this._supportsNativePlatform());\n    }\n  }, {\n    key: \"getModulePath\",\n    value: function getModulePath(from, moduleName) {\n      if (moduleName[0] !== '.' || (_path || _load_path()).default.isAbsolute(moduleName)) {\n        return moduleName;\n      }\n      return (_path || _load_path()).default.normalize((_path || _load_path()).default.dirname(from) + '/' + moduleName);\n    }\n  }, {\n    key: \"getPackage\",\n    value: function getPackage(name) {\n      return this._moduleMap.getPackage(name, this._options.defaultPlatform, this._supportsNativePlatform());\n    }\n  }, {\n    key: \"getMockModule\",\n    value: function getMockModule(from, name) {\n      var mock = this._moduleMap.getMockModule(name);\n      if (mock) {\n        return mock;\n      } else {\n        var moduleName = this._resolveStubModuleName(from, name);\n        if (moduleName) {\n          return this.getModule(moduleName) || moduleName;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"getModulePaths\",\n    value: function getModulePaths(from) {\n      if (!this._modulePathCache[from]) {\n        var moduleDirectory = this._options.moduleDirectories;\n        var paths = (0, (_node_modules_paths || _load_node_modules_paths()).default)(from, {\n          moduleDirectory: moduleDirectory\n        });\n        if (paths[paths.length - 1] === undefined) {\n          // circumvent node-resolve bug that adds `undefined` as last item.\n          paths.pop();\n        }\n        this._modulePathCache[from] = paths;\n      }\n      return this._modulePathCache[from];\n    }\n  }, {\n    key: \"getModuleID\",\n    value: function getModuleID(virtualMocks, from, _moduleName) {\n      var moduleName = _moduleName || '';\n      var key = from + (_path || _load_path()).default.delimiter + moduleName;\n      if (this._moduleIDCache[key]) {\n        return this._moduleIDCache[key];\n      }\n      var moduleType = this._getModuleType(moduleName);\n      var absolutePath = this._getAbsolutePath(virtualMocks, from, moduleName);\n      var mockPath = this._getMockPath(from, moduleName);\n      var sep = (_path || _load_path()).default.delimiter;\n      var id = moduleType + sep + (absolutePath ? absolutePath + sep : '') + (mockPath ? mockPath + sep : '');\n      return this._moduleIDCache[key] = id;\n    }\n  }, {\n    key: \"_getModuleType\",\n    value: function _getModuleType(moduleName) {\n      return this.isCoreModule(moduleName) ? 'node' : 'user';\n    }\n  }, {\n    key: \"_getAbsolutePath\",\n    value: function _getAbsolutePath(virtualMocks, from, moduleName) {\n      if (this.isCoreModule(moduleName)) {\n        return moduleName;\n      }\n      return this._isModuleResolved(from, moduleName) ? this.getModule(moduleName) : this._getVirtualMockPath(virtualMocks, from, moduleName);\n    }\n  }, {\n    key: \"_getMockPath\",\n    value: function _getMockPath(from, moduleName) {\n      return !this.isCoreModule(moduleName) ? this.getMockModule(from, moduleName) : null;\n    }\n  }, {\n    key: \"_getVirtualMockPath\",\n    value: function _getVirtualMockPath(virtualMocks, from, moduleName) {\n      var virtualMockPath = this.getModulePath(from, moduleName);\n      return virtualMocks[virtualMockPath] ? virtualMockPath : moduleName ? this.resolveModule(from, moduleName) : from;\n    }\n  }, {\n    key: \"_isModuleResolved\",\n    value: function _isModuleResolved(from, moduleName) {\n      return !!(this.getModule(moduleName) || this.getMockModule(from, moduleName));\n    }\n  }, {\n    key: \"_resolveStubModuleName\",\n    value: function _resolveStubModuleName(from, moduleName) {\n      var _this2 = this;\n      var dirname = (_path || _load_path()).default.dirname(from);\n      var paths = this._options.modulePaths;\n      var extensions = this._options.extensions;\n      var moduleDirectory = this._options.moduleDirectories;\n      var moduleNameMapper = this._options.moduleNameMapper;\n      var resolver = this._options.resolver;\n      if (moduleNameMapper) {\n        var _iterator = _createForOfIteratorHelper(moduleNameMapper),\n          _step;\n        try {\n          var _loop = function _loop() {\n            var _ref = _step.value;\n            var mappedModuleName = _ref.moduleName;\n            var regex = _ref.regex;\n            if (regex.test(moduleName)) {\n              // Note: once a moduleNameMapper matches the name, it must result\n              // in a module, or else an error is thrown.\n              var matches = moduleName.match(regex);\n              var updatedName = matches ? mappedModuleName.replace(/\\$([0-9]+)/g, function (_, index) {\n                return matches[parseInt(index, 10)];\n              }) : mappedModuleName;\n              var _module2 = _this2.getModule(updatedName) || Resolver.findNodeModule(updatedName, {\n                basedir: dirname,\n                browser: _this2._options.browser,\n                extensions: extensions,\n                moduleDirectory: moduleDirectory,\n                paths: paths,\n                resolver: resolver,\n                rootDir: _this2._options.rootDir\n              });\n              if (!_module2) {\n                throw createNoMappedModuleFoundError(moduleName, updatedName, mappedModuleName, regex, resolver);\n              }\n              return {\n                v: _module2\n              };\n            }\n          };\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _ret = _loop();\n            if (typeof _ret === \"object\") return _ret.v;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_supportsNativePlatform\",\n    value: function _supportsNativePlatform() {\n      return (this._options.platforms || []).indexOf(NATIVE_PLATFORM) !== -1;\n    }\n  }], [{\n    key: \"findNodeModule\",\n    value: function findNodeModule(path, options) {\n      var resolver = options.resolver /* $FlowFixMe */ ? require(options.resolver) : (_default_resolver || _load_default_resolver()).default;\n      var paths = options.paths;\n      try {\n        return resolver(path, {\n          basedir: options.basedir,\n          browser: options.browser,\n          extensions: options.extensions,\n          moduleDirectory: options.moduleDirectory,\n          paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n          rootDir: options.rootDir\n        });\n      } catch (e) {}\n      return null;\n    }\n  }]);\n  return Resolver;\n}();\nvar createNoMappedModuleFoundError = function createNoMappedModuleFoundError(moduleName, updatedName, mappedModuleName, regex, resolver) {\n  var error = new Error((_chalk || _load_chalk()).default.red(\"\".concat((_chalk || _load_chalk()).default.bold('Configuration error'), \":\\n\\nCould not locate module \").concat((_chalk || _load_chalk()).default.bold(moduleName), \" mapped as:\\n\").concat((_chalk || _load_chalk()).default.bold(updatedName), \".\\n\\nPlease check your configuration for these entries:\\n{\\n  \\\"moduleNameMapper\\\": {\\n    \\\"\").concat(regex.toString(), \"\\\": \\\"\").concat((_chalk || _load_chalk()).default.bold(mappedModuleName), \"\\\"\\n  },\\n  \\\"resolver\\\": \").concat((_chalk || _load_chalk()).default.bold(String(resolver)), \"\\n}\")));\n  error.name = '';\n  return error;\n};\nmodule.exports = Resolver;","map":null,"metadata":{},"sourceType":"script"}