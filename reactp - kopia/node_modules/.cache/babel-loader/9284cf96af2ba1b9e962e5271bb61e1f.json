{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var comma = ','.charCodeAt(0);\n  var semicolon = ';'.charCodeAt(0);\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  var intToChar = new Uint8Array(64); // 64 possible chars.\n  var charToInt = new Uint8Array(128); // z is 122 in ASCII\n  for (var i = 0; i < chars.length; i++) {\n    var c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n  }\n  // Provide a fallback for older environments.\n  var td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {\n    decode: function decode(buf) {\n      var out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      return out.toString();\n    }\n  } : {\n    decode: function decode(buf) {\n      var out = '';\n      for (var _i = 0; _i < buf.length; _i++) {\n        out += String.fromCharCode(buf[_i]);\n      }\n      return out;\n    }\n  };\n  function decode(mappings) {\n    var state = new Int32Array(5);\n    var decoded = [];\n    var index = 0;\n    do {\n      var semi = indexOf(mappings, index);\n      var line = [];\n      var sorted = true;\n      var lastCol = 0;\n      state[0] = 0;\n      for (var _i2 = index; _i2 < semi; _i2++) {\n        var seg = void 0;\n        _i2 = decodeInteger(mappings, _i2, state, 0); // genColumn\n        var col = state[0];\n        if (col < lastCol) sorted = false;\n        lastCol = col;\n        if (hasMoreVlq(mappings, _i2, semi)) {\n          _i2 = decodeInteger(mappings, _i2, state, 1); // sourcesIndex\n          _i2 = decodeInteger(mappings, _i2, state, 2); // sourceLine\n          _i2 = decodeInteger(mappings, _i2, state, 3); // sourceColumn\n          if (hasMoreVlq(mappings, _i2, semi)) {\n            _i2 = decodeInteger(mappings, _i2, state, 4); // namesIndex\n            seg = [col, state[1], state[2], state[3], state[4]];\n          } else {\n            seg = [col, state[1], state[2], state[3]];\n          }\n        } else {\n          seg = [col];\n        }\n        line.push(seg);\n      }\n      if (!sorted) sort(line);\n      decoded.push(line);\n      index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n  }\n  function indexOf(mappings, index) {\n    var idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n  }\n  function decodeInteger(mappings, pos, state, j) {\n    var value = 0;\n    var shift = 0;\n    var integer = 0;\n    do {\n      var _c = mappings.charCodeAt(pos++);\n      integer = charToInt[_c];\n      value |= (integer & 31) << shift;\n      shift += 5;\n    } while (integer & 32);\n    var shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n      value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n  }\n  function hasMoreVlq(mappings, i, length) {\n    if (i >= length) return false;\n    return mappings.charCodeAt(i) !== comma;\n  }\n  function sort(line) {\n    line.sort(sortComparator);\n  }\n  function sortComparator(a, b) {\n    return a[0] - b[0];\n  }\n  function encode(decoded) {\n    var state = new Int32Array(5);\n    var bufLength = 1024 * 16;\n    var subLength = bufLength - 36;\n    var buf = new Uint8Array(bufLength);\n    var sub = buf.subarray(0, subLength);\n    var pos = 0;\n    var out = '';\n    for (var _i3 = 0; _i3 < decoded.length; _i3++) {\n      var line = decoded[_i3];\n      if (_i3 > 0) {\n        if (pos === bufLength) {\n          out += td.decode(buf);\n          pos = 0;\n        }\n        buf[pos++] = semicolon;\n      }\n      if (line.length === 0) continue;\n      state[0] = 0;\n      for (var j = 0; j < line.length; j++) {\n        var segment = line[j];\n        // We can push up to 5 ints, each int can take at most 7 chars, and we\n        // may push a comma.\n        if (pos > subLength) {\n          out += td.decode(sub);\n          buf.copyWithin(0, subLength, pos);\n          pos -= subLength;\n        }\n        if (j > 0) buf[pos++] = comma;\n        pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n        if (segment.length === 1) continue;\n        pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n        pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n        pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n        if (segment.length === 4) continue;\n        pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n      }\n    }\n\n    return out + td.decode(buf.subarray(0, pos));\n  }\n  function encodeInteger(buf, pos, state, segment, j) {\n    var next = segment[j];\n    var num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n    do {\n      var clamped = num & 31;\n      num >>>= 5;\n      if (num > 0) clamped |= 32;\n      buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n  }\n  exports.decode = decode;\n  exports.encode = encode;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}