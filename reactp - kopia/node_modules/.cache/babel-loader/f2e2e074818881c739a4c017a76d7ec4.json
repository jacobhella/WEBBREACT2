{"ast":null,"code":"/**\n * Copyright (c) 2017-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n'use strict';\n\nvar _types;\nfunction _load_types() {\n  return _types = require('./types');\n}\nvar file = null;\n\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\nprocess.on('message', function (request /* Should be ChildMessage */) {\n  switch (request[0]) {\n    case (_types || _load_types()).CHILD_MESSAGE_INITIALIZE:\n      file = request[2];\n      break;\n    case (_types || _load_types()).CHILD_MESSAGE_CALL:\n      execMethod(request[2], request[3]);\n      break;\n    case (_types || _load_types()).CHILD_MESSAGE_END:\n      process.exit(0);\n      break;\n    default:\n      throw new TypeError('Unexpected request from parent process: ' + request[0]);\n  }\n});\nfunction reportSuccess(result) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n  process.send([(_types || _load_types()).PARENT_MESSAGE_OK, result]);\n}\nfunction reportError(error) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n  process.send([(_types || _load_types()).PARENT_MESSAGE_ERROR, error.constructor && error.constructor.name, error.message, error.stack,\n  // $FlowFixMe: this is safe to just inherit from Object.\n  typeof error === 'object' ? Object.assign({}, error) : error]);\n}\nfunction execMethod(method, args) {\n  // $FlowFixMe: This has to be a dynamic require.\n  var main = require(file);\n  var result;\n  try {\n    if (method === 'default') {\n      result = (main.__esModule ? main['default'] : main).apply(global, args);\n    } else {\n      result = main[method].apply(main, args);\n    }\n  } catch (err) {\n    reportError(err);\n    return;\n  }\n  if (result && typeof result.then === 'function') {\n    result.then(reportSuccess, reportError);\n  } else {\n    reportSuccess(result);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}