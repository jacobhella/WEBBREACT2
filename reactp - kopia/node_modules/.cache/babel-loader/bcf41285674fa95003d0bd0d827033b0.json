{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = require('path'),\n  mkdirp = require('mkdirp'),\n  once = require('once'),\n  async = require('async'),\n  fs = require('fs'),\n  filesFor = require('./file-matcher').filesFor,\n  libInstrument = require('istanbul-lib-instrument'),\n  libCoverage = require('istanbul-lib-coverage'),\n  inputError = require('./input-error');\n\n/*\n * Chunk file size to use when reading non JavaScript files in memory\n * and copying them over when using complete-copy flag.\n */\nvar READ_FILE_CHUNK_SIZE = 64 * 1024;\nfunction BaselineCollector(instrumenter) {\n  this.instrumenter = instrumenter;\n  this.map = libCoverage.createCoverageMap();\n  this.instrument = instrumenter.instrument.bind(this.instrumenter);\n  var origInstrumentSync = instrumenter.instrumentSync;\n  this.instrumentSync = function () {\n    var args = Array.prototype.slice.call(arguments),\n      ret = origInstrumentSync.apply(this.instrumenter, args),\n      baseline = this.instrumenter.lastFileCoverage();\n    this.map.addFileCoverage(baseline);\n    return ret;\n  };\n  //monkey patch the instrumenter to call our version instead\n  instrumenter.instrumentSync = this.instrumentSync.bind(this);\n}\nBaselineCollector.prototype.getCoverage = function () {\n  return this.map.toJSON();\n};\nfunction processFiles(instrumenter, opts, callback) {\n  var inputDir = opts.inputDir,\n    outputDir = opts.outputDir,\n    relativeNames = opts.names,\n    extensions = opts.extensions,\n    verbose = opts.verbose;\n  var processor = function processor(name, callback) {\n      var inputFile = path.resolve(inputDir, name),\n        outputFile = path.resolve(outputDir, name),\n        inputFileExtension = path.extname(inputFile),\n        isJavaScriptFile = extensions.indexOf(inputFileExtension) > -1,\n        oDir = path.dirname(outputFile),\n        readStream,\n        writeStream;\n      callback = once(callback);\n      mkdirp.sync(oDir);\n\n      /* istanbul ignore if */\n      if (fs.statSync(inputFile).isDirectory()) {\n        return callback(null, name);\n      }\n      if (isJavaScriptFile) {\n        fs.readFile(inputFile, 'utf8', function (err, data) {\n          /* istanbul ignore if */if (err) {\n            return callback(err, name);\n          }\n          instrumenter.instrument(data, inputFile, function (iErr, instrumented) {\n            if (iErr) {\n              return callback(iErr, name);\n            }\n            fs.writeFile(outputFile, instrumented, 'utf8', function (err) {\n              return callback(err, name);\n            });\n          });\n        });\n      } else {\n        // non JavaScript file, copy it as is\n        readStream = fs.createReadStream(inputFile, {\n          'bufferSize': READ_FILE_CHUNK_SIZE\n        });\n        writeStream = fs.createWriteStream(outputFile);\n        readStream.on('error', callback);\n        writeStream.on('error', callback);\n        readStream.pipe(writeStream);\n        readStream.on('end', function () {\n          callback(null, name);\n        });\n      }\n    },\n    q = async.queue(processor, 10),\n    errors = [],\n    count = 0,\n    startTime = new Date().getTime();\n  q.push(relativeNames, function (err, name) {\n    var inputFile, outputFile;\n    if (err) {\n      errors.push({\n        file: name,\n        error: err.message || /* istanbul ignore next */err.toString()\n      });\n      inputFile = path.resolve(inputDir, name);\n      outputFile = path.resolve(outputDir, name);\n      fs.writeFileSync(outputFile, fs.readFileSync(inputFile));\n    }\n    if (verbose) {\n      console.error('Processed: ' + name);\n    } else {\n      if (count % 100 === 0) {\n        process.stdout.write('.');\n      }\n    }\n    count += 1;\n  });\n  q.drain = function () {\n    var endTime = new Date().getTime();\n    console.error('\\nProcessed [' + count + '] files in ' + Math.floor((endTime - startTime) / 1000) + ' secs');\n    if (errors.length > 0) {\n      console.error('The following ' + errors.length + ' file(s) had errors and were copied as-is');\n      console.error(errors);\n    }\n    return callback();\n  };\n}\nfunction run(config, opts, callback) {\n  opts = opts || {};\n  var iOpts = config.instrumentation,\n    input = opts.input,\n    output = opts.output,\n    excludes = opts.excludes,\n    file,\n    stats,\n    stream,\n    includes,\n    instrumenter,\n    origCallback = callback,\n    needBaseline = iOpts.saveBaseline(),\n    baselineFile = path.resolve(iOpts.baselineFile());\n  if (iOpts.completeCopy()) {\n    includes = ['**/*'];\n  } else {\n    includes = iOpts.extensions().map(function (ext) {\n      return '**/*' + ext;\n    });\n  }\n  if (!input) {\n    return callback(new Error('No input specified'));\n  }\n  instrumenter = libInstrument.createInstrumenter(iOpts.getInstrumenterOpts());\n  if (needBaseline) {\n    mkdirp.sync(path.dirname(baselineFile));\n    instrumenter = new BaselineCollector(instrumenter);\n    callback = function callback(err) {\n      /* istanbul ignore else */\n      if (!err) {\n        console.error('Saving baseline coverage at ' + baselineFile);\n        fs.writeFileSync(baselineFile, JSON.stringify(instrumenter.getCoverage()), 'utf8');\n      }\n      return origCallback(err);\n    };\n  }\n  file = path.resolve(input);\n  stats = fs.statSync(file);\n  if (stats.isDirectory()) {\n    if (!output) {\n      return callback(inputError.create('Need an output directory when input is a directory!'));\n    }\n    if (output === file) {\n      return callback(inputError.create('Cannot instrument into the same directory/ file as input!'));\n    }\n    mkdirp.sync(output);\n    filesFor({\n      root: file,\n      includes: includes,\n      excludes: excludes || iOpts.excludes(false),\n      relative: true\n    }, function (err, files) {\n      /* istanbul ignore if */\n      if (err) {\n        return callback(err);\n      }\n      processFiles(instrumenter, {\n        inputDir: file,\n        outputDir: output,\n        names: files,\n        extensions: iOpts.extensions(),\n        verbose: config.verbose\n      }, callback);\n    });\n  } else {\n    if (output) {\n      stream = fs.createWriteStream(output);\n    } else {\n      stream = process.stdout;\n    }\n    stream.write(instrumenter.instrumentSync(fs.readFileSync(file, 'utf8'), file));\n    if (stream !== process.stdout) {\n      stream.end();\n    }\n    return callback();\n  }\n}\nmodule.exports = {\n  run: run\n};","map":null,"metadata":{},"sourceType":"script"}