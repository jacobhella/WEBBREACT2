{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\nvar NO_NAME = -1;\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nvar addSegment;\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nvar addMapping;\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nvar maybeAddSegment;\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nvar maybeAddMapping;\n/**\n * Adds/removes the content of the source file to the source map.\n */\nvar setSourceContent;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nvar toDecodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nvar toEncodedMap;\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nvar fromMap;\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nvar allMappings;\n// This split declaration is only so that terser can elminiate the static initialization block.\nvar addSegmentInternal;\n/**\n * Provides the state to generate a sourcemap.\n */\nvar GenMapping = function GenMapping() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    file = _ref.file,\n    sourceRoot = _ref.sourceRoot;\n  _classCallCheck(this, GenMapping);\n  this._names = new SetArray();\n  this._sources = new SetArray();\n  this._sourcesContent = [];\n  this._mappings = [];\n  this.file = file;\n  this.sourceRoot = sourceRoot;\n};\n(function () {\n  addSegment = function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n  };\n  maybeAddSegment = function maybeAddSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n  };\n  addMapping = function addMapping(map, mapping) {\n    return addMappingInternal(false, map, mapping);\n  };\n  maybeAddMapping = function maybeAddMapping(map, mapping) {\n    return addMappingInternal(true, map, mapping);\n  };\n  setSourceContent = function setSourceContent(map, source, content) {\n    var sources = map._sources,\n      sourcesContent = map._sourcesContent;\n    sourcesContent[put(sources, source)] = content;\n  };\n  toDecodedMap = function toDecodedMap(map) {\n    var file = map.file,\n      sourceRoot = map.sourceRoot,\n      mappings = map._mappings,\n      sources = map._sources,\n      sourcesContent = map._sourcesContent,\n      names = map._names;\n    removeEmptyFinalLines(mappings);\n    return {\n      version: 3,\n      file: file || undefined,\n      names: names.array,\n      sourceRoot: sourceRoot || undefined,\n      sources: sources.array,\n      sourcesContent: sourcesContent,\n      mappings: mappings\n    };\n  };\n  toEncodedMap = function toEncodedMap(map) {\n    var decoded = toDecodedMap(map);\n    return Object.assign(Object.assign({}, decoded), {\n      mappings: encode(decoded.mappings)\n    });\n  };\n  allMappings = function allMappings(map) {\n    var out = [];\n    var mappings = map._mappings,\n      sources = map._sources,\n      names = map._names;\n    for (var i = 0; i < mappings.length; i++) {\n      var line = mappings[i];\n      for (var j = 0; j < line.length; j++) {\n        var seg = line[j];\n        var generated = {\n          line: i + 1,\n          column: seg[COLUMN]\n        };\n        var source = undefined;\n        var original = undefined;\n        var name = undefined;\n        if (seg.length !== 1) {\n          source = sources.array[seg[SOURCES_INDEX]];\n          original = {\n            line: seg[SOURCE_LINE] + 1,\n            column: seg[SOURCE_COLUMN]\n          };\n          if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n        }\n        out.push({\n          generated: generated,\n          source: source,\n          original: original,\n          name: name\n        });\n      }\n    }\n    return out;\n  };\n  fromMap = function fromMap(input) {\n    var map = new TraceMap(input);\n    var gen = new GenMapping({\n      file: map.file,\n      sourceRoot: map.sourceRoot\n    });\n    putAll(gen._names, map.names);\n    putAll(gen._sources, map.sources);\n    gen._sourcesContent = map.sourcesContent || map.sources.map(function () {\n      return null;\n    });\n    gen._mappings = decodedMappings(map);\n    return gen;\n  };\n  // Internal helpers\n  addSegmentInternal = function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    var mappings = map._mappings,\n      sources = map._sources,\n      sourcesContent = map._sourcesContent,\n      names = map._names;\n    var line = getLine(mappings, genLine);\n    var index = getColumnIndex(line, genColumn);\n    if (!source) {\n      if (skipable && skipSourceless(line, index)) return;\n      return insert(line, index, [genColumn]);\n    }\n    var sourcesIndex = put(sources, source);\n    var namesIndex = name ? put(names, name) : NO_NAME;\n    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n      return;\n    }\n    return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n  };\n})();\nfunction getLine(mappings, index) {\n  for (var i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\nfunction getColumnIndex(line, genColumn) {\n  var index = line.length;\n  for (var i = index - 1; i >= 0; index = i--) {\n    var current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\nfunction insert(array, index, value) {\n  for (var i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n  var length = mappings.length;\n  var len = length;\n  for (var i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\nfunction putAll(strarr, array) {\n  for (var i = 0; i < array.length; i++) put(strarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n  var prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n  var prev = line[index - 1];\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n}\nfunction addMappingInternal(skipable, map, mapping) {\n  var generated = mapping.generated,\n    source = mapping.source,\n    original = mapping.original,\n    name = mapping.name,\n    content = mapping.content;\n  if (!source) {\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n  }\n  var s = source;\n  return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);\n}\nexport { GenMapping, addMapping, addSegment, allMappings, fromMap, maybeAddMapping, maybeAddSegment, setSourceContent, toDecodedMap, toEncodedMap };","map":null,"metadata":{},"sourceType":"module"}