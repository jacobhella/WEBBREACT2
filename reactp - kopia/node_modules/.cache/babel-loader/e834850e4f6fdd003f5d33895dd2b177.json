{"ast":null,"code":"'use strict';\n\nvar argsert = require('./argsert');\nvar objFilter = require('./obj-filter');\nvar specialKeys = ['$0', '--', '_'];\n\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nmodule.exports = function validation(yargs, usage, y18n) {\n  var __ = y18n.__;\n  var __n = y18n.__n;\n  var self = {};\n\n  // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n  self.nonOptionCount = function nonOptionCount(argv) {\n    var demandedCommands = yargs.getDemandedCommands();\n    // don't count currently executing commands\n    var _s = argv._.length - yargs.getContext().commands.length;\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(\n          // replace $0 with observed, $1 with expected.\n          demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.min) : null);\n        } else {\n          usage.fail(__('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(\n          // replace $0 with observed, $1 with expected.\n          demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.max) : null);\n        } else {\n          usage.fail(__('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max));\n        }\n      }\n    }\n  };\n\n  // validate the appropriate # of <required>\n  // positional arguments were provided:\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__('Not enough non-option arguments: got %s, need at least %s', observed, required));\n    }\n  };\n\n  // make sure all the required arguments are present.\n  self.requiredArguments = function requiredArguments(argv) {\n    var demandedOptions = yargs.getDemandedOptions();\n    var missing = null;\n    Object.keys(demandedOptions).forEach(function (key) {\n      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    });\n    if (missing) {\n      var customMsgs = [];\n      Object.keys(missing).forEach(function (key) {\n        var msg = missing[key];\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      });\n      var customMsg = customMsgs.length ? \"\\n\".concat(customMsgs.join('\\n')) : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  };\n\n  // check for unknown arguments (strict-mode).\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap) {\n    var commandKeys = yargs.getCommandInstance().getCommands();\n    var unknown = [];\n    var currentContext = yargs.getContext();\n    Object.keys(argv).forEach(function (key) {\n      if (specialKeys.indexOf(key) === -1 && !positionalMap.hasOwnProperty(key) && !yargs._getParseContext().hasOwnProperty(key) && !aliases.hasOwnProperty(key)) {\n        unknown.push(key);\n      }\n    });\n    if (commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(function (key) {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key);\n        }\n      });\n    }\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  };\n\n  // validate arguments limited to enumerated choices\n  self.limitedChoices = function limitedChoices(argv) {\n    var options = yargs.getOptions();\n    var invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(function (key) {\n      if (specialKeys.indexOf(key) === -1 && options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach(function (value) {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    var invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n    var msg = __('Invalid values:');\n    invalidKeys.forEach(function (key) {\n      msg += \"\\n  \".concat(__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key])));\n    });\n    usage.fail(msg);\n  };\n\n  // custom checks, added using the `check` option on yargs.\n  var checks = [];\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global: global\n    });\n  };\n  self.customChecks = function customChecks(argv, aliases) {\n    for (var i = 0, f; (f = checks[i]) !== undefined; i++) {\n      var func = f.func;\n      var result = null;\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  };\n\n  // check implications, argument foo implies => argument bar.\n  var implied = {};\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n      if (Array.isArray(value)) {\n        value.forEach(function (i) {\n          return self.implies(key, i);\n        });\n      } else {\n        implied[key].push(value);\n      }\n    }\n  };\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n  self.implications = function implications(argv) {\n    var implyFail = [];\n    Object.keys(implied).forEach(function (key) {\n      var origKey = key;\n      (implied[key] || []).forEach(function (value) {\n        var num;\n        var key = origKey;\n        var origValue = value;\n\n        // convert string '1' to number 1\n        num = Number(key);\n        key = isNaN(num) ? key : num;\n        if (typeof key === 'number') {\n          // check length of argv._\n          key = argv._.length >= key;\n        } else if (key.match(/^--no-.+/)) {\n          // check if key doesn't exist\n          key = key.match(/^--no-(.+)/)[1];\n          key = !argv[key];\n        } else {\n          // check if key exists\n          key = argv[key];\n        }\n        num = Number(value);\n        value = isNaN(num) ? value : num;\n        if (typeof value === 'number') {\n          value = argv._.length >= value;\n        } else if (value.match(/^--no-.+/)) {\n          value = value.match(/^--no-(.+)/)[1];\n          value = !argv[value];\n        } else {\n          value = argv[value];\n        }\n        if (key && !value) {\n          implyFail.push(\" \".concat(origKey, \" -> \").concat(origValue));\n        }\n      });\n    });\n    if (implyFail.length) {\n      var msg = \"\".concat(__('Implications failed:'), \"\\n\");\n      implyFail.forEach(function (value) {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n  var conflicting = {};\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n      if (Array.isArray(value)) {\n        value.forEach(function (i) {\n          return self.conflicts(key, i);\n        });\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n  self.getConflicting = function () {\n    return conflicting;\n  };\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(function (key) {\n      if (conflicting[key]) {\n        conflicting[key].forEach(function (value) {\n          // we default keys to 'undefined' that have been configured, we should not\n          // apply conflicting check unless they are a value other than 'undefined'.\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__(\"Arguments \".concat(key, \" and \").concat(value, \" are mutually exclusive\")));\n          }\n        });\n      }\n    });\n  };\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    var distance = require('./levenshtein');\n    var threshold = 3; // if it takes more than three edits, let's move on.\n    potentialCommands = potentialCommands.sort(function (a, b) {\n      return b.length - a.length;\n    });\n    var recommended = null;\n    var bestDistance = Infinity;\n    for (var i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      var d = distance(cmd, candidate);\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, function (k, v) {\n      return !localLookup[k];\n    });\n    conflicting = objFilter(conflicting, function (k, v) {\n      return !localLookup[k];\n    });\n    checks = checks.filter(function (c) {\n      return c.global;\n    });\n    return self;\n  };\n  var frozen;\n  self.freeze = function freeze() {\n    frozen = {};\n    frozen.implied = implied;\n    frozen.checks = checks;\n    frozen.conflicting = conflicting;\n  };\n  self.unfreeze = function unfreeze() {\n    implied = frozen.implied;\n    checks = frozen.checks;\n    conflicting = frozen.conflicting;\n    frozen = undefined;\n  };\n  return self;\n};","map":null,"metadata":{},"sourceType":"script"}