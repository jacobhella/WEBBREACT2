{"ast":null,"code":"'use strict';\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error('babel-plugin-jest-hoist: ' + message);\n  }\n}\n\n// We allow `jest`, `expect`, `require`, all default Node.js globals and all\n// ES2015 built-ins to be used inside of a `jest.mock` factory.\n// We also allow variables prefixed with `mock` as an escape-hatch.\nvar WHITELISTED_IDENTIFIERS = {\n  Array: true,\n  ArrayBuffer: true,\n  Boolean: true,\n  DataView: true,\n  Date: true,\n  Error: true,\n  EvalError: true,\n  Float32Array: true,\n  Float64Array: true,\n  Function: true,\n  Generator: true,\n  GeneratorFunction: true,\n  Infinity: true,\n  Int16Array: true,\n  Int32Array: true,\n  Int8Array: true,\n  InternalError: true,\n  Intl: true,\n  JSON: true,\n  Map: true,\n  Math: true,\n  NaN: true,\n  Number: true,\n  Object: true,\n  Promise: true,\n  Proxy: true,\n  RangeError: true,\n  ReferenceError: true,\n  Reflect: true,\n  RegExp: true,\n  Set: true,\n  String: true,\n  Symbol: true,\n  SyntaxError: true,\n  TypeError: true,\n  URIError: true,\n  Uint16Array: true,\n  Uint32Array: true,\n  Uint8Array: true,\n  Uint8ClampedArray: true,\n  WeakMap: true,\n  WeakSet: true,\n  arguments: true,\n  console: true,\n  expect: true,\n  isNaN: true,\n  jest: true,\n  parseFloat: true,\n  parseInt: true,\n  require: true,\n  undefined: true\n};\nObject.keys(global).forEach(function (name) {\n  return WHITELISTED_IDENTIFIERS[name] = true;\n});\nvar JEST_GLOBAL = {\n  name: 'jest'\n};\nvar IDVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path) {\n    this.ids.add(path);\n  },\n  blacklist: ['TypeAnnotation']\n};\nvar FUNCTIONS = Object.create(null);\nFUNCTIONS.mock = function (args) {\n  if (args.length === 1) {\n    return args[0].isStringLiteral() || args[0].isLiteral();\n  } else if (args.length === 2 || args.length === 3) {\n    var moduleFactory = args[1];\n    invariant(moduleFactory.isFunction(), 'The second argument of `jest.mock` must be an inline function.');\n    var ids = new Set();\n    var parentScope = moduleFactory.parentPath.scope;\n    moduleFactory.traverse(IDVisitor, {\n      ids: ids\n    });\n    var _iterator = _createForOfIteratorHelper(ids),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var id = _step.value;\n        var name = id.node.name;\n        var found = false;\n        var scope = id.scope;\n        while (scope !== parentScope) {\n          if (scope.bindings[name]) {\n            found = true;\n            break;\n          }\n          scope = scope.parent;\n        }\n        if (!found) {\n          invariant(scope.hasGlobal(name) && WHITELISTED_IDENTIFIERS[name] || /^mock/i.test(name) ||\n          // Allow istanbul's coverage variable to pass.\n          /^(?:__)?cov/.test(name), 'The module factory of `jest.mock()` is not allowed to ' + 'reference any out-of-scope variables.\\n' + 'Invalid variable access: ' + name + '\\n' + 'Whitelisted objects: ' + Object.keys(WHITELISTED_IDENTIFIERS).join(', ') + '.\\n' + 'Note: This is a precaution to guard against uninitialized mock ' + 'variables. If it is ensured that the mock is required lazily, ' + 'variable names prefixed with `mock` (case insensitive) are permitted.');\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return true;\n  }\n  return false;\n};\nFUNCTIONS.unmock = function (args) {\n  return args.length === 1 && args[0].isStringLiteral();\n};\nFUNCTIONS.deepUnmock = function (args) {\n  return args.length === 1 && args[0].isStringLiteral();\n};\nFUNCTIONS.disableAutomock = FUNCTIONS.enableAutomock = function (args) {\n  return args.length === 0;\n};\nmodule.exports = function () {\n  var isJest = function isJest(callee) {\n    return callee.get('object').isIdentifier(JEST_GLOBAL) || callee.isMemberExpression() && isJest(callee.get('object'));\n  };\n  var shouldHoistExpression = function shouldHoistExpression(expr) {\n    if (!expr.isCallExpression()) {\n      return false;\n    }\n    var callee = expr.get('callee');\n    var object = callee.get('object');\n    var property = callee.get('property');\n    return property.isIdentifier() && FUNCTIONS[property.node.name] && (object.isIdentifier(JEST_GLOBAL) || callee.isMemberExpression() && shouldHoistExpression(object)) && FUNCTIONS[property.node.name](expr.get('arguments'));\n  };\n  return {\n    visitor: {\n      ExpressionStatement: function ExpressionStatement(path) {\n        if (shouldHoistExpression(path.get('expression'))) {\n          path.node._blockHoist = Infinity;\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}