{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\nvar _typeof3 = _interopRequireDefault(_typeof2);\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._maybePopFromStatements = _maybePopFromStatements;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\nvar _cache = require(\"../cache\");\nvar _hoister = require(\"./lib/hoister\");\nvar _hoister2 = _interopRequireDefault(_hoister);\nvar _index = require(\"./index\");\nvar _index2 = _interopRequireDefault(_index);\nvar _babelTypes = require(\"babel-types\");\nvar t = _interopRequireWildcard(_babelTypes);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n  nodes = this._verifyNodeList(nodes);\n  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {\n    return this.parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") || this.parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    this.replaceExpressionWithStatements(nodes);\n  } else {\n    this._maybePopFromStatements(nodes);\n    if (Array.isArray(this.container)) {\n      return this._containerInsertBefore(nodes);\n    } else if (this.isStatementOrBlock()) {\n      if (this.node) nodes.push(this.node);\n      this._replaceWith(t.blockStatement(nodes));\n    } else {\n      throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n    }\n  }\n  return [this];\n}\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  var paths = [];\n  for (var i = 0; i < nodes.length; i++) {\n    var to = from + i;\n    var node = nodes[i];\n    this.container.splice(to, 0, node);\n    if (this.context) {\n      var path = this.context.create(this.parent, this.container, to, this.listKey);\n      if (this.context.queue) path.pushContext(this.context);\n      paths.push(path);\n    } else {\n      paths.push(_index2.default.get({\n        parentPath: this.parentPath,\n        parent: this.parent,\n        container: this.container,\n        listKey: this.listKey,\n        key: to\n      }));\n    }\n  }\n  var contexts = this._getQueueContexts();\n  for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n    var _ref;\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n    var _path = _ref;\n    _path.setScope();\n    _path.debug(function () {\n      return \"Inserted.\";\n    });\n    for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref2;\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n      var context = _ref2;\n      context.maybeQueue(_path, true);\n    }\n  }\n  return paths;\n}\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\nfunction _maybePopFromStatements(nodes) {\n  var last = nodes[nodes.length - 1];\n  var isIdentifier = t.isIdentifier(last) || t.isExpressionStatement(last) && t.isIdentifier(last.expression);\n  if (isIdentifier && !this.isCompletionRecord()) {\n    nodes.pop();\n  }\n}\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n  nodes = this._verifyNodeList(nodes);\n  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {\n    return this.parentPath.insertAfter(nodes);\n  } else if (this.isNodeType(\"Expression\") || this.parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      var temp = this.scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", temp, this.node)));\n      nodes.push(t.expressionStatement(temp));\n    }\n    this.replaceExpressionWithStatements(nodes);\n  } else {\n    this._maybePopFromStatements(nodes);\n    if (Array.isArray(this.container)) {\n      return this._containerInsertAfter(nodes);\n    } else if (this.isStatementOrBlock()) {\n      if (this.node) nodes.unshift(this.node);\n      this._replaceWith(t.blockStatement(nodes));\n    } else {\n      throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n    }\n  }\n  return [this];\n}\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n  var paths = _cache.path.get(this.parent);\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var msg = void 0;\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if ((typeof node === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(node)) !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index2.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n    if (msg) {\n      var type = Array.isArray(node) ? \"array\" : typeof node === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(node);\n      throw new Error(\"Node list \" + msg + \" with the index of \" + i + \" and type of \" + type);\n    }\n  }\n  return nodes;\n}\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n  nodes = this._verifyNodeList(nodes);\n  var path = _index2.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey: listKey,\n    key: 0\n  });\n  return path.insertBefore(nodes);\n}\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n  nodes = this._verifyNodeList(nodes);\n  var container = this.node[listKey];\n  var path = _index2.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey: listKey,\n    key: container.length\n  });\n  return path.replaceWithMultiple(nodes);\n}\nfunction hoist() {\n  var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;\n  var hoister = new _hoister2.default(this, scope);\n  return hoister.run();\n}","map":null,"metadata":{},"sourceType":"script"}