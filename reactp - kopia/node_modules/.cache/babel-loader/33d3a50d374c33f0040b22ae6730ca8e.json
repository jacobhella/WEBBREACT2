{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = require('path'),\n  fs = require('fs'),\n  filesFor = require('./file-matcher').filesFor,\n  libCoverage = require('istanbul-lib-coverage'),\n  inputError = require('./input-error'),\n  isAbsolute = path.isAbsolute || function (file) {\n    return path.resolve(file) === path.normalize(file);\n  };\nfunction removeFiles(origMap, root, files) {\n  var filesObj = {},\n    ret = libCoverage.createCoverageMap();\n\n  // Create lookup table.\n  files.forEach(function (file) {\n    filesObj[file] = true;\n  });\n  origMap.files().forEach(function (key) {\n    // Exclude keys will always be relative, but covObj keys can be absolute or relative\n    var excludeKey = isAbsolute(key) ? path.relative(root, key) : key;\n    // Also normalize for files that start with `./`, etc.\n    excludeKey = path.normalize(excludeKey);\n    if (filesObj[excludeKey] !== true) {\n      ret.addFileCoverage(origMap.fileCoverageFor(key));\n    }\n  });\n  return ret;\n}\nfunction run(config, opts, callback) {\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n  var root = opts.root || config.instrumentation.root() || process.cwd(),\n    includePattern = opts.include || '**/coverage*.json',\n    errors = [],\n    check,\n    makeMap,\n    processFiles;\n  check = function check(name, thresholds, actuals) {\n    [\"statements\", \"branches\", \"lines\", \"functions\"].forEach(function (key) {\n      var actual = actuals[key].pct,\n        actualUncovered = actuals[key].total - actuals[key].covered,\n        threshold = thresholds[key];\n      if (threshold < 0) {\n        if (threshold * -1 < actualUncovered) {\n          errors.push('ERROR: Uncovered count for ' + key + ' (' + actualUncovered + ') exceeds ' + name + ' threshold (' + -1 * threshold + ')');\n        }\n      } else {\n        if (actual < threshold) {\n          errors.push('ERROR: Coverage for ' + key + ' (' + actual + '%) does not meet ' + name + ' threshold (' + threshold + '%)');\n        }\n      }\n    });\n  };\n  makeMap = function makeMap(files, callback) {\n    var coverageMap = libCoverage.createCoverageMap();\n    if (files.length === 0) {\n      return callback(inputError.create('ERROR: No coverage files found.'));\n    }\n    files.forEach(function (file) {\n      var coverageObject = JSON.parse(fs.readFileSync(file, 'utf8'));\n      coverageMap.merge(coverageObject);\n    });\n    return callback(null, coverageMap);\n  };\n  processFiles = function processFiles(coverageMap, callback) {\n    var thresholds = {\n        global: {\n          statements: config.check.global.statements || 0,\n          branches: config.check.global.branches || 0,\n          lines: config.check.global.lines || 0,\n          functions: config.check.global.functions || 0,\n          excludes: config.check.global.excludes || []\n        },\n        each: {\n          statements: config.check.each.statements || 0,\n          branches: config.check.each.branches || 0,\n          lines: config.check.each.lines || 0,\n          functions: config.check.each.functions || 0,\n          excludes: config.check.each.excludes || []\n        }\n      },\n      globalResults = removeFiles(coverageMap, root, thresholds.global.excludes),\n      eachResults = removeFiles(coverageMap, root, thresholds.each.excludes),\n      finalError;\n    if (config.verbose) {\n      console.error('Compare actuals against thresholds');\n      console.error(JSON.stringify({\n        global: globalResults,\n        each: eachResults,\n        thresholds: thresholds\n      }, undefined, 4));\n    }\n    check(\"global\", thresholds.global, globalResults.getCoverageSummary());\n    eachResults.files().forEach(function (key) {\n      var summary = eachResults.fileCoverageFor(key).toSummary();\n      check(\"per-file\" + \" (\" + key + \") \", thresholds.each, summary);\n    });\n    finalError = errors.length === 0 ? null : errors.join(\"\\n\");\n    return callback(finalError);\n  };\n  filesFor({\n    root: root,\n    includes: [includePattern]\n  }, function (err, files) {\n    if (err) {\n      return callback(err);\n    }\n    makeMap(files, function (err, map) {\n      if (err) {\n        return callback(err);\n      }\n      return processFiles(map, callback);\n    });\n  });\n}\nmodule.exports = {\n  run: run\n};","map":null,"metadata":{},"sourceType":"script"}