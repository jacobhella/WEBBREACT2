{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nvar _template = require(\"@babel/template\");\nvar _t = require(\"@babel/types\");\nvar NOT_LOCAL_BINDING = _t.NOT_LOCAL_BINDING,\n  cloneNode = _t.cloneNode,\n  identifier = _t.identifier,\n  isAssignmentExpression = _t.isAssignmentExpression,\n  isAssignmentPattern = _t.isAssignmentPattern,\n  isFunction = _t.isFunction,\n  isIdentifier = _t.isIdentifier,\n  isLiteral = _t.isLiteral,\n  isNullLiteral = _t.isNullLiteral,\n  isObjectMethod = _t.isObjectMethod,\n  isObjectProperty = _t.isObjectProperty,\n  isRegExpLiteral = _t.isRegExpLiteral,\n  isRestElement = _t.isRestElement,\n  isTemplateLiteral = _t.isTemplateLiteral,\n  isVariableDeclarator = _t.isVariableDeclarator,\n  toBindingIdentifierName = _t.toBindingIdentifierName;\nfunction getFunctionArity(node) {\n  var count = node.params.findIndex(function (param) {\n    return isAssignmentPattern(param) || isRestElement(param);\n  });\n  return count === -1 ? node.params.length : count;\n}\nvar buildPropertyMethodAssignmentWrapper = _template.default.statement(\"\\n  (function (FUNCTION_KEY) {\\n    function FUNCTION_ID() {\\n      return FUNCTION_KEY.apply(this, arguments);\\n    }\\n\\n    FUNCTION_ID.toString = function () {\\n      return FUNCTION_KEY.toString();\\n    }\\n\\n    return FUNCTION_ID;\\n  })(FUNCTION)\\n\");\nvar buildGeneratorPropertyMethodAssignmentWrapper = _template.default.statement(\"\\n  (function (FUNCTION_KEY) {\\n    function* FUNCTION_ID() {\\n      return yield* FUNCTION_KEY.apply(this, arguments);\\n    }\\n\\n    FUNCTION_ID.toString = function () {\\n      return FUNCTION_KEY.toString();\\n    };\\n\\n    return FUNCTION_ID;\\n  })(FUNCTION)\\n\");\nvar visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\": function ReferencedIdentifierBindingIdentifier(path, state) {\n    if (path.node.name !== state.name) return;\n    var localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n    state.selfReference = true;\n    path.stop();\n  }\n};\nfunction getNameFromLiteralId(id) {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n  if (isRegExpLiteral(id)) {\n    return \"_\".concat(id.pattern, \"_\").concat(id.flags);\n  }\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(function (quasi) {\n      return quasi.value.raw;\n    }).join(\"\");\n  }\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n  return \"\";\n}\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!isFunction(method)) return;\n      var build = buildPropertyMethodAssignmentWrapper;\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n      var template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      var params = template.callee.body.body[0].params;\n      for (var i = 0, len = getFunctionArity(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n      return template;\n    }\n  }\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\nfunction visit(node, name, scope) {\n  var state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    name: name\n  };\n  var binding = scope.getOwnBinding(name);\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n  return state;\n}\nfunction _default(_ref) {\n  var node = _ref.node,\n    parent = _ref.parent,\n    scope = _ref.scope,\n    id = _ref.id;\n  var localBinding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var supportUnicodeId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (node.id) return;\n  if ((isObjectProperty(parent) || isObjectMethod(parent, {\n    kind: \"method\"\n  })) && (!parent.computed || isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (isVariableDeclarator(parent)) {\n    id = parent.id;\n    if (isIdentifier(id) && !localBinding) {\n      var binding = scope.parent.getBinding(id.name);\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = cloneNode(id);\n        node.id[NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (isAssignmentExpression(parent, {\n    operator: \"=\"\n  })) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n  var name;\n  if (id && isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && isIdentifier(id)) {\n    name = id.name;\n  }\n  if (name === undefined) {\n    return;\n  }\n  if (!supportUnicodeId && isFunction(node) && /[\\uD800-\\uDFFF]/.test(name)) {\n    return;\n  }\n  name = toBindingIdentifierName(name);\n  var newId = identifier(name);\n  newId[NOT_LOCAL_BINDING] = true;\n  var state = visit(node, name, scope);\n  return wrap(state, node, newId, scope) || node;\n}","map":null,"metadata":{},"sourceType":"script"}