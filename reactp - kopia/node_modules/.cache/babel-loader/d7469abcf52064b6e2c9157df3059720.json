{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar EventEmitter = require('events').EventEmitter;\nvar fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (e) {\n  // Ignore.\n}\n\n/**\n * Constants\n */\n\nvar CHANGE_EVENT = common.CHANGE_EVENT;\nvar DELETE_EVENT = common.DELETE_EVENT;\nvar ADD_EVENT = common.ADD_EVENT;\nvar ALL_EVENT = common.ALL_EVENT;\n\n/**\n * Export `FSEventsWatcher` class.\n */\n\nmodule.exports = FSEventsWatcher;\n\n/**\n * Watches `dir`.\n *\n * @class FSEventsWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction FSEventsWatcher(dir, opts) {\n  var _this = this;\n  if (!fsevents) {\n    throw new Error('`fsevents` unavailable (this watcher can only be used on Darwin)');\n  }\n  common.assignOptions(this, opts);\n  this.root = path.resolve(dir);\n  this.watcher = fsevents(this.root);\n  this.watcher.start().on('change', this.handleEvent.bind(this));\n  this._tracked = Object.create(null);\n  common.recReaddir(this.root, function (filepath) {\n    return _this._tracked[filepath] = true;\n  }, function (filepath) {\n    return _this._tracked[filepath] = true;\n  }, this.emit.bind(this, 'ready'), this.emit.bind(this, 'error'), this.ignored);\n}\nFSEventsWatcher.prototype.__proto__ = EventEmitter.prototype;\nFSEventsWatcher.prototype.handleEvent = function (filepath) {\n  var relativePath = path.relative(this.root, filepath);\n  if (!common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n    return;\n  }\n  fs.lstat(filepath, function (error, stat) {\n    if (error && error.code !== 'ENOENT') {\n      this.emit('error', error);\n      return;\n    }\n    if (error) {\n      // Ignore files that aren't tracked and don't exist.\n      if (!this._tracked[filepath]) {\n        return;\n      }\n      this._emit(DELETE_EVENT, relativePath);\n      delete this._tracked[filepath];\n      return;\n    }\n    if (this._tracked[filepath]) {\n      this._emit(CHANGE_EVENT, relativePath, stat);\n    } else {\n      this._tracked[filepath] = true;\n      this._emit(ADD_EVENT, relativePath, stat);\n    }\n  }.bind(this));\n};\n\n/**\n * End watching.\n *\n * @public\n */\n\nFSEventsWatcher.prototype.close = function (callback) {\n  this.watcher.stop();\n  this.removeAllListeners();\n  if (typeof callback === 'function') {\n    process.nextTick(callback.bind(null, null, true));\n  }\n};\n\n/**\n * Emit events.\n *\n * @private\n */\n\nFSEventsWatcher.prototype._emit = function (type, file, stat) {\n  this.emit(type, file, this.root, stat);\n  this.emit(ALL_EVENT, type, file, this.root, stat);\n};","map":null,"metadata":{},"sourceType":"script"}