{"ast":null,"code":"/*! https://mths.be/jsesc v1.3.0 by @mathias */\n;\n(function (root) {\n  // Detect free variables `exports`\n  var freeExports = typeof exports == 'object' && exports;\n\n  // Detect free variable `module`\n  var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;\n\n  // Detect free variable `global`, from Node.js or Browserified code,\n  // and use it as `root`\n  var freeGlobal = typeof global == 'object' && global;\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  var object = {};\n  var hasOwnProperty = object.hasOwnProperty;\n  var forOwn = function forOwn(object, callback) {\n    var key;\n    for (key in object) {\n      if (hasOwnProperty.call(object, key)) {\n        callback(key, object[key]);\n      }\n    }\n  };\n  var extend = function extend(destination, source) {\n    if (!source) {\n      return destination;\n    }\n    forOwn(source, function (key, value) {\n      destination[key] = value;\n    });\n    return destination;\n  };\n  var forEach = function forEach(array, callback) {\n    var length = array.length;\n    var index = -1;\n    while (++index < length) {\n      callback(array[index]);\n    }\n  };\n  var toString = object.toString;\n  var isArray = function isArray(value) {\n    return toString.call(value) == '[object Array]';\n  };\n  var isObject = function isObject(value) {\n    // This is a very simple check, but it’s good enough for what we need.\n    return toString.call(value) == '[object Object]';\n  };\n  var isString = function isString(value) {\n    return typeof value == 'string' || toString.call(value) == '[object String]';\n  };\n  var isNumber = function isNumber(value) {\n    return typeof value == 'number' || toString.call(value) == '[object Number]';\n  };\n  var isFunction = function isFunction(value) {\n    // In a perfect world, the `typeof` check would be sufficient. However,\n    // in Chrome 1–12, `typeof /x/ == 'object'`, and in IE 6–8\n    // `typeof alert == 'object'` and similar for other host objects.\n    return typeof value == 'function' || toString.call(value) == '[object Function]';\n  };\n  var isMap = function isMap(value) {\n    return toString.call(value) == '[object Map]';\n  };\n  var isSet = function isSet(value) {\n    return toString.call(value) == '[object Set]';\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  // https://mathiasbynens.be/notes/javascript-escapes#single\n  var singleEscapes = {\n    '\"': '\\\\\"',\n    '\\'': '\\\\\\'',\n    '\\\\': '\\\\\\\\',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t'\n    // `\\v` is omitted intentionally, because in IE < 9, '\\v' == 'v'.\n    // '\\v': '\\\\x0B'\n  };\n\n  var regexSingleEscape = /[\"'\\\\\\b\\f\\n\\r\\t]/;\n  var regexDigit = /[0-9]/;\n  var regexWhitelist = /[ !#-&\\(-\\[\\]-~]/;\n  var jsesc = function jsesc(argument, options) {\n    // Handle options\n    var defaults = {\n      'escapeEverything': false,\n      'escapeEtago': false,\n      'quotes': 'single',\n      'wrap': false,\n      'es6': false,\n      'json': false,\n      'compact': true,\n      'lowercaseHex': false,\n      'numbers': 'decimal',\n      'indent': '\\t',\n      '__indent__': '',\n      '__inline1__': false,\n      '__inline2__': false\n    };\n    var json = options && options.json;\n    if (json) {\n      defaults.quotes = 'double';\n      defaults.wrap = true;\n    }\n    options = extend(defaults, options);\n    if (options.quotes != 'single' && options.quotes != 'double') {\n      options.quotes = 'single';\n    }\n    var quote = options.quotes == 'double' ? '\"' : '\\'';\n    var compact = options.compact;\n    var indent = options.indent;\n    var lowercaseHex = options.lowercaseHex;\n    var oldIndent = '';\n    var inline1 = options.__inline1__;\n    var inline2 = options.__inline2__;\n    var newLine = compact ? '' : '\\n';\n    var result;\n    var isEmpty = true;\n    var useBinNumbers = options.numbers == 'binary';\n    var useOctNumbers = options.numbers == 'octal';\n    var useDecNumbers = options.numbers == 'decimal';\n    var useHexNumbers = options.numbers == 'hexadecimal';\n    if (json && argument && isFunction(argument.toJSON)) {\n      argument = argument.toJSON();\n    }\n    if (!isString(argument)) {\n      if (isMap(argument)) {\n        if (argument.size == 0) {\n          return 'new Map()';\n        }\n        if (!compact) {\n          options.__inline1__ = true;\n        }\n        return 'new Map(' + jsesc(Array.from(argument), options) + ')';\n      }\n      if (isSet(argument)) {\n        if (argument.size == 0) {\n          return 'new Set()';\n        }\n        return 'new Set(' + jsesc(Array.from(argument), options) + ')';\n      }\n      if (isArray(argument)) {\n        result = [];\n        options.wrap = true;\n        if (inline1) {\n          options.__inline1__ = false;\n          options.__inline2__ = true;\n        } else {\n          oldIndent = options.__indent__;\n          indent += oldIndent;\n          options.__indent__ = indent;\n        }\n        forEach(argument, function (value) {\n          isEmpty = false;\n          if (inline2) {\n            options.__inline2__ = false;\n          }\n          result.push((compact || inline2 ? '' : indent) + jsesc(value, options));\n        });\n        if (isEmpty) {\n          return '[]';\n        }\n        if (inline2) {\n          return '[' + result.join(', ') + ']';\n        }\n        return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';\n      } else if (isNumber(argument)) {\n        if (json) {\n          // Some number values (e.g. `Infinity`) cannot be represented in JSON.\n          return JSON.stringify(argument);\n        }\n        if (useDecNumbers) {\n          return String(argument);\n        }\n        if (useHexNumbers) {\n          var tmp = argument.toString(16);\n          if (!lowercaseHex) {\n            tmp = tmp.toUpperCase();\n          }\n          return '0x' + tmp;\n        }\n        if (useBinNumbers) {\n          return '0b' + argument.toString(2);\n        }\n        if (useOctNumbers) {\n          return '0o' + argument.toString(8);\n        }\n      } else if (!isObject(argument)) {\n        if (json) {\n          // For some values (e.g. `undefined`, `function` objects),\n          // `JSON.stringify(value)` returns `undefined` (which isn’t valid\n          // JSON) instead of `'null'`.\n          return JSON.stringify(argument) || 'null';\n        }\n        return String(argument);\n      } else {\n        // it’s an object\n        result = [];\n        options.wrap = true;\n        oldIndent = options.__indent__;\n        indent += oldIndent;\n        options.__indent__ = indent;\n        forOwn(argument, function (key, value) {\n          isEmpty = false;\n          result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));\n        });\n        if (isEmpty) {\n          return '{}';\n        }\n        return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';\n      }\n    }\n    var string = argument;\n    // Loop over each code unit in the string and escape it\n    var index = -1;\n    var length = string.length;\n    var first;\n    var second;\n    var codePoint;\n    result = '';\n    while (++index < length) {\n      var character = string.charAt(index);\n      if (options.es6) {\n        first = string.charCodeAt(index);\n        if (\n        // check if it’s the start of a surrogate pair\n        first >= 0xD800 && first <= 0xDBFF &&\n        // high surrogate\n        length > index + 1 // there is a next code unit\n        ) {\n          second = string.charCodeAt(index + 1);\n          if (second >= 0xDC00 && second <= 0xDFFF) {\n            // low surrogate\n            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n            var hexadecimal = codePoint.toString(16);\n            if (!lowercaseHex) {\n              hexadecimal = hexadecimal.toUpperCase();\n            }\n            result += \"\\\\u{\" + hexadecimal + '}';\n            index++;\n            continue;\n          }\n        }\n      }\n      if (!options.escapeEverything) {\n        if (regexWhitelist.test(character)) {\n          // It’s a printable ASCII character that is not `\"`, `'` or `\\`,\n          // so don’t escape it.\n          result += character;\n          continue;\n        }\n        if (character == '\"') {\n          result += quote == character ? '\\\\\"' : character;\n          continue;\n        }\n        if (character == '\\'') {\n          result += quote == character ? '\\\\\\'' : character;\n          continue;\n        }\n      }\n      if (character == '\\0' && !json && !regexDigit.test(string.charAt(index + 1))) {\n        result += '\\\\0';\n        continue;\n      }\n      if (regexSingleEscape.test(character)) {\n        // no need for a `hasOwnProperty` check here\n        result += singleEscapes[character];\n        continue;\n      }\n      var charCode = character.charCodeAt(0);\n      var hexadecimal = charCode.toString(16);\n      if (!lowercaseHex) {\n        hexadecimal = hexadecimal.toUpperCase();\n      }\n      var longhand = hexadecimal.length > 2 || json;\n      var escaped = '\\\\' + (longhand ? 'u' : 'x') + ('0000' + hexadecimal).slice(longhand ? -4 : -2);\n      result += escaped;\n      continue;\n    }\n    if (options.wrap) {\n      result = quote + result + quote;\n    }\n    if (options.escapeEtago) {\n      // https://mathiasbynens.be/notes/etago\n      return result.replace(/<\\/(script|style)/gi, '<\\\\/$1');\n    }\n    return result;\n  };\n  jsesc.version = '1.3.0';\n\n  /*--------------------------------------------------------------------------*/\n\n  // Some AMD build optimizers, like r.js, check for specific condition patterns\n  // like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    define(function () {\n      return jsesc;\n    });\n  } else if (freeExports && !freeExports.nodeType) {\n    if (freeModule) {\n      // in Node.js or RingoJS v0.8.0+\n      freeModule.exports = jsesc;\n    } else {\n      // in Narwhal or RingoJS v0.7.0-\n      freeExports.jsesc = jsesc;\n    }\n  } else {\n    // in Rhino or a web browser\n    root.jsesc = jsesc;\n  }\n})(this);","map":null,"metadata":{},"sourceType":"script"}