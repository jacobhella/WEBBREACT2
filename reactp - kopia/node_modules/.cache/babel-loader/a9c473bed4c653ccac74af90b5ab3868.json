{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = collectHandles;\nexports.formatHandleErrors = formatHandleErrors;\nvar _jestMessageUtil;\nfunction _load_jestMessageUtil() {\n  return _jestMessageUtil = require('jest-message-util');\n}\nvar _stripAnsi;\nfunction _load_stripAnsi() {\n  return _stripAnsi = _interopRequireDefault(require('strip-ansi'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction stackIsFromUser(stack) {\n  // Either the test file, or something required by it\n  if (stack.includes('Runtime.requireModule')) {\n    return true;\n  }\n\n  // jest-jasmine it or describe call\n  if (stack.includes('asyncJestTest') || stack.includes('asyncJestLifecycle')) {\n    return true;\n  }\n\n  // An async function call from within circus\n  if (stack.includes('callAsyncCircusFn')) {\n    // jest-circus it or describe call\n    return stack.includes('_callCircusTest') || stack.includes('_callCircusHook');\n  }\n  return false;\n}\n\n// Inspired by https://github.com/mafintosh/why-is-node-running/blob/master/index.js\n// Extracted as we want to format the result ourselves\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nfunction collectHandles() {\n  var activeHandles = new Map();\n  function initHook(asyncId, type) {\n    if (type === 'PROMISE' || type === 'TIMERWRAP') {\n      return;\n    }\n    var error = new Error(type);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, initHook);\n    }\n    if (stackIsFromUser(error.stack)) {\n      activeHandles.set(asyncId, error);\n    }\n  }\n  var hook;\n  try {\n    // $FlowFixMe: Node core module\n    var asyncHooks = require('async_hooks');\n    hook = asyncHooks.createHook({\n      destroy: function destroy(asyncId) {\n        activeHandles.delete(asyncId);\n      },\n      init: initHook\n    });\n    hook.enable();\n  } catch (e) {\n    var nodeMajor = Number(process.versions.node.split('.')[0]);\n    if (e.code === 'MODULE_NOT_FOUND' && nodeMajor < 8) {\n      throw new Error('You can only use --detectOpenHandles on Node 8 and newer.');\n    } else {\n      throw e;\n    }\n  }\n  return function () {\n    hook.disable();\n    var result = Array.from(activeHandles.values());\n    activeHandles.clear();\n    return result;\n  };\n}\nfunction formatHandleErrors(errors, config) {\n  var stacks = new Set();\n  return errors.map(function (err) {\n    return (0, (_jestMessageUtil || _load_jestMessageUtil()).formatExecError)(err, config, {\n      noStackTrace: false\n    }, undefined, true);\n  })\n  // E.g. timeouts might give multiple traces to the same line of code\n  // This hairy filtering tries to remove entries with duplicate stack traces\n  .filter(function (handle) {\n    var ansiFree = (0, (_stripAnsi || _load_stripAnsi()).default)(handle);\n    var match = ansiFree.match(/\\s+at(.*)/);\n    if (!match || match.length < 2) {\n      return true;\n    }\n    var stack = ansiFree.substr(ansiFree.indexOf(match[1])).trim();\n    if (stacks.has(stack)) {\n      return false;\n    }\n    stacks.add(stack);\n    return true;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}