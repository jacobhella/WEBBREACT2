{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.FunctionDeclaration = undefined;\nexports._params = _params;\nexports._method = _method;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nvar _babelTypes = require(\"babel-types\");\nvar t = _interopRequireWildcard(_babelTypes);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _params(node) {\n  var _this = this;\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n  this.printList(node.params, node, {\n    iterator: function iterator(node) {\n      if (node.optional) _this.token(\"?\");\n      _this.print(node.typeAnnotation, node);\n    }\n  });\n  this.token(\")\");\n  if (node.returnType) {\n    this.print(node.returnType, node);\n  }\n}\nfunction _method(node) {\n  var kind = node.kind;\n  var key = node.key;\n  if (kind === \"method\" || kind === \"init\") {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key, node);\n    this.token(\"]\");\n  } else {\n    this.print(key, node);\n  }\n  this._params(node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction FunctionExpression(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) this.token(\"*\");\n  if (node.id) {\n    this.space();\n    this.print(node.id, node);\n  } else {\n    this.space();\n  }\n  this._params(node);\n  this.space();\n  this.print(node.body, node);\n}\nexports.FunctionDeclaration = FunctionExpression;\nfunction ArrowFunctionExpression(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n  var firstParam = node.params[0];\n  if (node.params.length === 1 && t.isIdentifier(firstParam) && !hasTypes(node, firstParam)) {\n    this.print(firstParam, node);\n  } else {\n    this._params(node);\n  }\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.body, node);\n}\nfunction hasTypes(node, param) {\n  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;\n}","map":null,"metadata":{},"sourceType":"script"}