{"ast":null,"code":"'use strict';\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = undefined;\nvar _fs = require('fs');\nvar _fs2 = _interopRequireDefault(_fs);\nvar _path = require('path');\nvar _path2 = _interopRequireDefault(_path);\nvar _chalk = require('chalk');\nvar _chalk2 = _interopRequireDefault(_chalk);\nvar _micromatch = require('micromatch');\nvar _micromatch2 = _interopRequireDefault(_micromatch);\nvar _slash = require('slash');\nvar _slash2 = _interopRequireDefault(_slash);\nvar _codeFrame = require('@babel/code-frame');\nvar _stackUtils = require('stack-utils');\nvar _stackUtils2 = _interopRequireDefault(_stackUtils);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n// stack utils tries to create pretty stack by making paths relative.\nvar stackUtils = new _stackUtils2.default({\n  cwd: 'something which does not exist'\n});\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar nodeInternals = [];\ntry {\n  nodeInternals = _stackUtils2.default.nodeInternals()\n  // this is to have the tests be the same in node 4 and node 6.\n  // TODO: Remove when we drop support for node 4\n  .concat(new RegExp('internal/process/next_tick.js'));\n} catch (e) {\n  // `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\nvar PATH_NODE_MODULES = \"\".concat(_path2.default.sep, \"node_modules\").concat(_path2.default.sep);\nvar PATH_JEST_PACKAGES = \"\".concat(_path2.default.sep, \"jest\").concat(_path2.default.sep, \"packages\").concat(_path2.default.sep);\n\n// filter for noisy stack trace lines\nvar JASMINE_IGNORE = /^\\s+at(?:(?:.jasmine\\-)|\\s+jasmine\\.buildExpectationResult)/;\nvar JEST_INTERNALS_IGNORE = /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nvar ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nvar ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nvar ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nvar NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nvar TITLE_INDENT = '  ';\nvar MESSAGE_INDENT = '    ';\nvar STACK_INDENT = '      ';\nvar ANCESTRY_SEPARATOR = \" \\u203A \";\nvar TITLE_BULLET = _chalk2.default.bold(\"\\u25CF \");\nvar STACK_TRACE_COLOR = _chalk2.default.dim;\nvar STACK_PATH_REGEXP = /\\s*at.*\\(?(\\:\\d*\\:\\d*|native)\\)?/;\nvar EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nvar ERROR_TEXT = 'Error: ';\nvar indentAllLines = function indentAllLines(lines, indent) {\n  return lines.split('\\n').map(function (line) {\n    return line ? indent + line : line;\n  }).join('\\n');\n};\nvar trim = function trim(string) {\n  return (string || '').trim();\n};\n\n// Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\nvar trimPaths = function trimPaths(string) {\n  return string.match(STACK_PATH_REGEXP) ? trim(string) : string;\n};\nvar getRenderedCallsite = function getRenderedCallsite(fileContent, line, column) {\n  var renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, {\n    start: {\n      column: column,\n      line: line\n    }\n  }, {\n    highlightCode: true\n  });\n  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);\n  renderedCallsite = \"\\n\".concat(renderedCallsite, \"\\n\");\n  return renderedCallsite;\n};\n\n// ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\nvar formatExecError = exports.formatExecError = function (error, config, options, testPath, reuseMessage) {\n  if (!error || typeof error === 'number') {\n    error = new Error(\"Expected an Error, but \\\"\".concat(String(error), \"\\\" was thrown\"));\n    error.stack = '';\n  }\n  var message, stack;\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack = error.stack;\n  }\n  var separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n  if (separated.message.indexOf(trim(message)) !== -1) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n  message = indentAllLines(message, MESSAGE_INDENT);\n  stack = stack && !options.noStackTrace ? '\\n' + formatStackTrace(stack, config, options, testPath) : '';\n  if (message.match(/^\\s*$/) && stack.match(/^\\s*$/)) {\n    // this can happen if an empty object is thrown.\n    message = MESSAGE_INDENT + 'Error: No message was provided';\n  }\n  var messageToUse;\n  if (reuseMessage) {\n    messageToUse = \" \".concat(message.trim());\n  } else {\n    messageToUse = \"\".concat(EXEC_ERROR_MESSAGE, \"\\n\\n\").concat(message);\n  }\n  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\\n';\n};\nvar removeInternalStackEntries = function removeInternalStackEntries(lines, options) {\n  var pathCounter = 0;\n  return lines.filter(function (line) {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n    if (nodeInternals.some(function (internal) {\n      return internal.test(line);\n    })) {\n      return false;\n    }\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n    return true;\n  });\n};\nvar formatPaths = function formatPaths(config, relativeTestPath, line) {\n  // Extract the file path from the trace line.\n  var match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n  if (!match) {\n    return line;\n  }\n  var filePath = (0, _slash2.default)(_path2.default.relative(config.rootDir, match[2]));\n  // highlight paths from the current test file\n  if (config.testMatch && config.testMatch.length && (0, _micromatch2.default)(filePath, config.testMatch) || filePath === relativeTestPath) {\n    filePath = _chalk2.default.reset.cyan(filePath);\n  }\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\nvar getStackTraceLines = exports.getStackTraceLines = function (stack) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    noStackTrace: false\n  };\n  return removeInternalStackEntries(stack.split(/\\n/), options);\n};\nvar getTopFrame = exports.getTopFrame = function (lines) {\n  var _iterator = _createForOfIteratorHelper(lines),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var line = _step.value;\n      if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n        continue;\n      }\n      var parsedFrame = stackUtils.parseLine(line.trim());\n      if (parsedFrame && parsedFrame.file) {\n        return parsedFrame;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return null;\n};\nvar formatStackTrace = exports.formatStackTrace = function (stack, config, options, testPath) {\n  var lines = getStackTraceLines(stack, options);\n  var topFrame = getTopFrame(lines);\n  var renderedCallsite = '';\n  var relativeTestPath = testPath ? (0, _slash2.default)(_path2.default.relative(config.rootDir, testPath)) : null;\n  if (topFrame) {\n    var filename = topFrame.file;\n    if (_path2.default.isAbsolute(filename)) {\n      var fileContent;\n      try {\n        // TODO: check & read HasteFS instead of reading the filesystem:\n        // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n        fileContent = _fs2.default.readFileSync(filename, 'utf8');\n        renderedCallsite = getRenderedCallsite(fileContent, topFrame.line, topFrame.column);\n      } catch (e) {\n        // the file does not exist or is inaccessible, we ignore\n      }\n    }\n  }\n  var stacktrace = lines.filter(Boolean).map(function (line) {\n    return STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line));\n  }).join('\\n');\n  return \"\".concat(renderedCallsite, \"\\n\").concat(stacktrace);\n};\nvar formatResultsErrors = exports.formatResultsErrors = function (testResults, config, options, testPath) {\n  var failedResults = testResults.reduce(function (errors, result) {\n    result.failureMessages.forEach(function (content) {\n      return errors.push({\n        content: content,\n        result: result\n      });\n    });\n    return errors;\n  }, []);\n  if (!failedResults.length) {\n    return null;\n  }\n  return failedResults.map(function (_ref) {\n    var result = _ref.result,\n      content = _ref.content;\n    var _separateMessageFromS = separateMessageFromStack(content);\n    var message = _separateMessageFromS.message,\n      stack = _separateMessageFromS.stack;\n    stack = options.noStackTrace ? '' : STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath)) + '\\n';\n    message = indentAllLines(message, MESSAGE_INDENT);\n    var title = _chalk2.default.bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') + result.title) + '\\n';\n    return title + '\\n' + message + '\\n' + stack;\n  }).join('\\n');\n};\n\n// jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\nvar separateMessageFromStack = exports.separateMessageFromStack = function (content) {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  }\n  var messageMatch = content.match(/(^(.|\\n)*?(?=\\n\\s*at\\s.*\\:\\d*\\:\\d*))/);\n  var message = messageMatch ? messageMatch[0] : 'Error';\n  var stack = messageMatch ? content.slice(message.length) : content;\n  // If the error is a plain error instead of a SyntaxError or TypeError\n  // we remove it from the message because it is generally not useful.\n  if (message.startsWith(ERROR_TEXT)) {\n    message = message.substr(ERROR_TEXT.length);\n  }\n  return {\n    message: message,\n    stack: stack\n  };\n};","map":null,"metadata":{},"sourceType":"script"}