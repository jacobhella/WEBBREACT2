{"ast":null,"code":"'use strict';\n\n// this file handles outputting usage instructions,\n// failures, etc. keeps logging in one place.\nvar stringWidth = require('string-width');\nvar objFilter = require('./obj-filter');\nvar path = require('path');\nvar setBlocking = require('set-blocking');\nvar YError = require('./yerror');\nmodule.exports = function usage(yargs, y18n) {\n  var __ = y18n.__;\n  var self = {};\n\n  // methods for ouputting/building failure message.\n  var fails = [];\n  self.failFn = function failFn(f) {\n    fails.push(f);\n  };\n  var failMessage = null;\n  var showHelpOnFail = true;\n  self.showHelpOnFail = function showHelpOnFailFn(enabled, message) {\n    if (typeof enabled === 'string') {\n      message = enabled;\n      enabled = true;\n    } else if (typeof enabled === 'undefined') {\n      enabled = true;\n    }\n    failMessage = message;\n    showHelpOnFail = enabled;\n    return self;\n  };\n  var failureOutput = false;\n  self.fail = function fail(msg, err) {\n    var logger = yargs._getLoggerInstance();\n    if (fails.length) {\n      for (var i = fails.length - 1; i >= 0; --i) {\n        fails[i](msg, err, self);\n      }\n    } else {\n      if (yargs.getExitProcess()) setBlocking(true);\n\n      // don't output failure message more than once\n      if (!failureOutput) {\n        failureOutput = true;\n        if (showHelpOnFail) yargs.showHelp('error');\n        if (msg || err) logger.error(msg || err);\n        if (failMessage) {\n          if (msg || err) logger.error('');\n          logger.error(failMessage);\n        }\n      }\n      err = err || new YError(msg);\n      if (yargs.getExitProcess()) {\n        return yargs.exit(1);\n      } else if (yargs._hasParseCallback()) {\n        return yargs.exit(1, err);\n      } else {\n        throw err;\n      }\n    }\n  };\n\n  // methods for ouputting/building help (usage) message.\n  var usages = [];\n  var usageDisabled = false;\n  self.usage = function (msg, description) {\n    if (msg === null) {\n      usageDisabled = true;\n      usages = [];\n      return;\n    }\n    usageDisabled = false;\n    usages.push([msg, description || '']);\n    return self;\n  };\n  self.getUsage = function () {\n    return usages;\n  };\n  self.getUsageDisabled = function () {\n    return usageDisabled;\n  };\n  self.getPositionalGroupName = function () {\n    return __('Positionals:');\n  };\n  var examples = [];\n  self.example = function (cmd, description) {\n    examples.push([cmd, description || '']);\n  };\n  var commands = [];\n  self.command = function command(cmd, description, isDefault, aliases) {\n    // the last default wins, so cancel out any previously set default\n    if (isDefault) {\n      commands = commands.map(function (cmdArray) {\n        cmdArray[2] = false;\n        return cmdArray;\n      });\n    }\n    commands.push([cmd, description || '', isDefault, aliases]);\n  };\n  self.getCommands = function () {\n    return commands;\n  };\n  var descriptions = {};\n  self.describe = function describe(key, desc) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.describe(k, key[k]);\n      });\n    } else {\n      descriptions[key] = desc;\n    }\n  };\n  self.getDescriptions = function () {\n    return descriptions;\n  };\n  var epilog;\n  self.epilog = function (msg) {\n    epilog = msg;\n  };\n  var wrapSet = false;\n  var wrap;\n  self.wrap = function (cols) {\n    wrapSet = true;\n    wrap = cols;\n  };\n  function getWrap() {\n    if (!wrapSet) {\n      wrap = windowWidth();\n      wrapSet = true;\n    }\n    return wrap;\n  }\n  var deferY18nLookupPrefix = '__yargsString__:';\n  self.deferY18nLookup = function (str) {\n    return deferY18nLookupPrefix + str;\n  };\n  var defaultGroup = 'Options:';\n  self.help = function help() {\n    normalizeAliases();\n\n    // handle old demanded API\n    var base$0 = path.basename(yargs.$0);\n    var demandedOptions = yargs.getDemandedOptions();\n    var demandedCommands = yargs.getDemandedCommands();\n    var groups = yargs.getGroups();\n    var options = yargs.getOptions();\n    var keys = Object.keys(Object.keys(descriptions).concat(Object.keys(demandedOptions)).concat(Object.keys(demandedCommands)).concat(Object.keys(options.default)).reduce(function (acc, key) {\n      if (key !== '_') acc[key] = true;\n      return acc;\n    }, {}));\n    var theWrap = getWrap();\n    var ui = require('cliui')({\n      width: theWrap,\n      wrap: !!theWrap\n    });\n\n    // the usage string.\n    if (!usageDisabled) {\n      if (usages.length) {\n        // user-defined usage.\n        usages.forEach(function (usage) {\n          ui.div(\"\".concat(usage[0].replace(/\\$0/g, base$0)));\n          if (usage[1]) {\n            ui.div({\n              text: \"\".concat(usage[1]),\n              padding: [1, 0, 0, 0]\n            });\n          }\n        });\n        ui.div();\n      } else if (commands.length) {\n        var u = null;\n        // demonstrate how commands are used.\n        if (demandedCommands._) {\n          u = \"\".concat(base$0, \" <\").concat(__('command'), \">\\n\");\n        } else {\n          u = \"\".concat(base$0, \" [\").concat(__('command'), \"]\\n\");\n        }\n        ui.div(\"\".concat(u));\n      }\n    }\n\n    // your application's commands, i.e., non-option\n    // arguments populated in '_'.\n    if (commands.length) {\n      ui.div(__('Commands:'));\n      var context = yargs.getContext();\n      var parentCommands = context.commands.length ? \"\".concat(context.commands.join(' '), \" \") : '';\n      commands.forEach(function (command) {\n        var commandString = \"\".concat(base$0, \" \").concat(parentCommands).concat(command[0].replace(/^\\$0 ?/, '')); // drop $0 from default commands.\n        ui.span({\n          text: commandString,\n          padding: [0, 2, 0, 2],\n          width: maxWidth(commands, theWrap, \"\".concat(base$0).concat(parentCommands)) + 4\n        }, {\n          text: command[1]\n        });\n        var hints = [];\n        if (command[2]) hints.push(\"[\".concat(__('default:').slice(0, -1), \"]\")); // TODO hacking around i18n here\n        if (command[3] && command[3].length) {\n          hints.push(\"[\".concat(__('aliases:'), \" \").concat(command[3].join(', '), \"]\"));\n        }\n        if (hints.length) {\n          ui.div({\n            text: hints.join(' '),\n            padding: [0, 0, 0, 2],\n            align: 'right'\n          });\n        } else {\n          ui.div();\n        }\n      });\n      ui.div();\n    }\n\n    // perform some cleanup on the keys array, making it\n    // only include top-level keys not their aliases.\n    var aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);\n    keys = keys.filter(function (key) {\n      return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {\n        return (options.alias[alias] || []).indexOf(key) === -1;\n      });\n    });\n\n    // populate 'Options:' group with any keys that have not\n    // explicitly had a group set.\n    if (!groups[defaultGroup]) groups[defaultGroup] = [];\n    addUngroupedKeys(keys, options.alias, groups);\n\n    // display 'Options:' table along with any custom tables:\n    Object.keys(groups).forEach(function (groupName) {\n      if (!groups[groupName].length) return;\n      ui.div(__(groupName));\n\n      // if we've grouped the key 'f', but 'f' aliases 'foobar',\n      // normalizedKeys should contain only 'foobar'.\n      var normalizedKeys = groups[groupName].map(function (key) {\n        if (~aliasKeys.indexOf(key)) return key;\n        for (var i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey;\n        }\n        return key;\n      });\n\n      // actually generate the switches string --foo, -f, --bar.\n      var switches = normalizedKeys.reduce(function (acc, key) {\n        acc[key] = [key].concat(options.alias[key] || []).map(function (sw) {\n          // for the special positional group don't\n          // add '--' or '-' prefix.\n          if (groupName === self.getPositionalGroupName()) return sw;else return (sw.length > 1 ? '--' : '-') + sw;\n        }).join(', ');\n        return acc;\n      }, {});\n      normalizedKeys.forEach(function (key) {\n        var kswitch = switches[key];\n        var desc = descriptions[key] || '';\n        var type = null;\n        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));\n        if (~options.boolean.indexOf(key)) type = \"[\".concat(__('boolean'), \"]\");\n        if (~options.count.indexOf(key)) type = \"[\".concat(__('count'), \"]\");\n        if (~options.string.indexOf(key)) type = \"[\".concat(__('string'), \"]\");\n        if (~options.normalize.indexOf(key)) type = \"[\".concat(__('string'), \"]\");\n        if (~options.array.indexOf(key)) type = \"[\".concat(__('array'), \"]\");\n        if (~options.number.indexOf(key)) type = \"[\".concat(__('number'), \"]\");\n        var extra = [type, key in demandedOptions ? \"[\".concat(__('required'), \"]\") : null, options.choices && options.choices[key] ? \"[\".concat(__('choices:'), \" \").concat(self.stringifiedValues(options.choices[key]), \"]\") : null, defaultString(options.default[key], options.defaultDescription[key])].filter(Boolean).join(' ');\n        ui.span({\n          text: kswitch,\n          padding: [0, 2, 0, 2],\n          width: maxWidth(switches, theWrap) + 4\n        }, desc);\n        if (extra) ui.div({\n          text: extra,\n          padding: [0, 0, 0, 2],\n          align: 'right'\n        });else ui.div();\n      });\n      ui.div();\n    });\n\n    // describe some common use-cases for your application.\n    if (examples.length) {\n      ui.div(__('Examples:'));\n      examples.forEach(function (example) {\n        example[0] = example[0].replace(/\\$0/g, base$0);\n      });\n      examples.forEach(function (example) {\n        if (example[1] === '') {\n          ui.div({\n            text: example[0],\n            padding: [0, 2, 0, 2]\n          });\n        } else {\n          ui.div({\n            text: example[0],\n            padding: [0, 2, 0, 2],\n            width: maxWidth(examples, theWrap) + 4\n          }, {\n            text: example[1]\n          });\n        }\n      });\n      ui.div();\n    }\n\n    // the usage string.\n    if (epilog) {\n      var e = epilog.replace(/\\$0/g, base$0);\n      ui.div(\"\".concat(e, \"\\n\"));\n    }\n    return ui.toString();\n  };\n\n  // return the maximum width of a string\n  // in the left-hand column of a table.\n  function maxWidth(table, theWrap, modifier) {\n    var width = 0;\n\n    // table might be of the form [leftColumn],\n    // or {key: leftColumn}\n    if (!Array.isArray(table)) {\n      table = Object.keys(table).map(function (key) {\n        return [table[key]];\n      });\n    }\n    table.forEach(function (v) {\n      width = Math.max(stringWidth(modifier ? \"\".concat(modifier, \" \").concat(v[0]) : v[0]), width);\n    });\n\n    // if we've enabled 'wrap' we should limit\n    // the max-width of the left-column.\n    if (theWrap) width = Math.min(width, parseInt(theWrap * 0.5, 10));\n    return width;\n  }\n\n  // make sure any options set for aliases,\n  // are copied to the keys being aliased.\n  function normalizeAliases() {\n    // handle old demanded API\n    var demandedOptions = yargs.getDemandedOptions();\n    var options = yargs.getOptions();\n    (Object.keys(options.alias) || []).forEach(function (key) {\n      options.alias[key].forEach(function (alias) {\n        // copy descriptions.\n        if (descriptions[alias]) self.describe(key, descriptions[alias]);\n        // copy demanded.\n        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]);\n        // type messages.\n        if (~options.boolean.indexOf(alias)) yargs.boolean(key);\n        if (~options.count.indexOf(alias)) yargs.count(key);\n        if (~options.string.indexOf(alias)) yargs.string(key);\n        if (~options.normalize.indexOf(alias)) yargs.normalize(key);\n        if (~options.array.indexOf(alias)) yargs.array(key);\n        if (~options.number.indexOf(alias)) yargs.number(key);\n      });\n    });\n  }\n\n  // given a set of keys, place any keys that are\n  // ungrouped under the 'Options:' grouping.\n  function addUngroupedKeys(keys, aliases, groups) {\n    var groupedKeys = [];\n    var toCheck = null;\n    Object.keys(groups).forEach(function (group) {\n      groupedKeys = groupedKeys.concat(groups[group]);\n    });\n    keys.forEach(function (key) {\n      toCheck = [key].concat(aliases[key]);\n      if (!toCheck.some(function (k) {\n        return groupedKeys.indexOf(k) !== -1;\n      })) {\n        groups[defaultGroup].push(key);\n      }\n    });\n    return groupedKeys;\n  }\n  self.showHelp = function (level) {\n    var logger = yargs._getLoggerInstance();\n    if (!level) level = 'error';\n    var emit = typeof level === 'function' ? level : logger[level];\n    emit(self.help());\n  };\n  self.functionDescription = function (fn) {\n    var description = fn.name ? require('decamelize')(fn.name, '-') : __('generated-value');\n    return ['(', description, ')'].join('');\n  };\n  self.stringifiedValues = function stringifiedValues(values, separator) {\n    var string = '';\n    var sep = separator || ', ';\n    var array = [].concat(values);\n    if (!values || !array.length) return string;\n    array.forEach(function (value) {\n      if (string.length) string += sep;\n      string += JSON.stringify(value);\n    });\n    return string;\n  };\n\n  // format the default-value-string displayed in\n  // the right-hand column.\n  function defaultString(value, defaultDescription) {\n    var string = \"[\".concat(__('default:'), \" \");\n    if (value === undefined && !defaultDescription) return null;\n    if (defaultDescription) {\n      string += defaultDescription;\n    } else {\n      switch (typeof value) {\n        case 'string':\n          string += \"\\\"\".concat(value, \"\\\"\");\n          break;\n        case 'object':\n          string += JSON.stringify(value);\n          break;\n        default:\n          string += value;\n      }\n    }\n    return \"\".concat(string, \"]\");\n  }\n\n  // guess the width of the console window, max-width 80.\n  function windowWidth() {\n    var maxWidth = 80;\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n      return Math.min(maxWidth, process.stdout.columns);\n    } else {\n      return maxWidth;\n    }\n  }\n\n  // logic for displaying application version.\n  var version = null;\n  self.version = function (ver) {\n    version = ver;\n  };\n  self.showVersion = function () {\n    var logger = yargs._getLoggerInstance();\n    logger.log(version);\n  };\n  self.reset = function reset(localLookup) {\n    // do not reset wrap here\n    // do not reset fails here\n    failMessage = null;\n    failureOutput = false;\n    usages = [];\n    usageDisabled = false;\n    epilog = undefined;\n    examples = [];\n    commands = [];\n    descriptions = objFilter(descriptions, function (k, v) {\n      return !localLookup[k];\n    });\n    return self;\n  };\n  var frozen;\n  self.freeze = function freeze() {\n    frozen = {};\n    frozen.failMessage = failMessage;\n    frozen.failureOutput = failureOutput;\n    frozen.usages = usages;\n    frozen.usageDisabled = usageDisabled;\n    frozen.epilog = epilog;\n    frozen.examples = examples;\n    frozen.commands = commands;\n    frozen.descriptions = descriptions;\n  };\n  self.unfreeze = function unfreeze() {\n    failMessage = frozen.failMessage;\n    failureOutput = frozen.failureOutput;\n    usages = frozen.usages;\n    usageDisabled = frozen.usageDisabled;\n    epilog = frozen.epilog;\n    examples = frozen.examples;\n    commands = frozen.commands;\n    descriptions = frozen.descriptions;\n    frozen = undefined;\n  };\n  return self;\n};","map":null,"metadata":{},"sourceType":"script"}