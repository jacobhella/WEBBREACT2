{"ast":null,"code":"'use strict';\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = function (j$) {\n  function Env(options) {\n    options = options || {};\n    var self = this;\n    var totalSpecsDefined = 0;\n    var catchExceptions = true;\n    var realSetTimeout = global.setTimeout;\n    var realClearTimeout = global.clearTimeout;\n    var runnableResources = {};\n    var currentSpec = null;\n    var currentlyExecutingSuites = [];\n    var currentDeclarationSuite = null;\n    var throwOnExpectationFailure = false;\n    var random = false;\n    var seed = null;\n    var currentSuite = function currentSuite() {\n      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n    };\n    var currentRunnable = function currentRunnable() {\n      return currentSpec || currentSuite();\n    };\n    var reporter = new j$.ReportDispatcher(['jasmineStarted', 'jasmineDone', 'suiteStarted', 'suiteDone', 'specStarted', 'specDone']);\n    this.specFilter = function () {\n      return true;\n    };\n    var nextSpecId = 0;\n    var getNextSpecId = function getNextSpecId() {\n      return 'spec' + nextSpecId++;\n    };\n    var nextSuiteId = 0;\n    var getNextSuiteId = function getNextSuiteId() {\n      return 'suite' + nextSuiteId++;\n    };\n    var defaultResourcesForRunnable = function defaultResourcesForRunnable(id, parentRunnableId) {\n      var resources = {\n        spies: []\n      };\n      runnableResources[id] = resources;\n    };\n    var clearResourcesForRunnable = function clearResourcesForRunnable(id) {\n      spyRegistry.clearSpies();\n      delete runnableResources[id];\n    };\n    var beforeAndAfterFns = function beforeAndAfterFns(suite) {\n      return function () {\n        var afters = [];\n        var befores = [];\n        while (suite) {\n          befores = befores.concat(suite.beforeFns);\n          afters = afters.concat(suite.afterFns);\n          suite = suite.parentSuite;\n        }\n        return {\n          befores: befores.reverse(),\n          afters: afters\n        };\n      };\n    };\n    var _getSpecName = function getSpecName(spec, suite) {\n      var fullName = [spec.description];\n      var suiteFullName = suite.getFullName();\n      if (suiteFullName !== '') {\n        fullName.unshift(suiteFullName);\n      }\n      return fullName.join(' ');\n    };\n    this.catchExceptions = function (value) {\n      catchExceptions = !!value;\n      return catchExceptions;\n    };\n    this.catchingExceptions = function () {\n      return catchExceptions;\n    };\n    this.throwOnExpectationFailure = function (value) {\n      throwOnExpectationFailure = !!value;\n    };\n    this.throwingExpectationFailures = function () {\n      return throwOnExpectationFailure;\n    };\n    this.randomizeTests = function (value) {\n      random = !!value;\n    };\n    this.randomTests = function () {\n      return random;\n    };\n    this.seed = function (value) {\n      if (value) {\n        seed = value;\n      }\n      return seed;\n    };\n    function queueRunnerFactory(options) {\n      options.clearTimeout = realClearTimeout;\n      options.fail = self.fail;\n      options.setTimeout = realSetTimeout;\n      return (0, _queue_runner2.default)(options);\n    }\n    var topSuite = new j$.Suite({\n      id: getNextSuiteId(),\n      getTestPath: function getTestPath() {\n        return j$.testPath;\n      }\n    });\n    currentDeclarationSuite = topSuite;\n    this.topSuite = function () {\n      return topSuite;\n    };\n    var uncaught = function uncaught(err) {\n      if (currentSpec) {\n        currentSpec.onException(err);\n        currentSpec.cancel();\n      } else {\n        console.error('Unhandled error');\n        console.error(err.stack);\n      }\n    };\n    var oldListenersException;\n    var oldListenersRejection;\n    var executionSetup = function executionSetup() {\n      // Need to ensure we are the only ones handling these exceptions.\n      oldListenersException = process.listeners('uncaughtException').slice();\n      oldListenersRejection = process.listeners('unhandledRejection').slice();\n      j$.process.removeAllListeners('uncaughtException');\n      j$.process.removeAllListeners('unhandledRejection');\n      j$.process.on('uncaughtException', uncaught);\n      j$.process.on('unhandledRejection', uncaught);\n    };\n    var executionTeardown = function executionTeardown() {\n      j$.process.removeListener('uncaughtException', uncaught);\n      j$.process.removeListener('unhandledRejection', uncaught);\n\n      // restore previous exception handlers\n      oldListenersException.forEach(function (listener) {\n        j$.process.on('uncaughtException', listener);\n      });\n      oldListenersRejection.forEach(function (listener) {\n        j$.process.on('unhandledRejection', listener);\n      });\n    };\n    this.execute = function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(runnablesToRun) {\n        var suiteTree,\n          lastDeclarationSuite,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              suiteTree = _args.length > 1 && _args[1] !== undefined ? _args[1] : topSuite;\n              if (!runnablesToRun) {\n                if (focusedRunnables.length) {\n                  runnablesToRun = focusedRunnables;\n                } else {\n                  runnablesToRun = [suiteTree.id];\n                }\n              }\n              if (currentlyExecutingSuites.length === 0) {\n                executionSetup();\n              }\n              lastDeclarationSuite = currentDeclarationSuite;\n              _context.next = 6;\n              return (0, _tree_processor2.default)({\n                nodeComplete: function nodeComplete(suite) {\n                  if (!suite.disabled) {\n                    clearResourcesForRunnable(suite.id);\n                  }\n                  currentlyExecutingSuites.pop();\n                  if (suite === topSuite) {\n                    reporter.jasmineDone({\n                      failedExpectations: topSuite.result.failedExpectations\n                    });\n                  } else {\n                    reporter.suiteDone(suite.getResult());\n                  }\n                },\n                nodeStart: function nodeStart(suite) {\n                  currentlyExecutingSuites.push(suite);\n                  defaultResourcesForRunnable(suite.id, suite.parentSuite && suite.parentSuite.id);\n                  if (suite === topSuite) {\n                    reporter.jasmineStarted({\n                      totalSpecsDefined: totalSpecsDefined\n                    });\n                  } else {\n                    reporter.suiteStarted(suite.result);\n                  }\n                },\n                queueRunnerFactory: queueRunnerFactory,\n                runnableIds: runnablesToRun,\n                tree: suiteTree\n              });\n            case 6:\n              currentDeclarationSuite = lastDeclarationSuite;\n              if (currentlyExecutingSuites.length === 0) {\n                executionTeardown();\n              }\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function (_x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this.addReporter = function (reporterToAdd) {\n      reporter.addReporter(reporterToAdd);\n    };\n    this.provideFallbackReporter = function (reporterToAdd) {\n      reporter.provideFallbackReporter(reporterToAdd);\n    };\n    this.clearReporters = function () {\n      reporter.clearReporters();\n    };\n    var spyRegistry = new j$.SpyRegistry({\n      currentSpies: function currentSpies() {\n        if (!currentRunnable()) {\n          throw new Error('Spies must be created in a before function or a spec');\n        }\n        return runnableResources[currentRunnable().id].spies;\n      }\n    });\n    this.allowRespy = function (allow) {\n      spyRegistry.allowRespy(allow);\n    };\n    this.spyOn = function () {\n      return spyRegistry.spyOn.apply(spyRegistry, arguments);\n    };\n    var suiteFactory = function suiteFactory(description) {\n      var suite = new j$.Suite({\n        id: getNextSuiteId(),\n        description: description,\n        parentSuite: currentDeclarationSuite,\n        throwOnExpectationFailure: throwOnExpectationFailure,\n        getTestPath: function getTestPath() {\n          return j$.testPath;\n        }\n      });\n      return suite;\n    };\n    this.describe = function (description, specDefinitions) {\n      var suite = suiteFactory(description);\n      if (specDefinitions.length > 0) {\n        throw new Error('describe does not expect any arguments');\n      }\n      if (currentDeclarationSuite.markedPending) {\n        suite.pend();\n      }\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n    this.xdescribe = function (description, specDefinitions) {\n      var suite = suiteFactory(description);\n      suite.pend();\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n    var focusedRunnables = [];\n    this.fdescribe = function (description, specDefinitions) {\n      var suite = suiteFactory(description);\n      suite.isFocused = true;\n      focusedRunnables.push(suite.id);\n      unfocusAncestor();\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n    function addSpecsToSuite(suite, specDefinitions) {\n      var parentSuite = currentDeclarationSuite;\n      parentSuite.addChild(suite);\n      currentDeclarationSuite = suite;\n      var declarationError = null;\n      try {\n        specDefinitions.call(suite);\n      } catch (e) {\n        declarationError = e;\n      }\n      if (declarationError) {\n        self.it('encountered a declaration exception', function () {\n          throw declarationError;\n        });\n      }\n      currentDeclarationSuite = parentSuite;\n    }\n    function findFocusedAncestor(suite) {\n      while (suite) {\n        if (suite.isFocused) {\n          return suite.id;\n        }\n        suite = suite.parentSuite;\n      }\n      return null;\n    }\n    function unfocusAncestor() {\n      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n      if (focusedAncestor) {\n        for (var i = 0; i < focusedRunnables.length; i++) {\n          if (focusedRunnables[i] === focusedAncestor) {\n            focusedRunnables.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n    var specFactory = function specFactory(description, fn, suite, _timeout) {\n      totalSpecsDefined++;\n      var spec = new j$.Spec({\n        id: getNextSpecId(),\n        beforeAndAfterFns: beforeAndAfterFns(suite),\n        resultCallback: specResultCallback,\n        getSpecName: function getSpecName(spec) {\n          return _getSpecName(spec, suite);\n        },\n        getTestPath: function getTestPath() {\n          return j$.testPath;\n        },\n        onStart: specStarted,\n        description: description,\n        queueRunnerFactory: queueRunnerFactory,\n        userContext: function userContext() {\n          return suite.clonedSharedUserContext();\n        },\n        queueableFn: {\n          fn: fn,\n          timeout: function timeout() {\n            return _timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n        },\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n      if (!self.specFilter(spec)) {\n        spec.disable();\n      }\n      return spec;\n      function specResultCallback(result) {\n        clearResourcesForRunnable(spec.id);\n        currentSpec = null;\n        reporter.specDone(result);\n      }\n      function specStarted(spec) {\n        currentSpec = spec;\n        defaultResourcesForRunnable(spec.id, suite.id);\n        reporter.specStarted(spec.result);\n      }\n    };\n    this.it = function (description, fn, timeout) {\n      if (typeof description !== 'string') {\n        throw new Error(\"Invalid first argument, \".concat(description, \". It must be a string.\"));\n      }\n      if (fn === undefined) {\n        throw new Error('Missing second argument. It must be a callback function.');\n      }\n      if (typeof fn !== 'function') {\n        throw new Error(\"Invalid second argument, \".concat(fn, \". It must be a callback function.\"));\n      }\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      if (currentDeclarationSuite.markedPending) {\n        spec.pend();\n      }\n\n      // When a test is defined inside another, jasmine will not run it.\n      // This check throws an error to warn the user about the edge-case.\n      if (currentSpec !== null) {\n        throw new Error('Tests cannot be nested. Test `' + spec.description + '` cannot run because it is nested within `' + currentSpec.description + '`.');\n      }\n      currentDeclarationSuite.addChild(spec);\n      return spec;\n    };\n    this.xit = function () {\n      var spec = this.it.apply(this, arguments);\n      spec.pend('Temporarily disabled with xit');\n      return spec;\n    };\n    this.fit = function (description, fn, timeout) {\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      currentDeclarationSuite.addChild(spec);\n      focusedRunnables.push(spec.id);\n      unfocusAncestor();\n      return spec;\n    };\n    this.beforeEach = function (beforeEachFunction, _timeout2) {\n      currentDeclarationSuite.beforeEach({\n        fn: beforeEachFunction,\n        timeout: function timeout() {\n          return _timeout2 || j$._DEFAULT_TIMEOUT_INTERVAL;\n        }\n      });\n    };\n    this.beforeAll = function (beforeAllFunction, _timeout3) {\n      currentDeclarationSuite.beforeAll({\n        fn: beforeAllFunction,\n        timeout: function timeout() {\n          return _timeout3 || j$._DEFAULT_TIMEOUT_INTERVAL;\n        }\n      });\n    };\n    this.afterEach = function (afterEachFunction, _timeout4) {\n      currentDeclarationSuite.afterEach({\n        fn: afterEachFunction,\n        timeout: function timeout() {\n          return _timeout4 || j$._DEFAULT_TIMEOUT_INTERVAL;\n        }\n      });\n    };\n    this.afterAll = function (afterAllFunction, _timeout5) {\n      currentDeclarationSuite.afterAll({\n        fn: afterAllFunction,\n        timeout: function timeout() {\n          return _timeout5 || j$._DEFAULT_TIMEOUT_INTERVAL;\n        }\n      });\n    };\n    this.pending = function (message) {\n      var fullMessage = j$.Spec.pendingSpecExceptionMessage;\n      if (message) {\n        fullMessage += message;\n      }\n      throw fullMessage;\n    };\n    this.fail = function (error) {\n      var _checkIsError = (0, _is_error2.default)(error);\n      var isError = _checkIsError.isError,\n        message = _checkIsError.message;\n      currentRunnable().addExpectationResult(false, {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        message: message,\n        error: isError ? error : new Error(message)\n      });\n    };\n  }\n  return Env;\n};\nvar _queue_runner = require('../queue_runner');\nvar _queue_runner2 = _interopRequireDefault(_queue_runner);\nvar _tree_processor = require('../tree_processor');\nvar _tree_processor2 = _interopRequireDefault(_tree_processor);\nvar _is_error = require('../is_error');\nvar _is_error2 = _interopRequireDefault(_is_error);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new _Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n        if (info.done) {\n          resolve(value);\n        } else {\n          return _Promise.resolve(value).then(function (value) {\n            step('next', value);\n          }, function (err) {\n            step('throw', err);\n          });\n        }\n      }\n      return step('next');\n    });\n  };\n}\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/* eslint-disable sort-keys */\n\n// Try getting the real promise object from the context, if available. Someone\n// could have overridden it in a test. Async functions return it implicitly.\n// eslint-disable-next-line no-unused-vars\nvar _Promise = global[Symbol.for('jest-native-promise')] || global.Promise;","map":null,"metadata":{},"sourceType":"script"}