{"ast":null,"code":"'use strict';\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = watch;\nvar _ansiEscapes;\nfunction _load_ansiEscapes() {\n  return _ansiEscapes = _interopRequireDefault(require('ansi-escapes'));\n}\nvar _chalk;\nfunction _load_chalk() {\n  return _chalk = _interopRequireDefault(require('chalk'));\n}\nvar _getChangedFilesPromise;\nfunction _load_getChangedFilesPromise() {\n  return _getChangedFilesPromise = _interopRequireDefault(require('./getChangedFilesPromise'));\n}\nvar _exit;\nfunction _load_exit() {\n  return _exit = _interopRequireDefault(require('exit'));\n}\nvar _jestHasteMap;\nfunction _load_jestHasteMap() {\n  return _jestHasteMap = _interopRequireDefault(require('jest-haste-map'));\n}\nvar _is_valid_path;\nfunction _load_is_valid_path() {\n  return _is_valid_path = _interopRequireDefault(require('./lib/is_valid_path'));\n}\nvar _jestUtil;\nfunction _load_jestUtil() {\n  return _jestUtil = require('jest-util');\n}\nvar _preRunMessage;\nfunction _load_preRunMessage() {\n  return _preRunMessage = require('./preRunMessage');\n}\nvar _create_context;\nfunction _load_create_context() {\n  return _create_context = _interopRequireDefault(require('./lib/create_context'));\n}\nvar _runJest;\nfunction _load_runJest() {\n  return _runJest = _interopRequireDefault(require('./runJest'));\n}\nvar _update_global_config;\nfunction _load_update_global_config() {\n  return _update_global_config = _interopRequireDefault(require('./lib/update_global_config'));\n}\nvar _SearchSource;\nfunction _load_SearchSource() {\n  return _SearchSource = _interopRequireDefault(require('./SearchSource'));\n}\nvar _TestWatcher;\nfunction _load_TestWatcher() {\n  return _TestWatcher = _interopRequireDefault(require('./TestWatcher'));\n}\nvar _FailedTestsCache;\nfunction _load_FailedTestsCache() {\n  return _FailedTestsCache = _interopRequireDefault(require('./FailedTestsCache'));\n}\nvar _constants;\nfunction _load_constants() {\n  return _constants = require('./constants');\n}\nvar _jestWatcher;\nfunction _load_jestWatcher() {\n  return _jestWatcher = require('jest-watcher');\n}\nvar _test_path_pattern;\nfunction _load_test_path_pattern() {\n  return _test_path_pattern = _interopRequireDefault(require('./plugins/test_path_pattern'));\n}\nvar _test_name_pattern;\nfunction _load_test_name_pattern() {\n  return _test_name_pattern = _interopRequireDefault(require('./plugins/test_name_pattern'));\n}\nvar _update_snapshots;\nfunction _load_update_snapshots() {\n  return _update_snapshots = _interopRequireDefault(require('./plugins/update_snapshots'));\n}\nvar _update_snapshots_interactive;\nfunction _load_update_snapshots_interactive() {\n  return _update_snapshots_interactive = _interopRequireDefault(require('./plugins/update_snapshots_interactive'));\n}\nvar _quit;\nfunction _load_quit() {\n  return _quit = _interopRequireDefault(require('./plugins/quit'));\n}\nvar _watch_plugins_helpers;\nfunction _load_watch_plugins_helpers() {\n  return _watch_plugins_helpers = require('./lib/watch_plugins_helpers');\n}\nvar _jestValidate;\nfunction _load_jestValidate() {\n  return _jestValidate = require('jest-validate');\n}\nvar _active_filters_message;\nfunction _load_active_filters_message() {\n  return _active_filters_message = _interopRequireDefault(require('./lib/active_filters_message'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar hasExitListener = false;\nvar INTERNAL_PLUGINS = [(_test_path_pattern || _load_test_path_pattern()).default, (_test_name_pattern || _load_test_name_pattern()).default, (_update_snapshots || _load_update_snapshots()).default, (_update_snapshots_interactive || _load_update_snapshots_interactive()).default, (_quit || _load_quit()).default];\nvar RESERVED_KEY_PLUGINS = new Map([[(_update_snapshots || _load_update_snapshots()).default, {\n  forbiddenOverwriteMessage: 'updating snapshots',\n  key: 'u'\n}], [(_update_snapshots_interactive || _load_update_snapshots_interactive()).default, {\n  forbiddenOverwriteMessage: 'updating snapshots interactively',\n  key: 'i'\n}], [(_quit || _load_quit()).default, {\n  forbiddenOverwriteMessage: 'quitting watch mode'\n}]]);\nfunction watch(initialGlobalConfig, contexts, outputStream, hasteMapInstances) {\n  var stdin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : process.stdin;\n  var hooks = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new (_jestWatcher || _load_jestWatcher()).JestHook();\n\n  // `globalConfig` will be constantly updated and reassigned as a result of\n  // watch mode interactions.\n  var globalConfig = initialGlobalConfig;\n  var activePlugin;\n  globalConfig = (0, (_update_global_config || _load_update_global_config()).default)(globalConfig, {\n    mode: globalConfig.watch ? 'watch' : 'watchAll',\n    passWithNoTests: true\n  });\n  var updateConfigAndRun = function updateConfigAndRun() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var bail = _ref.bail,\n      changedSince = _ref.changedSince,\n      collectCoverage = _ref.collectCoverage,\n      collectCoverageFrom = _ref.collectCoverageFrom,\n      collectCoverageOnlyFrom = _ref.collectCoverageOnlyFrom,\n      coverageDirectory = _ref.coverageDirectory,\n      coverageReporters = _ref.coverageReporters,\n      mode = _ref.mode,\n      notify = _ref.notify,\n      notifyMode = _ref.notifyMode,\n      onlyFailures = _ref.onlyFailures,\n      reporters = _ref.reporters,\n      testNamePattern = _ref.testNamePattern,\n      testPathPattern = _ref.testPathPattern,\n      updateSnapshot = _ref.updateSnapshot,\n      verbose = _ref.verbose;\n    var previousUpdateSnapshot = globalConfig.updateSnapshot;\n    globalConfig = (0, (_update_global_config || _load_update_global_config()).default)(globalConfig, {\n      bail: bail,\n      changedSince: changedSince,\n      collectCoverage: collectCoverage,\n      collectCoverageFrom: collectCoverageFrom,\n      collectCoverageOnlyFrom: collectCoverageOnlyFrom,\n      coverageDirectory: coverageDirectory,\n      coverageReporters: coverageReporters,\n      mode: mode,\n      notify: notify,\n      notifyMode: notifyMode,\n      onlyFailures: onlyFailures,\n      reporters: reporters,\n      testNamePattern: testNamePattern,\n      testPathPattern: testPathPattern,\n      updateSnapshot: updateSnapshot,\n      verbose: verbose\n    });\n    startRun(globalConfig);\n    globalConfig = (0, (_update_global_config || _load_update_global_config()).default)(globalConfig, {\n      // updateSnapshot is not sticky after a run.\n      updateSnapshot: previousUpdateSnapshot === 'all' ? 'none' : previousUpdateSnapshot\n    });\n  };\n  var watchPlugins = INTERNAL_PLUGINS.map(function (InternalPlugin) {\n    return new InternalPlugin({\n      stdin: stdin,\n      stdout: outputStream\n    });\n  });\n  watchPlugins.forEach(function (plugin) {\n    var hookSubscriber = hooks.getSubscriber();\n    if (plugin.apply) {\n      plugin.apply(hookSubscriber);\n    }\n  });\n  if (globalConfig.watchPlugins != null) {\n    var watchPluginKeys = new Map();\n    var _iterator = _createForOfIteratorHelper(watchPlugins),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var plugin = _step.value;\n        var reservedInfo = RESERVED_KEY_PLUGINS.get(plugin.constructor) || {};\n        var key = reservedInfo.key || getPluginKey(plugin, globalConfig);\n        if (!key) {\n          continue;\n        }\n        var forbiddenOverwriteMessage = reservedInfo.forbiddenOverwriteMessage;\n        watchPluginKeys.set(key, {\n          forbiddenOverwriteMessage: forbiddenOverwriteMessage,\n          overwritable: forbiddenOverwriteMessage == null,\n          plugin: plugin\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper(globalConfig.watchPlugins),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var pluginWithConfig = _step2.value;\n        // $FlowFixMe dynamic require\n        var ThirdPartyPlugin = require(pluginWithConfig.path);\n        var _plugin = new ThirdPartyPlugin({\n          config: pluginWithConfig.config,\n          stdin: stdin,\n          stdout: outputStream\n        });\n        checkForConflicts(watchPluginKeys, _plugin, globalConfig);\n        var hookSubscriber = hooks.getSubscriber();\n        if (_plugin.apply) {\n          _plugin.apply(hookSubscriber);\n        }\n        watchPlugins.push(_plugin);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  var failedTestsCache = new (_FailedTestsCache || _load_FailedTestsCache()).default();\n  var searchSources = contexts.map(function (context) {\n    return {\n      context: context,\n      searchSource: new (_SearchSource || _load_SearchSource()).default(context)\n    };\n  });\n  var isRunning = false;\n  var testWatcher;\n  var shouldDisplayWatchUsage = true;\n  var isWatchUsageDisplayed = false;\n  var emitFileChange = function emitFileChange() {\n    if (hooks.isUsed('onFileChange')) {\n      var projects = searchSources.map(function (_ref2) {\n        var context = _ref2.context,\n          searchSource = _ref2.searchSource;\n        return {\n          config: context.config,\n          testPaths: searchSource.findMatchingTests('').tests.map(function (t) {\n            return t.path;\n          })\n        };\n      });\n      hooks.getEmitter().onFileChange({\n        projects: projects\n      });\n    }\n  };\n  emitFileChange();\n  hasteMapInstances.forEach(function (hasteMapInstance, index) {\n    hasteMapInstance.on('change', function (_ref3) {\n      var eventsQueue = _ref3.eventsQueue,\n        hasteFS = _ref3.hasteFS,\n        moduleMap = _ref3.moduleMap;\n      var validPaths = eventsQueue.filter(function (_ref4) {\n        var filePath = _ref4.filePath;\n        return (0, (_is_valid_path || _load_is_valid_path()).default)(globalConfig, contexts[index].config, filePath);\n      });\n      if (validPaths.length) {\n        var context = contexts[index] = (0, (_create_context || _load_create_context()).default)(contexts[index].config, {\n          hasteFS: hasteFS,\n          moduleMap: moduleMap\n        });\n        activePlugin = null;\n        searchSources = searchSources.slice();\n        searchSources[index] = {\n          context: context,\n          searchSource: new (_SearchSource || _load_SearchSource()).default(context)\n        };\n        emitFileChange();\n        startRun(globalConfig);\n      }\n    });\n  });\n  if (!hasExitListener) {\n    hasExitListener = true;\n    process.on('exit', function () {\n      if (activePlugin) {\n        outputStream.write((_ansiEscapes || _load_ansiEscapes()).default.cursorDown());\n        outputStream.write((_ansiEscapes || _load_ansiEscapes()).default.eraseDown);\n      }\n    });\n  }\n  var startRun = function startRun(globalConfig) {\n    if (isRunning) {\n      return null;\n    }\n    testWatcher = new (_TestWatcher || _load_TestWatcher()).default({\n      isWatchMode: true\n    });\n    (_jestUtil || _load_jestUtil()).isInteractive && outputStream.write((_constants || _load_constants()).CLEAR);\n    (0, (_preRunMessage || _load_preRunMessage()).print)(outputStream);\n    isRunning = true;\n    var configs = contexts.map(function (context) {\n      return context.config;\n    });\n    var changedFilesPromise = (0, (_getChangedFilesPromise || _load_getChangedFilesPromise()).default)(globalConfig, configs);\n    return (0, (_runJest || _load_runJest()).default)({\n      changedFilesPromise: changedFilesPromise,\n      contexts: contexts,\n      failedTestsCache: failedTestsCache,\n      globalConfig: globalConfig,\n      jestHooks: hooks.getEmitter(),\n      onComplete: function onComplete(results) {\n        isRunning = false;\n        hooks.getEmitter().onTestRunComplete(results);\n\n        // Create a new testWatcher instance so that re-runs won't be blocked.\n        // The old instance that was passed to Jest will still be interrupted\n        // and prevent test runs from the previous run.\n        testWatcher = new (_TestWatcher || _load_TestWatcher()).default({\n          isWatchMode: true\n        });\n\n        // Do not show any Watch Usage related stuff when running in a\n        // non-interactive environment\n        if ((_jestUtil || _load_jestUtil()).isInteractive) {\n          if (shouldDisplayWatchUsage) {\n            outputStream.write(usage(globalConfig, watchPlugins));\n            shouldDisplayWatchUsage = false; // hide Watch Usage after first run\n            isWatchUsageDisplayed = true;\n          } else {\n            outputStream.write(showToggleUsagePrompt());\n            shouldDisplayWatchUsage = false;\n            isWatchUsageDisplayed = false;\n          }\n        } else {\n          outputStream.write('\\n');\n        }\n        failedTestsCache.setTestResults(results.testResults);\n      },\n      outputStream: outputStream,\n      startRun: startRun,\n      testWatcher: testWatcher\n    }).catch(function (error) {\n      return (\n        // Errors thrown inside `runJest`, e.g. by resolvers, are caught here for\n        // continuous watch mode execution. We need to reprint them to the\n        // terminal and give just a little bit of extra space so they fit below\n        // `preRunMessagePrint` message nicely.\n        console.error('\\n\\n' + (_chalk || _load_chalk()).default.red(error))\n      );\n    });\n  };\n  var onKeypress = function onKeypress(key) {\n    if (key === (_jestWatcher || _load_jestWatcher()).KEYS.CONTROL_C || key === (_jestWatcher || _load_jestWatcher()).KEYS.CONTROL_D) {\n      if (typeof stdin.setRawMode === 'function') {\n        stdin.setRawMode(false);\n      }\n      outputStream.write('\\n');\n      (0, (_exit || _load_exit()).default)(0);\n      return;\n    }\n    if (activePlugin != null && activePlugin.onKey) {\n      // if a plugin is activate, Jest should let it handle keystrokes, so ignore\n      // them here\n      activePlugin.onKey(key);\n      return;\n    }\n\n    // Abort test run\n    var pluginKeys = (0, (_watch_plugins_helpers || _load_watch_plugins_helpers()).getSortedUsageRows)(watchPlugins, globalConfig).map(function (usage) {\n      return Number(usage.key).toString(16);\n    });\n    if (isRunning && testWatcher && ['q', (_jestWatcher || _load_jestWatcher()).KEYS.ENTER, 'a', 'o', 'f'].concat(pluginKeys).includes(key)) {\n      testWatcher.setState({\n        interrupted: true\n      });\n      return;\n    }\n    var matchingWatchPlugin = (0, (_watch_plugins_helpers || _load_watch_plugins_helpers()).filterInteractivePlugins)(watchPlugins, globalConfig).find(function (plugin) {\n      return getPluginKey(plugin, globalConfig) === key;\n    });\n    if (matchingWatchPlugin != null) {\n      // \"activate\" the plugin, which has jest ignore keystrokes so the plugin\n      // can handle them\n      activePlugin = matchingWatchPlugin;\n      if (activePlugin.run) {\n        activePlugin.run(globalConfig, updateConfigAndRun).then(function (shouldRerun) {\n          activePlugin = null;\n          if (shouldRerun) {\n            updateConfigAndRun();\n          }\n        }, function () {\n          activePlugin = null;\n          onCancelPatternPrompt();\n        });\n      } else {\n        activePlugin = null;\n      }\n    }\n    switch (key) {\n      case (_jestWatcher || _load_jestWatcher()).KEYS.ENTER:\n        startRun(globalConfig);\n        break;\n      case 'a':\n        globalConfig = (0, (_update_global_config || _load_update_global_config()).default)(globalConfig, {\n          mode: 'watchAll',\n          testNamePattern: '',\n          testPathPattern: ''\n        });\n        startRun(globalConfig);\n        break;\n      case 'c':\n        updateConfigAndRun({\n          mode: 'watch',\n          testNamePattern: '',\n          testPathPattern: ''\n        });\n        break;\n      case 'f':\n        globalConfig = (0, (_update_global_config || _load_update_global_config()).default)(globalConfig, {\n          onlyFailures: !globalConfig.onlyFailures\n        });\n        startRun(globalConfig);\n        break;\n      case 'o':\n        globalConfig = (0, (_update_global_config || _load_update_global_config()).default)(globalConfig, {\n          mode: 'watch',\n          testNamePattern: '',\n          testPathPattern: ''\n        });\n        startRun(globalConfig);\n        break;\n      case '?':\n        break;\n      case 'w':\n        if (!shouldDisplayWatchUsage && !isWatchUsageDisplayed) {\n          outputStream.write((_ansiEscapes || _load_ansiEscapes()).default.cursorUp());\n          outputStream.write((_ansiEscapes || _load_ansiEscapes()).default.eraseDown);\n          outputStream.write(usage(globalConfig, watchPlugins));\n          isWatchUsageDisplayed = true;\n          shouldDisplayWatchUsage = false;\n        }\n        break;\n    }\n  };\n  var onCancelPatternPrompt = function onCancelPatternPrompt() {\n    outputStream.write((_ansiEscapes || _load_ansiEscapes()).default.cursorHide);\n    outputStream.write((_ansiEscapes || _load_ansiEscapes()).default.clearScreen);\n    outputStream.write(usage(globalConfig, watchPlugins));\n    outputStream.write((_ansiEscapes || _load_ansiEscapes()).default.cursorShow);\n  };\n  if (typeof stdin.setRawMode === 'function') {\n    stdin.setRawMode(true);\n    stdin.resume();\n    stdin.setEncoding('utf8');\n    stdin.on('data', onKeypress);\n  }\n  startRun(globalConfig);\n  return Promise.resolve();\n}\nvar checkForConflicts = function checkForConflicts(watchPluginKeys, plugin, globalConfig) {\n  var key = getPluginKey(plugin, globalConfig);\n  if (!key) {\n    return;\n  }\n  var conflictor = watchPluginKeys.get(key);\n  if (!conflictor || conflictor.overwritable) {\n    watchPluginKeys.set(key, {\n      overwritable: false,\n      plugin: plugin\n    });\n    return;\n  }\n  var error;\n  if (conflictor.forbiddenOverwriteMessage) {\n    error = \"\\n  Watch plugin \".concat((_chalk || _load_chalk()).default.bold.red(getPluginIdentifier(plugin)), \" attempted to register key \").concat((_chalk || _load_chalk()).default.bold.red(\"<\".concat(key, \">\")), \",\\n  that is reserved internally for \").concat((_chalk || _load_chalk()).default.bold.red(conflictor.forbiddenOverwriteMessage), \".\\n  Please change the configuration key for this plugin.\").trim();\n  } else {\n    var plugins = [conflictor.plugin, plugin].map(function (p) {\n      return (_chalk || _load_chalk()).default.bold.red(getPluginIdentifier(p));\n    }).join(' and ');\n    error = \"\\n  Watch plugins \".concat(plugins, \" both attempted to register key \").concat((_chalk || _load_chalk()).default.bold.red(\"<\".concat(key, \">\")), \".\\n  Please change the key configuration for one of the conflicting plugins to avoid overlap.\").trim();\n  }\n  throw new (_jestValidate || _load_jestValidate()).ValidationError('Watch plugin configuration error', error);\n};\nvar getPluginIdentifier = function getPluginIdentifier(plugin) {\n  return (\n    // This breaks as `displayName` is not defined as a static, but since\n    // WatchPlugin is an interface, and it is my understanding interface\n    // static fields are not definable anymore, no idea how to circumvent\n    // this :-(\n    // $FlowFixMe: leave `displayName` be.\n    plugin.constructor.displayName || plugin.constructor.name\n  );\n};\nvar getPluginKey = function getPluginKey(plugin, globalConfig) {\n  if (typeof plugin.getUsageInfo === 'function') {\n    return (plugin.getUsageInfo(globalConfig) || {}).key;\n  }\n  return null;\n};\nvar usage = function usage(globalConfig, watchPlugins) {\n  var delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '\\n';\n  var messages = [(0, (_active_filters_message || _load_active_filters_message()).default)(globalConfig), globalConfig.testPathPattern || globalConfig.testNamePattern ? (_chalk || _load_chalk()).default.dim(\" \\u203A Press \") + 'c' + (_chalk || _load_chalk()).default.dim(' to clear filters.') : null, '\\n' + (_chalk || _load_chalk()).default.bold('Watch Usage'), globalConfig.watch ? (_chalk || _load_chalk()).default.dim(\" \\u203A Press \") + 'a' + (_chalk || _load_chalk()).default.dim(' to run all tests.') : null, globalConfig.onlyFailures ? (_chalk || _load_chalk()).default.dim(\" \\u203A Press \") + 'f' + (_chalk || _load_chalk()).default.dim(' to quit \"only failed tests\" mode.') : (_chalk || _load_chalk()).default.dim(\" \\u203A Press \") + 'f' + (_chalk || _load_chalk()).default.dim(' to run only failed tests.'), (globalConfig.watchAll || globalConfig.testPathPattern || globalConfig.testNamePattern) && !globalConfig.noSCM ? (_chalk || _load_chalk()).default.dim(\" \\u203A Press \") + 'o' + (_chalk || _load_chalk()).default.dim(' to only run tests related to changed files.') : null].concat(_toConsumableArray((0, (_watch_plugins_helpers || _load_watch_plugins_helpers()).getSortedUsageRows)(watchPlugins, globalConfig).map(function (plugin) {\n    return (_chalk || _load_chalk()).default.dim(\" \\u203A Press\") + ' ' + plugin.key + ' ' + (_chalk || _load_chalk()).default.dim(\"to \".concat(plugin.prompt, \".\"));\n  })), [(_chalk || _load_chalk()).default.dim(\" \\u203A Press \") + 'Enter' + (_chalk || _load_chalk()).default.dim(' to trigger a test run.')]);\n  return messages.filter(function (message) {\n    return !!message;\n  }).join(delimiter) + '\\n';\n};\nvar showToggleUsagePrompt = function showToggleUsagePrompt() {\n  return '\\n' + (_chalk || _load_chalk()).default.bold('Watch Usage: ') + (_chalk || _load_chalk()).default.dim('Press ') + 'w' + (_chalk || _load_chalk()).default.dim(' to show more.');\n};","map":null,"metadata":{},"sourceType":"script"}