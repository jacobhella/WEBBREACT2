{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = require('path'),\n  fs = require('fs'),\n  mkdirp = require('mkdirp'),\n  matcherFor = require('./file-matcher').matcherFor,\n  libInstrument = require('istanbul-lib-instrument'),\n  libCoverage = require('istanbul-lib-coverage'),\n  libSourceMaps = require('istanbul-lib-source-maps'),\n  hook = require('istanbul-lib-hook'),\n  Reporter = require('./reporter');\nfunction getCoverFunctions(config, includes, callback) {\n  if (!callback && typeof includes === 'function') {\n    callback = includes;\n    includes = null;\n  }\n  var includePid = config.instrumentation.includePid(),\n    reportingDir = path.resolve(config.reporting.dir()),\n    reporter = new Reporter(config),\n    excludes = config.instrumentation.excludes(true),\n    // The coverage variable below should have different value than\n    // that of the coverage variable actually used by the instrumenter (in this case: __coverage__).\n    // Otherwise if you run nyc to provide coverage on these files,\n    // both the actual instrumenter and this file will write to the global coverage variable,\n    // and provide unexpected coverage result.\n    coverageVar = '$$coverage$$',\n    instOpts = config.instrumentation.getInstrumenterOpts(),\n    sourceMapStore = libSourceMaps.createSourceMapStore({}),\n    instrumenter,\n    transformer,\n    fakeRequire,\n    requireTransformer,\n    reportInitFn,\n    hookFn,\n    unhookFn,\n    coverageFinderFn,\n    coverageSetterFn,\n    beforeReportFn,\n    exitFn;\n  instOpts.coverageVariable = coverageVar;\n  instOpts.sourceMapUrlCallback = function (file, url) {\n    sourceMapStore.registerURL(file, url);\n  };\n  coverageFinderFn = function coverageFinderFn() {\n    return global[coverageVar];\n  };\n  instrumenter = libInstrument.createInstrumenter(instOpts);\n  transformer = function transformer(code, file) {\n    return instrumenter.instrumentSync(code, file);\n  };\n  requireTransformer = function requireTransformer(code, file) {\n    var cov,\n      ret = transformer(code, file);\n    if (fakeRequire) {\n      cov = coverageFinderFn();\n      cov[file] = instrumenter.lastFileCoverage();\n      return 'function x() {}';\n    }\n    return ret;\n  };\n  coverageSetterFn = function coverageSetterFn(cov) {\n    global[coverageVar] = cov;\n  };\n  reportInitFn = function reportInitFn() {\n    // set up reporter\n    mkdirp.sync(reportingDir); //ensure we fail early if we cannot do this\n    reporter.addAll(config.reporting.reports());\n    if (config.reporting.print() !== 'none') {\n      switch (config.reporting.print()) {\n        case 'detail':\n          reporter.add('text');\n          break;\n        case 'both':\n          reporter.add('text');\n          reporter.add('text-summary');\n          break;\n        default:\n          reporter.add('text-summary');\n          break;\n      }\n    }\n  };\n  var disabler;\n  hookFn = function hookFn(matchFn) {\n    var hookOpts = {\n      verbose: config.verbose,\n      extensions: config.instrumentation.extensions(),\n      coverageVariable: coverageVar\n    };\n\n    //initialize the global variable\n    coverageSetterFn({});\n    reportInitFn();\n    if (config.hooks.hookRunInContext()) {\n      hook.hookRunInContext(matchFn, transformer, hookOpts);\n    }\n    if (config.hooks.hookRunInThisContext()) {\n      hook.hookRunInThisContext(matchFn, transformer, hookOpts);\n    }\n    disabler = hook.hookRequire(matchFn, requireTransformer, hookOpts);\n  };\n  unhookFn = function unhookFn(matchFn) {\n    if (disabler) {\n      disabler();\n    }\n    hook.unhookRunInThisContext();\n    hook.unhookRunInContext();\n    hook.unloadRequireCache(matchFn);\n  };\n  beforeReportFn = function beforeReportFn(matchFn, cov) {\n    var pidExt = includePid ? '-' + process.pid : '',\n      file = path.resolve(reportingDir, 'coverage' + pidExt + '.raw.json'),\n      missingFiles,\n      finalCoverage = cov;\n    if (config.instrumentation.includeAllSources()) {\n      if (config.verbose) {\n        console.error(\"Including all sources not require'd by tests\");\n      }\n      missingFiles = [];\n      // Files that are not touched by code ran by the test runner is manually instrumented, to\n      // illustrate the missing coverage.\n      matchFn.files.forEach(function (file) {\n        if (!cov[file]) {\n          missingFiles.push(file);\n        }\n      });\n      fakeRequire = true;\n      missingFiles.forEach(function (file) {\n        try {\n          require(file);\n        } catch (ex) {\n          console.error('Unable to post-instrument: ' + file);\n        }\n      });\n    }\n    if (Object.keys(finalCoverage).length > 0) {\n      if (config.verbose) {\n        console.error('=============================================================================');\n        console.error('Writing coverage object [' + file + ']');\n        console.error('Writing coverage reports at [' + reportingDir + ']');\n        console.error('=============================================================================');\n      }\n      fs.writeFileSync(file, JSON.stringify(finalCoverage), 'utf8');\n    }\n    return finalCoverage;\n  };\n  exitFn = function exitFn(matchFn, reporterOpts) {\n    var cov, coverageMap, transformed;\n    cov = coverageFinderFn() || {};\n    cov = beforeReportFn(matchFn, cov);\n    coverageSetterFn(cov);\n    if (!(cov && typeof cov === 'object') || Object.keys(cov).length === 0) {\n      console.error('No coverage information was collected, exit without writing coverage information');\n      return;\n    }\n    coverageMap = libCoverage.createCoverageMap(cov);\n    transformed = sourceMapStore.transformCoverage(coverageMap);\n    reporterOpts.sourceFinder = transformed.sourceFinder;\n    reporter.write(transformed.map, reporterOpts);\n    sourceMapStore.dispose();\n  };\n  excludes.push(path.relative(process.cwd(), path.join(reportingDir, '**', '*')));\n  includes = includes || config.instrumentation.extensions().map(function (ext) {\n    return '**/*' + ext;\n  });\n  var matchConfig = {\n    root: config.instrumentation.root() || /* istanbul ignore next: untestable */process.cwd(),\n    includes: includes,\n    excludes: excludes\n  };\n  matcherFor(matchConfig, function (err, matchFn) {\n    /* istanbul ignore if: untestable */\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, {\n      coverageFn: coverageFinderFn,\n      hookFn: hookFn.bind(null, matchFn),\n      exitFn: exitFn.bind(null, matchFn, {}),\n      // XXX: reporter opts\n      unhookFn: unhookFn.bind(null, matchFn)\n    });\n  });\n}\nmodule.exports = {\n  getCoverFunctions: getCoverFunctions\n};","map":null,"metadata":{},"sourceType":"script"}