{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/taggedTemplateLiteral\");\nvar _slicedToArray = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _toConsumableArray = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _templateObject;\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\nvar _assert = require(\"assert\");\nvar _t = require(\"@babel/types\");\nvar _template = require(\"@babel/template\");\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\nvar assignmentExpression = _t.assignmentExpression,\n  callExpression = _t.callExpression,\n  cloneNode = _t.cloneNode,\n  expressionStatement = _t.expressionStatement,\n  getOuterBindingIdentifiers = _t.getOuterBindingIdentifiers,\n  identifier = _t.identifier,\n  isMemberExpression = _t.isMemberExpression,\n  isVariableDeclaration = _t.isVariableDeclaration,\n  jsxIdentifier = _t.jsxIdentifier,\n  jsxMemberExpression = _t.jsxMemberExpression,\n  memberExpression = _t.memberExpression,\n  numericLiteral = _t.numericLiteral,\n  sequenceExpression = _t.sequenceExpression,\n  stringLiteral = _t.stringLiteral,\n  variableDeclaration = _t.variableDeclaration,\n  variableDeclarator = _t.variableDeclarator;\nfunction isInType(path) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n      case \"ExportSpecifier\":\n        return path.parentPath.parent.exportKind === \"type\";\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n    }\n  } while (path = path.parentPath);\n}\nfunction rewriteLiveReferences(programPath, metadata) {\n  var imported = new Map();\n  var exported = new Map();\n  var requeueInParent = function requeueInParent(path) {\n    programPath.requeue(path);\n  };\n  var _iterator = _createForOfIteratorHelper(metadata.source),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        source = _step$value[0],\n        data = _step$value[1];\n      var _iterator3 = _createForOfIteratorHelper(data.imports),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            localName = _step3$value[0],\n            importName = _step3$value[1];\n          imported.set(localName, [source, importName, null]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var _iterator4 = _createForOfIteratorHelper(data.importsNamespace),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _localName = _step4.value;\n          imported.set(_localName, [source, null, _localName]);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(metadata.local),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _exportMeta;\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        local = _step2$value[0],\n        _data = _step2$value[1];\n      var exportMeta = exported.get(local);\n      if (!exportMeta) {\n        exportMeta = [];\n        exported.set(local, exportMeta);\n      }\n      (_exportMeta = exportMeta).push.apply(_exportMeta, _toConsumableArray(_data.names));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var rewriteBindingInitVisitorState = {\n    metadata: metadata,\n    requeueInParent: requeueInParent,\n    scope: programPath.scope,\n    exported: exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([].concat(_toConsumableArray(Array.from(imported.keys())), _toConsumableArray(Array.from(exported.keys())))), false);\n  var rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata: metadata,\n    requeueInParent: requeueInParent,\n    scope: programPath.scope,\n    imported: imported,\n    exported: exported,\n    buildImportReference: function buildImportReference(_ref, identNode) {\n      var _ref2 = _slicedToArray(_ref, 3),\n        source = _ref2[0],\n        importName = _ref2[1],\n        localName = _ref2[2];\n      var meta = metadata.source.get(source);\n      meta.referenced = true;\n      if (localName) {\n        if (meta.lazy) {\n          identNode = callExpression(identNode, []);\n        }\n        return identNode;\n      }\n      var namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n      var computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\nvar rewriteBindingInitVisitor = {\n  Scope: function Scope(path) {\n    path.skip();\n  },\n  ClassDeclaration: function ClassDeclaration(path) {\n    var requeueInParent = this.requeueInParent,\n      exported = this.exported,\n      metadata = this.metadata;\n    var id = path.node.id;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    var localName = id.name;\n    var exportNames = exported.get(localName) || [];\n    if (exportNames.length > 0) {\n      var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n  VariableDeclaration: function VariableDeclaration(path) {\n    var requeueInParent = this.requeueInParent,\n      exported = this.exported,\n      metadata = this.metadata;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {\n      var exportNames = exported.get(localName) || [];\n      if (exportNames.length > 0) {\n        var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n};\nvar buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr, scope) {\n  var exportsObjectName = metadata.exportName;\n  for (var currentScope = scope; currentScope != null; currentScope = currentScope.parent) {\n    if (currentScope.hasOwnBinding(exportsObjectName)) {\n      currentScope.rename(exportsObjectName);\n    }\n  }\n  return (exportNames || []).reduce(function (expr, exportName) {\n    var stringSpecifiers = metadata.stringSpecifiers;\n    var computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(exportsObjectName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\nvar buildImportThrow = function buildImportThrow(localName) {\n  return _template.default.expression.ast(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    (function() {\\n      throw new Error('\\\"' + '\", \"' + '\\\" is read-only.');\\n    })()\\n  \"])), localName);\n};\nvar rewriteReferencesVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path) {\n    var seen = this.seen,\n      buildImportReference = this.buildImportReference,\n      scope = this.scope,\n      imported = this.imported,\n      requeueInParent = this.requeueInParent;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    var localName = path.node.name;\n    var importData = imported.get(localName);\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(\"Cannot transform the imported binding \\\"\".concat(localName, \"\\\" since it's also used in a type annotation. \") + \"Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.\");\n      }\n      var localBinding = path.scope.getBinding(localName);\n      var rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      var ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        var object = ref.object,\n          property = ref.property;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n  UpdateExpression: function UpdateExpression(path) {\n    var scope = this.scope,\n      seen = this.seen,\n      imported = this.imported,\n      exported = this.exported,\n      requeueInParent = this.requeueInParent,\n      buildImportReference = this.buildImportReference;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    var arg = path.get(\"argument\");\n    if (arg.isMemberExpression()) return;\n    var update = path.node;\n    if (arg.isIdentifier()) {\n      var localName = arg.node.name;\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n      var exportedNames = exported.get(localName);\n      var importData = imported.get(localName);\n      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n        if (importData) {\n          path.replaceWith(assignmentExpression(update.operator[0] + \"=\", buildImportReference(importData, arg.node), buildImportThrow(localName)));\n        } else if (update.prefix) {\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update), path.scope));\n        } else {\n          var ref = scope.generateDeclaredUidIdentifier(localName);\n          path.replaceWith(sequenceExpression([assignmentExpression(\"=\", cloneNode(ref), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path.scope), cloneNode(ref)]));\n        }\n      }\n    }\n    requeueInParent(path);\n    path.skip();\n  },\n  AssignmentExpression: {\n    exit: function exit(path) {\n      var _this = this;\n      var scope = this.scope,\n        seen = this.seen,\n        imported = this.imported,\n        exported = this.exported,\n        requeueInParent = this.requeueInParent,\n        buildImportReference = this.buildImportReference;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      var left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n      if (left.isIdentifier()) {\n        var localName = left.node.name;\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n        var exportedNames = exported.get(localName);\n        var importData = imported.get(localName);\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n          var assignment = path.node;\n          if (importData) {\n            assignment.left = buildImportReference(importData, left.node);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment, path.scope));\n          requeueInParent(path);\n        }\n      } else {\n        var ids = left.getOuterBindingIdentifiers();\n        var programScopeIds = Object.keys(ids).filter(function (localName) {\n          return scope.getBinding(localName) === path.scope.getBinding(localName);\n        });\n        var id = programScopeIds.find(function (localName) {\n          return imported.has(localName);\n        });\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n        var items = [];\n        programScopeIds.forEach(function (localName) {\n          var exportedNames = exported.get(localName) || [];\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, identifier(localName), path.scope));\n          }\n        });\n        if (items.length > 0) {\n          var node = sequenceExpression(items);\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n          var statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n  },\n  \"ForOfStatement|ForInStatement\": function ForOfStatementForInStatement(path) {\n    var scope = path.scope,\n      node = path.node;\n    var left = node.left;\n    var exported = this.exported,\n      imported = this.imported,\n      programScope = this.scope;\n    if (!isVariableDeclaration(left)) {\n      var didTransformExport = false,\n        importConstViolationName;\n      var loopBodyScope = path.get(\"body\").scope;\n      for (var _i = 0, _Object$keys = Object.keys(getOuterBindingIdentifiers(left)); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n      path.ensureBlock();\n      var bodyPath = path.get(\"body\");\n      var newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}