{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\"use strict\";\n\nvar path = require('path'),\n  parsePath = require('path-parse'),\n  SEP = path.sep || /* istanbul ignore next */'/',\n  origParser = parsePath,\n  origSep = SEP;\nfunction makeRelativeNormalizedPath(str, sep) {\n  var parsed = parsePath(str),\n    root = parsed.root,\n    dir,\n    file = parsed.base,\n    quoted,\n    pos;\n\n  // handle a weird windows case separately\n  if (sep === '\\\\') {\n    pos = root.indexOf(':\\\\');\n    if (pos >= 0) {\n      root = root.substring(0, pos + 2);\n    }\n  }\n  dir = parsed.dir.substring(root.length);\n  if (str === '') {\n    return [];\n  }\n  if (sep !== '/') {\n    quoted = new RegExp(sep.replace(/\\W/g, '\\\\$&'), 'g');\n    dir = dir.replace(quoted, '/');\n    file = file.replace(quoted, '/'); // excessively paranoid?\n  }\n\n  if (dir !== '') {\n    dir = dir + '/' + file;\n  } else {\n    dir = file;\n  }\n  if (dir.substring(0, 1) === '/') {\n    dir = dir.substring(1);\n  }\n  dir = dir.split(/\\/+/);\n  return dir;\n}\nfunction Path(strOrArray) {\n  if (Array.isArray(strOrArray)) {\n    this.v = strOrArray;\n  } else if (typeof strOrArray === \"string\") {\n    this.v = makeRelativeNormalizedPath(strOrArray, SEP);\n  } else {\n    throw new Error('Invalid Path argument must be string or array:' + strOrArray);\n  }\n}\nPath.prototype.toString = function () {\n  return this.v.join('/');\n};\nPath.prototype.hasParent = function () {\n  return this.v.length > 0;\n};\nPath.prototype.parent = function () {\n  if (!this.hasParent()) {\n    throw new Error('Unable to get parent for 0 elem path');\n  }\n  var p = this.v.slice();\n  p.pop();\n  return new Path(p);\n};\nPath.prototype.elements = function () {\n  return this.v.slice();\n};\nPath.prototype.contains = function (other) {\n  var i;\n  if (other.length > this.length) {\n    return false;\n  }\n  for (i = 0; i < other.length; i += 1) {\n    if (this.v[i] !== other.v[i]) {\n      return false;\n    }\n  }\n  return true;\n};\nPath.prototype.ancestorOf = function (other) {\n  return other.contains(this) && other.length !== this.length;\n};\nPath.prototype.descendantOf = function (other) {\n  return this.contains(other) && other.length !== this.length;\n};\nPath.prototype.commonPrefixPath = function (other) {\n  var len = this.length > other.length ? other.length : this.length,\n    i,\n    ret = [];\n  for (i = 0; i < len; i += 1) {\n    if (this.v[i] === other.v[i]) {\n      ret.push(this.v[i]);\n    } else {\n      break;\n    }\n  }\n  return new Path(ret);\n};\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function (f) {\n  Path.prototype[f] = function () {\n    var args = Array.prototype.slice.call(arguments),\n      v = this.v;\n    return v[f].apply(v, args);\n  };\n});\nPath.compare = function (a, b) {\n  var al = a.length,\n    bl = b.length,\n    astr,\n    bstr;\n  if (al < bl) {\n    return -1;\n  }\n  if (al > bl) {\n    return 1;\n  }\n  astr = a.toString();\n  bstr = b.toString();\n  return astr < bstr ? -1 : astr > bstr ? 1 : 0;\n};\nObject.defineProperty(Path.prototype, 'length', {\n  enumerable: true,\n  get: function get() {\n    return this.v.length;\n  }\n});\nmodule.exports = Path;\nPath.tester = {\n  setParserAndSep: function setParserAndSep(p, sep) {\n    parsePath = p;\n    SEP = sep;\n  },\n  reset: function reset() {\n    parsePath = origParser;\n    SEP = origSep;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}