{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _jestMessageUtil = require('jest-message-util');\n\n// Try getting the real promise object from the context, if available. Someone\n// could have overridden it in a test.\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\nvar Jasmine2Reporter = /*#__PURE__*/function () {\n  function Jasmine2Reporter(globalConfig, config, testPath) {\n    var _this = this;\n    _classCallCheck(this, Jasmine2Reporter);\n    this._globalConfig = globalConfig;\n    this._config = config;\n    this._testPath = testPath;\n    this._testResults = [];\n    this._currentSuites = [];\n    this._resolve = null;\n    this._resultsPromise = new Promise(function (resolve) {\n      return _this._resolve = resolve;\n    });\n    this._startTimes = new Map();\n  }\n  _createClass(Jasmine2Reporter, [{\n    key: \"specStarted\",\n    value: function specStarted(spec) {\n      this._startTimes.set(spec.id, Date.now());\n    }\n  }, {\n    key: \"specDone\",\n    value: function specDone(result) {\n      this._testResults.push(this._extractSpecResults(result, this._currentSuites.slice(0)));\n    }\n  }, {\n    key: \"suiteStarted\",\n    value: function suiteStarted(suite) {\n      this._currentSuites.push(suite.description);\n    }\n  }, {\n    key: \"suiteDone\",\n    value: function suiteDone() {\n      this._currentSuites.pop();\n    }\n  }, {\n    key: \"jasmineDone\",\n    value: function jasmineDone() {\n      var numFailingTests = 0;\n      var numPassingTests = 0;\n      var numPendingTests = 0;\n      var testResults = this._testResults;\n      testResults.forEach(function (testResult) {\n        if (testResult.status === 'failed') {\n          numFailingTests++;\n        } else if (testResult.status === 'pending') {\n          numPendingTests++;\n        } else {\n          numPassingTests++;\n        }\n      });\n      var testResult = {\n        console: null,\n        failureMessage: (0, _jestMessageUtil.formatResultsErrors)(testResults, this._config, this._globalConfig, this._testPath),\n        numFailingTests: numFailingTests,\n        numPassingTests: numPassingTests,\n        numPendingTests: numPendingTests,\n        perfStats: {\n          end: 0,\n          start: 0\n        },\n        snapshot: {\n          added: 0,\n          fileDeleted: false,\n          matched: 0,\n          unchecked: 0,\n          unmatched: 0,\n          updated: 0\n        },\n        testFilePath: this._testPath,\n        testResults: testResults\n      };\n      this._resolve(testResult);\n    }\n  }, {\n    key: \"getResults\",\n    value: function getResults() {\n      return this._resultsPromise;\n    }\n  }, {\n    key: \"_addMissingMessageToStack\",\n    value: function _addMissingMessageToStack(stack, message) {\n      // Some errors (e.g. Angular injection error) don't prepend error.message\n      // to stack, instead the first line of the stack is just plain 'Error'\n      var ERROR_REGEX = /^Error\\s*\\n/;\n      if (stack && message && ERROR_REGEX.test(stack) && stack.indexOf(message) === -1) {\n        return message + stack.replace(ERROR_REGEX, '\\n');\n      }\n      return stack;\n    }\n  }, {\n    key: \"_extractSpecResults\",\n    value: function _extractSpecResults(specResult, ancestorTitles) {\n      var _this2 = this;\n      var start = this._startTimes.get(specResult.id);\n      var duration = start ? Date.now() - start : undefined;\n      var status = specResult.status === 'disabled' ? 'pending' : specResult.status;\n      var location = specResult.__callsite ? {\n        column: specResult.__callsite.getColumnNumber(),\n        // $FlowFixMe: https://github.com/facebook/flow/issues/5213\n        line: specResult.__callsite.getLineNumber()\n      } : null;\n      var results = {\n        ancestorTitles: ancestorTitles,\n        duration: duration,\n        failureMessages: [],\n        fullName: specResult.fullName,\n        location: location,\n        numPassingAsserts: 0,\n        // Jasmine2 only returns an array of failed asserts.\n        status: status,\n        title: specResult.description\n      };\n      specResult.failedExpectations.forEach(function (failed) {\n        var message = !failed.matcherName && failed.stack ? _this2._addMissingMessageToStack(failed.stack, failed.message) : failed.message || '';\n        results.failureMessages.push(message);\n      });\n      return results;\n    }\n  }]);\n  return Jasmine2Reporter;\n}();\nexports.default = Jasmine2Reporter;","map":null,"metadata":{},"sourceType":"script"}