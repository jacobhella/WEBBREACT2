{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = WatchmanWatcher;\nvar _fs;\nfunction _load_fs() {\n  return _fs = _interopRequireDefault(require('fs'));\n}\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _assert;\nfunction _load_assert() {\n  return _assert = _interopRequireDefault(require('assert'));\n}\nvar _common;\nfunction _load_common() {\n  return _common = _interopRequireDefault(require('sane/src/common'));\n}\nvar _fbWatchman;\nfunction _load_fbWatchman() {\n  return _fbWatchman = _interopRequireDefault(require('fb-watchman'));\n}\nvar _events;\nfunction _load_events() {\n  return _events = require('events');\n}\nvar _recrawlWarningDedupe;\nfunction _load_recrawlWarningDedupe() {\n  return _recrawlWarningDedupe = _interopRequireDefault(require('sane/src/utils/recrawl-warning-dedupe'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar CHANGE_EVENT = (_common || _load_common()).default.CHANGE_EVENT;\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar DELETE_EVENT = (_common || _load_common()).default.DELETE_EVENT;\nvar ADD_EVENT = (_common || _load_common()).default.ADD_EVENT;\nvar ALL_EVENT = (_common || _load_common()).default.ALL_EVENT;\nvar SUB_NAME = 'sane-sub';\n\n/**\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction WatchmanWatcher(dir, opts) {\n  (_common || _load_common()).default.assignOptions(this, opts);\n  this.root = (_path || _load_path()).default.resolve(dir);\n  this.init();\n}\n\n// eslint-disable-next-line no-proto\nWatchmanWatcher.prototype.__proto__ = (_events || _load_events()).EventEmitter.prototype;\n\n/**\n * Run the watchman `watch` command on the root and subscribe to changes.\n *\n * @private\n */\n\nWatchmanWatcher.prototype.init = function () {\n  if (this.client) {\n    this.client.removeAllListeners();\n  }\n  var self = this;\n  this.client = new (_fbWatchman || _load_fbWatchman()).default.Client();\n  this.client.on('error', function (error) {\n    self.emit('error', error);\n  });\n  this.client.on('subscription', this.handleChangeEvent.bind(this));\n  this.client.on('end', function () {\n    console.warn('[sane] Warning: Lost connection to watchman, reconnecting..');\n    self.init();\n  });\n  this.watchProjectInfo = null;\n  function getWatchRoot() {\n    return self.watchProjectInfo ? self.watchProjectInfo.root : self.root;\n  }\n  function onCapability(error, resp) {\n    if (handleError(self, error)) {\n      // The Watchman watcher is unusable on this system, we cannot continue\n      return;\n    }\n    handleWarning(resp);\n    self.capabilities = resp.capabilities;\n    if (self.capabilities.relative_root) {\n      self.client.command(['watch-project', getWatchRoot()], onWatchProject);\n    } else {\n      self.client.command(['watch', getWatchRoot()], onWatch);\n    }\n  }\n  function onWatchProject(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n    handleWarning(resp);\n    self.watchProjectInfo = {\n      relativePath: resp.relative_path ? resp.relative_path : '',\n      root: resp.watch\n    };\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n  function onWatch(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n    handleWarning(resp);\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n  function onClock(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n    handleWarning(resp);\n    var options = {\n      fields: ['name', 'exists', 'new'],\n      since: resp.clock\n    };\n\n    // If the server has the wildmatch capability available it supports\n    // the recursive **/*.foo style match and we can offload our globs\n    // to the watchman server.  This saves both on data size to be\n    // communicated back to us and compute for evaluating the globs\n    // in our node process.\n    if (self.capabilities.wildmatch) {\n      if (self.globs.length === 0) {\n        if (!self.dot) {\n          // Make sure we honor the dot option if even we're not using globs.\n          options.expression = ['match', '**', 'wholename', {\n            includedotfiles: false\n          }];\n        }\n      } else {\n        options.expression = ['anyof'];\n        for (var i in self.globs) {\n          options.expression.push(['match', self.globs[i], 'wholename', {\n            includedotfiles: self.dot\n          }]);\n        }\n      }\n    }\n    if (self.capabilities.relative_root) {\n      options.relative_root = self.watchProjectInfo.relativePath;\n    }\n    self.client.command(['subscribe', getWatchRoot(), SUB_NAME, options], onSubscribe);\n  }\n  function onSubscribe(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n    handleWarning(resp);\n    self.emit('ready');\n  }\n  self.client.capabilityCheck({\n    optional: ['wildmatch', 'relative_root']\n  }, onCapability);\n};\n\n/**\n * Handles a change event coming from the subscription.\n *\n * @param {Object} resp\n * @private\n */\n\nWatchmanWatcher.prototype.handleChangeEvent = function (resp) {\n  (_assert || _load_assert()).default.equal(resp.subscription, SUB_NAME, 'Invalid subscription event.');\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n  if (Array.isArray(resp.files)) {\n    resp.files.forEach(this.handleFileChange, this);\n  }\n};\n\n/**\n * Handles a single change event record.\n *\n * @param {Object} changeDescriptor\n * @private\n */\n\nWatchmanWatcher.prototype.handleFileChange = function (changeDescriptor) {\n  var self = this;\n  var absPath;\n  var relativePath;\n  if (this.capabilities.relative_root) {\n    relativePath = changeDescriptor.name;\n    absPath = (_path || _load_path()).default.join(this.watchProjectInfo.root, this.watchProjectInfo.relativePath, relativePath);\n  } else {\n    absPath = (_path || _load_path()).default.join(this.root, changeDescriptor.name);\n    relativePath = changeDescriptor.name;\n  }\n  if (!(self.capabilities.wildmatch && !this.hasIgnore) && !(_common || _load_common()).default.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n    return;\n  }\n  if (!changeDescriptor.exists) {\n    self.emitEvent(DELETE_EVENT, relativePath, self.root);\n  } else {\n    (_fs || _load_fs()).default.lstat(absPath, function (error, stat) {\n      // Files can be deleted between the event and the lstat call\n      // the most reliable thing to do here is to ignore the event.\n      if (error && error.code === 'ENOENT') {\n        return;\n      }\n      if (handleError(self, error)) {\n        return;\n      }\n      var eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT;\n\n      // Change event on dirs are mostly useless.\n      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {\n        self.emitEvent(eventType, relativePath, self.root, stat);\n      }\n    });\n  }\n};\n\n/**\n * Dispatches the event.\n *\n * @param {string} eventType\n * @param {string} filepath\n * @param {string} root\n * @param {fs.Stat} stat\n * @private\n */\n\nWatchmanWatcher.prototype.emitEvent = function (eventType, filepath, root, stat) {\n  this.emit(eventType, filepath, root, stat);\n  this.emit(ALL_EVENT, eventType, filepath, root, stat);\n};\n\n/**\n * Closes the watcher.\n *\n * @param {function} callback\n * @private\n */\n\nWatchmanWatcher.prototype.close = function (callback) {\n  this.client.removeAllListeners();\n  this.client.end();\n  callback && callback(null, true);\n};\n\n/**\n * Handles an error and returns true if exists.\n *\n * @param {WatchmanWatcher} self\n * @param {Error} error\n * @private\n */\n\nfunction handleError(self, error) {\n  if (error != null) {\n    self.emit('error', error);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Handles a warning in the watchman resp object.\n *\n * @param {object} resp\n * @private\n */\n\nfunction handleWarning(resp) {\n  if ('warning' in resp) {\n    if ((_recrawlWarningDedupe || _load_recrawlWarningDedupe()).default.isRecrawlWarningDupe(resp.warning)) {\n      return true;\n    }\n    console.warn(resp.warning);\n    return true;\n  } else {\n    return false;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}