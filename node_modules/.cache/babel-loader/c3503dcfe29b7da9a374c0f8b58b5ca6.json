{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _constants;\nfunction _load_constants() {\n  return _constants = _interopRequireDefault(require('./constants'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar EMPTY_MAP = {};\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\nvar ModuleMap = /*#__PURE__*/function () {\n  function ModuleMap(raw) {\n    _classCallCheck(this, ModuleMap);\n    this._raw = raw;\n  }\n  _createClass(ModuleMap, [{\n    key: \"getModule\",\n    value: function getModule(name, platform, supportsNativePlatform, type) {\n      if (!type) {\n        type = (_constants || _load_constants()).default.MODULE;\n      }\n      var module = this._getModuleMetadata(name, platform, !!supportsNativePlatform);\n      if (module && module[(_constants || _load_constants()).default.TYPE] === type) {\n        return module[(_constants || _load_constants()).default.PATH];\n      }\n      return null;\n    }\n  }, {\n    key: \"getPackage\",\n    value: function getPackage(name, platform, supportsNativePlatform) {\n      return this.getModule(name, platform, null, (_constants || _load_constants()).default.PACKAGE);\n    }\n  }, {\n    key: \"getMockModule\",\n    value: function getMockModule(name) {\n      return this._raw.mocks[name] || this._raw.mocks[name + '/index'];\n    }\n  }, {\n    key: \"getRawModuleMap\",\n    value: function getRawModuleMap() {\n      return {\n        duplicates: this._raw.duplicates,\n        map: this._raw.map,\n        mocks: this._raw.mocks\n      };\n    }\n    /**\n     * When looking up a module's data, we walk through each eligible platform for\n     * the query. For each platform, we want to check if there are known\n     * duplicates for that name+platform pair. The duplication logic normally\n     * removes elements from the `map` object, but we want to check upfront to be\n     * extra sure. If metadata exists both in the `duplicates` object and the\n     * `map`, this would be a bug.\n     */\n  }, {\n    key: \"_getModuleMetadata\",\n    value: function _getModuleMetadata(name, platform, supportsNativePlatform) {\n      var map = this._raw.map[name] || EMPTY_MAP;\n      var dupMap = this._raw.duplicates[name] || EMPTY_MAP;\n      if (platform != null) {\n        this._assertNoDuplicates(name, platform, supportsNativePlatform, dupMap[platform]);\n        if (map[platform] != null) {\n          return map[platform];\n        }\n      }\n      if (supportsNativePlatform) {\n        this._assertNoDuplicates(name, (_constants || _load_constants()).default.NATIVE_PLATFORM, supportsNativePlatform, dupMap[(_constants || _load_constants()).default.NATIVE_PLATFORM]);\n        if (map[(_constants || _load_constants()).default.NATIVE_PLATFORM]) {\n          return map[(_constants || _load_constants()).default.NATIVE_PLATFORM];\n        }\n      }\n      this._assertNoDuplicates(name, (_constants || _load_constants()).default.GENERIC_PLATFORM, supportsNativePlatform, dupMap[(_constants || _load_constants()).default.GENERIC_PLATFORM]);\n      if (map[(_constants || _load_constants()).default.GENERIC_PLATFORM]) {\n        return map[(_constants || _load_constants()).default.GENERIC_PLATFORM];\n      }\n      return null;\n    }\n  }, {\n    key: \"_assertNoDuplicates\",\n    value: function _assertNoDuplicates(name, platform, supportsNativePlatform, set) {\n      if (set == null) {\n        return;\n      }\n      throw new DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, set);\n    }\n  }]);\n  return ModuleMap;\n}();\nexports.default = ModuleMap;\nvar DuplicateHasteCandidatesError = /*#__PURE__*/function (_Error) {\n  _inherits(DuplicateHasteCandidatesError, _Error);\n  function DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, duplicatesSet) {\n    var _this;\n    _classCallCheck(this, DuplicateHasteCandidatesError);\n    var platformMessage = getPlatformMessage(platform);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DuplicateHasteCandidatesError).call(this, \"The name `\".concat(name, \"` was looked up in the Haste module map. It \") + \"cannot be resolved, because there exists several different \" + \"files, or packages, that provide a module for \" + \"that particular name and platform. \".concat(platformMessage, \" You must \") + \"delete or blacklist files until there remains only one of these:\\n\\n\" + Object.keys(duplicatesSet).sort().map(function (dupFilePath) {\n      var typeMessage = getTypeMessage(duplicatesSet[dupFilePath]);\n      return \"  * `\".concat(dupFilePath, \"` (\").concat(typeMessage, \")\\n\");\n    }).join('')));\n    _this.hasteName = name;\n    _this.platform = platform;\n    _this.supportsNativePlatform = supportsNativePlatform;\n    _this.duplicatesSet = duplicatesSet;\n    return _this;\n  }\n  return DuplicateHasteCandidatesError;\n}(_wrapNativeSuper(Error));\nfunction getPlatformMessage(platform) {\n  if (platform === (_constants || _load_constants()).default.GENERIC_PLATFORM) {\n    return 'The platform is generic (no extension).';\n  }\n  return \"The platform extension is `\".concat(platform, \"`.\");\n}\nfunction getTypeMessage(type) {\n  switch (type) {\n    case (_constants || _load_constants()).default.MODULE:\n      return 'module';\n    case (_constants || _load_constants()).default.PACKAGE:\n      return 'package';\n  }\n  return 'unknown';\n}\nModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;","map":null,"metadata":{},"sourceType":"script"}