{"ast":null,"code":"var stringWidth = require('string-width');\nvar stripAnsi = require('strip-ansi');\nvar wrap = require('wrap-ansi');\nvar align = {\n  right: alignRight,\n  center: alignCenter\n};\nvar top = 0;\nvar right = 1;\nvar bottom = 2;\nvar left = 3;\nfunction UI(opts) {\n  this.width = opts.width;\n  this.wrap = opts.wrap;\n  this.rows = [];\n}\nUI.prototype.span = function () {\n  var cols = this.div.apply(this, arguments);\n  cols.span = true;\n};\nUI.prototype.resetOutput = function () {\n  this.rows = [];\n};\nUI.prototype.div = function () {\n  if (arguments.length === 0) this.div('');\n  if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {\n    return this._applyLayoutDSL(arguments[0]);\n  }\n  var cols = [];\n  for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {\n    if (typeof arg === 'string') cols.push(this._colFromString(arg));else cols.push(arg);\n  }\n  this.rows.push(cols);\n  return cols;\n};\nUI.prototype._shouldApplyLayoutDSL = function () {\n  return arguments.length === 1 && typeof arguments[0] === 'string' && /[\\t\\n]/.test(arguments[0]);\n};\nUI.prototype._applyLayoutDSL = function (str) {\n  var _this = this;\n  var rows = str.split('\\n');\n  var leftColumnWidth = 0;\n\n  // simple heuristic for layout, make sure the\n  // second column lines up along the left-hand.\n  // don't allow the first column to take up more\n  // than 50% of the screen.\n  rows.forEach(function (row) {\n    var columns = row.split('\\t');\n    if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {\n      leftColumnWidth = Math.min(Math.floor(_this.width * 0.5), stringWidth(columns[0]));\n    }\n  });\n\n  // generate a table:\n  //  replacing ' ' with padding calculations.\n  //  using the algorithmically generated width.\n  rows.forEach(function (row) {\n    var columns = row.split('\\t');\n    _this.div.apply(_this, columns.map(function (r, i) {\n      return {\n        text: r.trim(),\n        padding: _this._measurePadding(r),\n        width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n      };\n    }));\n  });\n  return this.rows[this.rows.length - 1];\n};\nUI.prototype._colFromString = function (str) {\n  return {\n    text: str,\n    padding: this._measurePadding(str)\n  };\n};\nUI.prototype._measurePadding = function (str) {\n  // measure padding without ansi escape codes\n  var noAnsi = stripAnsi(str);\n  return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n};\nUI.prototype.toString = function () {\n  var _this = this;\n  var lines = [];\n  _this.rows.forEach(function (row, i) {\n    _this.rowToString(row, lines);\n  });\n\n  // don't display any lines with the\n  // hidden flag set.\n  lines = lines.filter(function (line) {\n    return !line.hidden;\n  });\n  return lines.map(function (line) {\n    return line.text;\n  }).join('\\n');\n};\nUI.prototype.rowToString = function (row, lines) {\n  var _this = this;\n  var padding;\n  var rrows = this._rasterize(row);\n  var str = '';\n  var ts;\n  var width;\n  var wrapWidth;\n  rrows.forEach(function (rrow, r) {\n    str = '';\n    rrow.forEach(function (col, c) {\n      ts = ''; // temporary string used during alignment/padding.\n      width = row[c].width; // the width with padding.\n      wrapWidth = _this._negatePadding(row[c]); // the width without padding.\n\n      ts += col;\n      for (var i = 0; i < wrapWidth - stringWidth(col); i++) {\n        ts += ' ';\n      }\n\n      // align the string within its column.\n      if (row[c].align && row[c].align !== 'left' && _this.wrap) {\n        ts = align[row[c].align](ts, wrapWidth);\n        if (stringWidth(ts) < wrapWidth) ts += new Array(width - stringWidth(ts)).join(' ');\n      }\n\n      // apply border and padding to string.\n      padding = row[c].padding || [0, 0, 0, 0];\n      if (padding[left]) str += new Array(padding[left] + 1).join(' ');\n      str += addBorder(row[c], ts, '| ');\n      str += ts;\n      str += addBorder(row[c], ts, ' |');\n      if (padding[right]) str += new Array(padding[right] + 1).join(' ');\n\n      // if prior row is span, try to render the\n      // current row on the prior line.\n      if (r === 0 && lines.length > 0) {\n        str = _this._renderInline(str, lines[lines.length - 1]);\n      }\n    });\n\n    // remove trailing whitespace.\n    lines.push({\n      text: str.replace(/ +$/, ''),\n      span: row.span\n    });\n  });\n  return lines;\n};\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) return '';else if (ts.trim().length) return style;else return '  ';\n  }\n  return '';\n}\n\n// if the full 'source' can render in\n// the target line, do so.\nUI.prototype._renderInline = function (source, previousLine) {\n  var leadingWhitespace = source.match(/^ */)[0].length;\n  var target = previousLine.text;\n  var targetTextWidth = stringWidth(target.trimRight());\n  if (!previousLine.span) return source;\n\n  // if we're not applying wrapping logic,\n  // just always append to the span.\n  if (!this.wrap) {\n    previousLine.hidden = true;\n    return target + source;\n  }\n  if (leadingWhitespace < targetTextWidth) return source;\n  previousLine.hidden = true;\n  return target.trimRight() + new Array(leadingWhitespace - targetTextWidth + 1).join(' ') + source.trimLeft();\n};\nUI.prototype._rasterize = function (row) {\n  var _this = this;\n  var i;\n  var rrow;\n  var rrows = [];\n  var widths = this._columnWidths(row);\n  var wrapped;\n\n  // word wrap all columns, and create\n  // a data-structure that is easy to rasterize.\n  row.forEach(function (col, c) {\n    // leave room for left and right padding.\n    col.width = widths[c];\n    if (_this.wrap) wrapped = wrap(col.text, _this._negatePadding(col), {\n      hard: true\n    }).split('\\n');else wrapped = col.text.split('\\n');\n    if (col.border) {\n      wrapped.unshift('.' + new Array(_this._negatePadding(col) + 3).join('-') + '.');\n      wrapped.push(\"'\" + new Array(_this._negatePadding(col) + 3).join('-') + \"'\");\n    }\n\n    // add top and bottom padding.\n    if (col.padding) {\n      for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('');\n      for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('');\n    }\n    wrapped.forEach(function (str, r) {\n      if (!rrows[r]) rrows.push([]);\n      rrow = rrows[r];\n      for (var i = 0; i < c; i++) {\n        if (rrow[i] === undefined) rrow.push('');\n      }\n      rrow.push(str);\n    });\n  });\n  return rrows;\n};\nUI.prototype._negatePadding = function (col) {\n  var wrapWidth = col.width;\n  if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n  if (col.border) wrapWidth -= 4;\n  return wrapWidth;\n};\nUI.prototype._columnWidths = function (row) {\n  var _this = this;\n  var widths = [];\n  var unset = row.length;\n  var unsetWidth;\n  var remainingWidth = this.width;\n\n  // column widths can be set in config.\n  row.forEach(function (col, i) {\n    if (col.width) {\n      unset--;\n      widths[i] = col.width;\n      remainingWidth -= col.width;\n    } else {\n      widths[i] = undefined;\n    }\n  });\n\n  // any unset widths should be calculated.\n  if (unset) unsetWidth = Math.floor(remainingWidth / unset);\n  widths.forEach(function (w, i) {\n    if (!_this.wrap) widths[i] = row[i].width || stringWidth(row[i].text);else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]));\n  });\n  return widths;\n};\n\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n  var padding = col.padding || [];\n  var minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n  if (col.border) minWidth += 4;\n  return minWidth;\n}\nfunction getWindowWidth() {\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) return process.stdout.columns;\n}\nfunction alignRight(str, width) {\n  str = str.trim();\n  var padding = '';\n  var strWidth = stringWidth(str);\n  if (strWidth < width) {\n    padding = new Array(width - strWidth + 1).join(' ');\n  }\n  return padding + str;\n}\nfunction alignCenter(str, width) {\n  str = str.trim();\n  var padding = '';\n  var strWidth = stringWidth(str.trim());\n  if (strWidth < width) {\n    padding = new Array(parseInt((width - strWidth) / 2, 10) + 1).join(' ');\n  }\n  return padding + str;\n}\nmodule.exports = function (opts) {\n  opts = opts || {};\n  return new UI({\n    width: (opts || {}).width || getWindowWidth() || 80,\n    wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true\n  });\n};","map":null,"metadata":{},"sourceType":"script"}