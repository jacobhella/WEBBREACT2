{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _fs;\nfunction _load_fs() {\n  return _fs = _interopRequireDefault(require('fs'));\n}\nvar _constants;\nfunction _load_constants() {\n  return _constants = require('./constants');\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar isFile = function isFile(filePath) {\n  return (_fs || _load_fs()).default.existsSync(filePath) && !(_fs || _load_fs()).default.lstatSync(filePath).isDirectory();\n};\nexports.default = function (pathToResolve, cwd) {\n  if (!(_path || _load_path()).default.isAbsolute(cwd)) {\n    throw new Error(\"\\\"cwd\\\" must be an absolute path. cwd: \".concat(cwd));\n  }\n  var absolutePath = (_path || _load_path()).default.isAbsolute(pathToResolve) ? pathToResolve : (_path || _load_path()).default.resolve(cwd, pathToResolve);\n  if (isFile(absolutePath)) {\n    return absolutePath;\n  }\n\n  // This is a guard against passing non existing path as a project/config,\n  // that will otherwise result in a very confusing situation.\n  // e.g.\n  // With a directory structure like this:\n  //   my_project/\n  //     packcage.json\n  //\n  // Passing a `my_project/some_directory_that_doesnt_exist` as a project\n  // name will resolve into a (possibly empty) `my_project/package.json` and\n  // try to run all tests it finds under `my_project` directory.\n  if (!(_fs || _load_fs()).default.existsSync(absolutePath)) {\n    throw new Error(\"Can't find a root directory while resolving a config file path.\\n\" + \"Provided path to resolve: \".concat(pathToResolve, \"\\n\") + \"cwd: \".concat(cwd));\n  }\n  return resolveConfigPathByTraversing(absolutePath, pathToResolve, cwd);\n};\nvar resolveConfigPathByTraversing = function resolveConfigPathByTraversing(pathToResolve, initialPath, cwd) {\n  var jestConfig = (_path || _load_path()).default.resolve(pathToResolve, (_constants || _load_constants()).JEST_CONFIG);\n  if (isFile(jestConfig)) {\n    return jestConfig;\n  }\n  var packageJson = (_path || _load_path()).default.resolve(pathToResolve, (_constants || _load_constants()).PACKAGE_JSON);\n  if (isFile(packageJson)) {\n    return packageJson;\n  }\n\n  // This is the system root.\n  // We tried everything, config is nowhere to be found ¯\\_(ツ)_/¯\n  if (pathToResolve === (_path || _load_path()).default.dirname(pathToResolve)) {\n    throw new Error(makeResolutionErrorMessage(initialPath, cwd));\n  }\n\n  // go up a level and try it again\n  return resolveConfigPathByTraversing((_path || _load_path()).default.dirname(pathToResolve), initialPath, cwd);\n};\nvar makeResolutionErrorMessage = function makeResolutionErrorMessage(initialPath, cwd) {\n  return 'Could not find a config file based on provided values:\\n' + \"path: \\\"\".concat(initialPath, \"\\\"\\n\") + \"cwd: \\\"\".concat(cwd, \"\\\"\\n\") + 'Config paths must be specified by either a direct path to a config\\n' + 'file, or a path to a directory. If directory is given, Jest will try to\\n' + \"traverse directory tree up, until it finds either \\\"\".concat((_constants || _load_constants()).JEST_CONFIG, \"\\\" or\\n\") + \"\\\"\".concat((_constants || _load_constants()).PACKAGE_JSON, \"\\\".\");\n};","map":null,"metadata":{},"sourceType":"script"}