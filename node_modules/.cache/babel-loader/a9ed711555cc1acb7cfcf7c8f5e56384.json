{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = simplifyAccess;\nvar _t = require(\"@babel/types\");\nvar LOGICAL_OPERATORS = _t.LOGICAL_OPERATORS,\n  assignmentExpression = _t.assignmentExpression,\n  binaryExpression = _t.binaryExpression,\n  cloneNode = _t.cloneNode,\n  identifier = _t.identifier,\n  logicalExpression = _t.logicalExpression,\n  numericLiteral = _t.numericLiteral,\n  sequenceExpression = _t.sequenceExpression,\n  unaryExpression = _t.unaryExpression;\nvar simpleAssignmentVisitor = {\n  UpdateExpression: {\n    exit: function exit(path) {\n      var scope = this.scope,\n        bindingNames = this.bindingNames,\n        includeUpdateExpression = this.includeUpdateExpression;\n      if (!includeUpdateExpression) {\n        return;\n      }\n      var arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      var localName = arg.node.name;\n      if (!bindingNames.has(localName)) return;\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {\n        var operator = path.node.operator == \"++\" ? \"+=\" : \"-=\";\n        path.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));\n      } else if (path.node.prefix) {\n        path.replaceWith(assignmentExpression(\"=\", identifier(localName), binaryExpression(path.node.operator[0], unaryExpression(\"+\", arg.node), numericLiteral(1))));\n      } else {\n        var old = path.scope.generateUidIdentifierBasedOnNode(arg.node, \"old\");\n        var varName = old.name;\n        path.scope.push({\n          id: old\n        });\n        var binary = binaryExpression(path.node.operator[0], identifier(varName), numericLiteral(1));\n        path.replaceWith(sequenceExpression([assignmentExpression(\"=\", identifier(varName), unaryExpression(\"+\", arg.node)), assignmentExpression(\"=\", cloneNode(arg.node), binary), identifier(varName)]));\n      }\n    }\n  },\n  AssignmentExpression: {\n    exit: function exit(path) {\n      var scope = this.scope,\n        seen = this.seen,\n        bindingNames = this.bindingNames;\n      if (path.node.operator === \"=\") return;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      var left = path.get(\"left\");\n      if (!left.isIdentifier()) return;\n      var localName = left.node.name;\n      if (!bindingNames.has(localName)) return;\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n      var operator = path.node.operator.slice(0, -1);\n      if (LOGICAL_OPERATORS.includes(operator)) {\n        path.replaceWith(logicalExpression(operator, path.node.left, assignmentExpression(\"=\", cloneNode(path.node.left), path.node.right)));\n      } else {\n        path.node.right = binaryExpression(operator, cloneNode(path.node.left), path.node.right);\n        path.node.operator = \"=\";\n      }\n    }\n  }\n};\nfunction simplifyAccess(path, bindingNames) {\n  var includeUpdateExpression = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  path.traverse(simpleAssignmentVisitor, {\n    scope: path.scope,\n    bindingNames: bindingNames,\n    seen: new WeakSet(),\n    includeUpdateExpression: includeUpdateExpression\n  });\n}","map":null,"metadata":{},"sourceType":"script"}