{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return']) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n  };\n}();\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _jestHasteMap;\nfunction _load_jestHasteMap() {\n  return _jestHasteMap = _interopRequireDefault(require('jest-haste-map'));\n}\nvar _jestMessageUtil;\nfunction _load_jestMessageUtil() {\n  return _jestMessageUtil = require('jest-message-util');\n}\nvar _jestResolve;\nfunction _load_jestResolve() {\n  return _jestResolve = _interopRequireDefault(require('jest-resolve'));\n}\nvar _jestUtil;\nfunction _load_jestUtil() {\n  return _jestUtil = require('jest-util');\n}\nvar _jestRegexUtil;\nfunction _load_jestRegexUtil() {\n  return _jestRegexUtil = require('jest-regex-util');\n}\nvar _jestSnapshot;\nfunction _load_jestSnapshot() {\n  return _jestSnapshot = _interopRequireDefault(require('jest-snapshot'));\n}\nvar _gracefulFs;\nfunction _load_gracefulFs() {\n  return _gracefulFs = _interopRequireDefault(require('graceful-fs'));\n}\nvar _stripBom;\nfunction _load_stripBom() {\n  return _stripBom = _interopRequireDefault(require('strip-bom'));\n}\nvar _script_transformer;\nfunction _load_script_transformer() {\n  return _script_transformer = _interopRequireDefault(require('./script_transformer'));\n}\nvar _should_instrument;\nfunction _load_should_instrument() {\n  return _should_instrument = _interopRequireDefault(require('./should_instrument'));\n}\nvar _cli;\nfunction _load_cli() {\n  return _cli = require('./cli');\n}\nvar _args;\nfunction _load_args() {\n  return _args = require('./cli/args');\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar NODE_MODULES = (_path || _load_path()).default.sep + 'node_modules' + (_path || _load_path()).default.sep;\nvar getModuleNameMapper = function getModuleNameMapper(config) {\n  if (Array.isArray(config.moduleNameMapper) && config.moduleNameMapper.length) {\n    return config.moduleNameMapper.map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2);\n      var regex = _ref2[0],\n        moduleName = _ref2[1];\n      return {\n        moduleName: moduleName,\n        regex: new RegExp(regex)\n      };\n    });\n  }\n  return null;\n};\nvar unmockRegExpCache = new WeakMap();\nvar Runtime = /*#__PURE__*/function () {\n  function Runtime(config, environment, resolver, cacheFS, coverageOptions) {\n    var _this = this;\n    _classCallCheck(this, Runtime);\n    this._cacheFS = cacheFS || Object.create(null);\n    this._config = config;\n    this._coverageOptions = coverageOptions || {\n      collectCoverage: false,\n      collectCoverageFrom: [],\n      collectCoverageOnlyFrom: null\n    };\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._explicitShouldMock = Object.create(null);\n    this._internalModuleRegistry = Object.create(null);\n    this._isCurrentlyExecutingManualMock = null;\n    this._mockFactories = Object.create(null);\n    this._mockRegistry = Object.create(null);\n    this._moduleMocker = this._environment.moduleMocker;\n    this._moduleRegistry = Object.create(null);\n    this._needsCoverageMapped = new Set();\n    this._resolver = resolver;\n    this._scriptTransformer = new (_script_transformer || _load_script_transformer()).default(config);\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = Object.create(null);\n    this._virtualMocks = Object.create(null);\n    this._mockMetaDataCache = Object.create(null);\n    this._shouldMockModuleCache = Object.create(null);\n    this._shouldUnmockTransitiveDependenciesCache = Object.create(null);\n    this._transitiveShouldMock = Object.create(null);\n    this._unmockList = unmockRegExpCache.get(config);\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(config.unmockedModulePathPatterns.join('|'));\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n    if (config.automock) {\n      config.setupFiles.forEach(function (filePath) {\n        if (filePath && filePath.includes(NODE_MODULES)) {\n          var moduleID = _this._resolver.getModuleID(_this._virtualMocks, filePath);\n          _this._transitiveShouldMock[moduleID] = false;\n        }\n      });\n    }\n    this.resetModules();\n    if (config.setupFiles.length) {\n      for (var i = 0; i < config.setupFiles.length; i++) {\n        this.requireModule(config.setupFiles[i]);\n      }\n    }\n  }\n  _createClass(Runtime, [{\n    key: \"requireModule\",\n    value: function requireModule(from, moduleName, options) {\n      var moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n      var modulePath;\n      var moduleRegistry = !options || !options.isInternalModule ? this._moduleRegistry : this._internalModuleRegistry;\n\n      // Some old tests rely on this mocking behavior. Ideally we'll change this\n      // to be more explicit.\n      var moduleResource = moduleName && this._resolver.getModule(moduleName);\n      var manualMock = moduleName && this._resolver.getMockModule(from, moduleName);\n      if ((!options || !options.isInternalModule) && !moduleResource && manualMock && manualMock !== this._isCurrentlyExecutingManualMock && this._explicitShouldMock[moduleID] !== false) {\n        modulePath = manualMock;\n      }\n      if (moduleName && this._resolver.isCoreModule(moduleName)) {\n        return this._requireCoreModule(moduleName);\n      }\n      if (!modulePath) {\n        modulePath = this._resolveModule(from, moduleName);\n      }\n      if (!moduleRegistry[modulePath]) {\n        // We must register the pre-allocated module object first so that any\n        // circular dependencies that may arise while evaluating the module can\n        var localModule = {\n          children: [],\n          exports: {},\n          filename: modulePath,\n          id: modulePath,\n          loaded: false\n        };\n        moduleRegistry[modulePath] = localModule;\n        if ((_path || _load_path()).default.extname(modulePath) === '.json') {\n          localModule.exports = this._environment.global.JSON.parse((0, (_stripBom || _load_stripBom()).default)((_gracefulFs || _load_gracefulFs()).default.readFileSync(modulePath, 'utf8')));\n        } else if ((_path || _load_path()).default.extname(modulePath) === '.node') {\n          // $FlowFixMe\n          localModule.exports = require(modulePath);\n        } else {\n          // Only include the fromPath if a moduleName is given. Else treat as root.\n          var fromPath = moduleName ? from : null;\n          this._execModule(localModule, options, moduleRegistry, fromPath);\n        }\n        localModule.loaded = true;\n      }\n      return moduleRegistry[modulePath].exports;\n    }\n  }, {\n    key: \"requireInternalModule\",\n    value: function requireInternalModule(from, to) {\n      return this.requireModule(from, to, {\n        isInternalModule: true\n      });\n    }\n  }, {\n    key: \"requireMock\",\n    value: function requireMock(from, moduleName) {\n      var moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n      if (this._mockRegistry[moduleID]) {\n        return this._mockRegistry[moduleID];\n      }\n      if (moduleID in this._mockFactories) {\n        return this._mockRegistry[moduleID] = this._mockFactories[moduleID]();\n      }\n      var manualMock = this._resolver.getMockModule(from, moduleName);\n      var modulePath;\n      if (manualMock) {\n        modulePath = this._resolveModule(from, manualMock);\n      } else {\n        modulePath = this._resolveModule(from, moduleName);\n      }\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      var moduleDir = (_path || _load_path()).default.dirname(modulePath);\n      var moduleFileName = (_path || _load_path()).default.basename(modulePath);\n      var potentialManualMock = (_path || _load_path()).default.join(moduleDir, '__mocks__', moduleFileName);\n      if ((_gracefulFs || _load_gracefulFs()).default.existsSync(potentialManualMock)) {\n        manualMock = true;\n        modulePath = potentialManualMock;\n      }\n      if (manualMock) {\n        var localModule = {\n          children: [],\n          exports: {},\n          filename: modulePath,\n          id: modulePath,\n          loaded: false\n        };\n\n        // Only include the fromPath if a moduleName is given. Else treat as root.\n        var fromPath = moduleName ? from : null;\n        this._execModule(localModule, undefined, this._mockRegistry, fromPath);\n        this._mockRegistry[moduleID] = localModule.exports;\n        localModule.loaded = true;\n      } else {\n        // Look for a real module to generate an automock from\n        this._mockRegistry[moduleID] = this._generateMock(from, moduleName);\n      }\n      return this._mockRegistry[moduleID];\n    }\n  }, {\n    key: \"requireModuleOrMock\",\n    value: function requireModuleOrMock(from, moduleName) {\n      if (this._shouldMock(from, moduleName)) {\n        return this.requireMock(from, moduleName);\n      } else {\n        return this.requireModule(from, moduleName);\n      }\n    }\n  }, {\n    key: \"resetModules\",\n    value: function resetModules() {\n      this._mockRegistry = Object.create(null);\n      this._moduleRegistry = Object.create(null);\n      if (this._environment && this._environment.global) {\n        var envGlobal = this._environment.global;\n        Object.keys(envGlobal).forEach(function (key) {\n          var globalMock = envGlobal[key];\n          if (typeof globalMock === 'object' && globalMock !== null || typeof globalMock === 'function') {\n            globalMock._isMockFunction && globalMock.mockClear();\n          }\n        });\n        if (envGlobal.mockClearTimers) {\n          envGlobal.mockClearTimers();\n        }\n      }\n    }\n  }, {\n    key: \"getAllCoverageInfoCopy\",\n    value: function getAllCoverageInfoCopy() {\n      return (0, (_jestUtil || _load_jestUtil()).deepCyclicCopy)(this._environment.global.__coverage__);\n    }\n  }, {\n    key: \"getSourceMapInfo\",\n    value: function getSourceMapInfo(coveredFiles) {\n      var _this2 = this;\n      return Object.keys(this._sourceMapRegistry).reduce(function (result, sourcePath) {\n        if (coveredFiles.has(sourcePath) && _this2._needsCoverageMapped.has(sourcePath) && (_gracefulFs || _load_gracefulFs()).default.existsSync(_this2._sourceMapRegistry[sourcePath])) {\n          result[sourcePath] = _this2._sourceMapRegistry[sourcePath];\n        }\n        return result;\n      }, {});\n    }\n  }, {\n    key: \"getSourceMaps\",\n    value: function getSourceMaps() {\n      return this._sourceMapRegistry;\n    }\n  }, {\n    key: \"setMock\",\n    value: function setMock(from, moduleName, mockFactory, options) {\n      if (options && options.virtual) {\n        var mockPath = this._resolver.getModulePath(from, moduleName);\n        this._virtualMocks[mockPath] = true;\n      }\n      var moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n      this._explicitShouldMock[moduleID] = true;\n      this._mockFactories[moduleID] = mockFactory;\n    }\n  }, {\n    key: \"restoreAllMocks\",\n    value: function restoreAllMocks() {\n      this._moduleMocker.restoreAllMocks();\n    }\n  }, {\n    key: \"resetAllMocks\",\n    value: function resetAllMocks() {\n      this._moduleMocker.resetAllMocks();\n    }\n  }, {\n    key: \"clearAllMocks\",\n    value: function clearAllMocks() {\n      this._moduleMocker.clearAllMocks();\n    }\n  }, {\n    key: \"_resolveModule\",\n    value: function _resolveModule(from, to) {\n      return to ? this._resolver.resolveModule(from, to) : from;\n    }\n  }, {\n    key: \"_requireResolve\",\n    value: function _requireResolve(from, moduleName) {\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var paths = _ref3.paths;\n      if (moduleName == null) {\n        throw new Error('The first argument to require.resolve must be a string. Received null or undefined.');\n      }\n      if (paths) {\n        var _iterator = _createForOfIteratorHelper(paths),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var p = _step.value;\n            var absolutePath = (_path || _load_path()).default.resolve(from, '..', p);\n            var _module = this._resolver.resolveModuleFromDirIfExists(absolutePath, moduleName,\n            // required to also resolve files without leading './' directly in the path\n            {\n              paths: [absolutePath]\n            });\n            if (_module) {\n              return _module;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        throw new Error(\"Cannot resolve module '\".concat(moduleName, \"' from paths ['\").concat(paths.join(\"', '\"), \"'] from \").concat(from));\n      }\n      return this._resolveModule(from, moduleName);\n    }\n  }, {\n    key: \"_requireResolvePaths\",\n    value: function _requireResolvePaths(from, moduleName) {\n      if (moduleName == null) {\n        throw new Error('The first argument to require.resolve.paths must be a string. Received null or undefined.');\n      }\n      if (!moduleName.length) {\n        throw new Error('The first argument to require.resolve.paths must not be the empty string.');\n      }\n      if (moduleName[0] === '.') {\n        return [(_path || _load_path()).default.resolve(from, '..')];\n      }\n      if (this._resolver.isCoreModule(moduleName)) {\n        return null;\n      }\n      return this._resolver.getModulePaths((_path || _load_path()).default.resolve(from, '..'));\n    }\n  }, {\n    key: \"_execModule\",\n    value: function _execModule(localModule, options, moduleRegistry, from) {\n      // If the environment was disposed, prevent this module from being executed.\n      if (!this._environment.global) {\n        return;\n      }\n      var isInternalModule = !!(options && options.isInternalModule);\n      var filename = localModule.filename;\n      var lastExecutingModulePath = this._currentlyExecutingModulePath;\n      this._currentlyExecutingModulePath = filename;\n      var origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n      this._isCurrentlyExecutingManualMock = filename;\n      var dirname = (_path || _load_path()).default.dirname(filename);\n      localModule.children = [];\n      Object.defineProperty(localModule, 'parent',\n      // https://github.com/facebook/flow/issues/285#issuecomment-270810619\n      {\n        enumerable: true,\n        get: function get() {\n          var key = from || '';\n          return moduleRegistry[key] || null;\n        }\n      });\n      localModule.paths = this._resolver.getModulePaths(dirname);\n      Object.defineProperty(localModule, 'require', {\n        value: this._createRequireImplementation(localModule, options)\n      });\n      var transformedFile = this._scriptTransformer.transform(filename, {\n        collectCoverage: this._coverageOptions.collectCoverage,\n        collectCoverageFrom: this._coverageOptions.collectCoverageFrom,\n        collectCoverageOnlyFrom: this._coverageOptions.collectCoverageOnlyFrom,\n        isInternalModule: isInternalModule\n      }, this._cacheFS[filename]);\n      if (transformedFile.sourceMapPath) {\n        this._sourceMapRegistry[filename] = transformedFile.sourceMapPath;\n        if (transformedFile.mapCoverage) {\n          this._needsCoverageMapped.add(filename);\n        }\n      }\n      var runScript = this._environment.runScript(transformedFile.script);\n      if (runScript === null) {\n        var originalStack = new ReferenceError('You are trying to `import` a file after the Jest environment has been torn down.').stack.split('\\n')\n        // Remove this file from the stack (jest-message-utils will keep one line)\n        .filter(function (line) {\n          return line.indexOf(__filename) === -1;\n        }).join('\\n');\n        var _separateMessageFromS = (0, (_jestMessageUtil || _load_jestMessageUtil()).separateMessageFromStack)(originalStack);\n        var message = _separateMessageFromS.message,\n          stack = _separateMessageFromS.stack;\n        console.error(\"\\n\".concat(message, \"\\n\") + (0, (_jestMessageUtil || _load_jestMessageUtil()).formatStackTrace)(stack, this._config, {\n          noStackTrace: false\n        }));\n        process.exitCode = 1;\n        return;\n      }\n      var wrapper = runScript[(_script_transformer || _load_script_transformer()).default.EVAL_RESULT_VARIABLE];\n      wrapper.call(localModule.exports,\n      // module context\n      localModule,\n      // module object\n      localModule.exports,\n      // module exports\n      localModule.require,\n      // require implementation\n      dirname,\n      // __dirname\n      filename,\n      // __filename\n      this._environment.global,\n      // global object\n      this._createJestObjectFor(filename,\n      // $FlowFixMe\n      localModule.require) // jest object\n      );\n\n      this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n      this._currentlyExecutingModulePath = lastExecutingModulePath;\n    }\n  }, {\n    key: \"_requireCoreModule\",\n    value: function _requireCoreModule(moduleName) {\n      if (moduleName === 'process') {\n        return this._environment.global.process;\n      }\n\n      // $FlowFixMe\n      return require(moduleName);\n    }\n  }, {\n    key: \"_generateMock\",\n    value: function _generateMock(from, moduleName) {\n      var modulePath = this._resolveModule(from, moduleName);\n      if (!(modulePath in this._mockMetaDataCache)) {\n        // This allows us to handle circular dependencies while generating an\n        // automock\n        this._mockMetaDataCache[modulePath] = this._moduleMocker.getMetadata({});\n\n        // In order to avoid it being possible for automocking to potentially\n        // cause side-effects within the module environment, we need to execute\n        // the module in isolation. This could cause issues if the module being\n        // mocked has calls into side-effectful APIs on another module.\n        var origMockRegistry = this._mockRegistry;\n        var origModuleRegistry = this._moduleRegistry;\n        this._mockRegistry = Object.create(null);\n        this._moduleRegistry = Object.create(null);\n        var moduleExports = this.requireModule(from, moduleName);\n\n        // Restore the \"real\" module/mock registries\n        this._mockRegistry = origMockRegistry;\n        this._moduleRegistry = origModuleRegistry;\n        var mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n        if (mockMetadata == null) {\n          throw new Error(\"Failed to get mock metadata: \".concat(modulePath, \"\\n\\n\") + \"See: https://jestjs.io/docs/manual-mocks.html#content\");\n        }\n        this._mockMetaDataCache[modulePath] = mockMetadata;\n      }\n      return this._moduleMocker.generateFromMetadata(this._mockMetaDataCache[modulePath]);\n    }\n  }, {\n    key: \"_shouldMock\",\n    value: function _shouldMock(from, moduleName) {\n      var mockPath = this._resolver.getModulePath(from, moduleName);\n      if (mockPath in this._virtualMocks) {\n        return true;\n      }\n      var explicitShouldMock = this._explicitShouldMock;\n      var moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n      var key = from + (_path || _load_path()).default.delimiter + moduleID;\n      if (moduleID in explicitShouldMock) {\n        return explicitShouldMock[moduleID];\n      }\n      if (!this._shouldAutoMock || this._resolver.isCoreModule(moduleName) || this._shouldUnmockTransitiveDependenciesCache[key]) {\n        return false;\n      }\n      if (moduleID in this._shouldMockModuleCache) {\n        return this._shouldMockModuleCache[moduleID];\n      }\n      var modulePath;\n      try {\n        modulePath = this._resolveModule(from, moduleName);\n      } catch (e) {\n        var manualMock = this._resolver.getMockModule(from, moduleName);\n        if (manualMock) {\n          this._shouldMockModuleCache[moduleID] = true;\n          return true;\n        }\n        throw e;\n      }\n      if (this._unmockList && this._unmockList.test(modulePath)) {\n        this._shouldMockModuleCache[moduleID] = false;\n        return false;\n      }\n\n      // transitive unmocking for package managers that store flat packages (npm3)\n      var currentModuleID = this._resolver.getModuleID(this._virtualMocks, from);\n      if (this._transitiveShouldMock[currentModuleID] === false || from.includes(NODE_MODULES) && modulePath.includes(NODE_MODULES) && (this._unmockList && this._unmockList.test(from) || explicitShouldMock[currentModuleID] === false)) {\n        this._transitiveShouldMock[moduleID] = false;\n        this._shouldUnmockTransitiveDependenciesCache[key] = true;\n        return false;\n      }\n      return this._shouldMockModuleCache[moduleID] = true;\n    }\n  }, {\n    key: \"_createRequireImplementation\",\n    value: function _createRequireImplementation(from, options) {\n      var _this3 = this;\n      var moduleRequire = options && options.isInternalModule ? function (moduleName) {\n        return _this3.requireInternalModule(from.filename, moduleName);\n      } : this.requireModuleOrMock.bind(this, from.filename);\n      moduleRequire.cache = Object.create(null);\n      moduleRequire.extensions = Object.create(null);\n      moduleRequire.requireActual = this.requireModule.bind(this, from.filename);\n      moduleRequire.requireMock = this.requireMock.bind(this, from.filename);\n      moduleRequire.resolve = function (moduleName, options) {\n        return _this3._requireResolve(from.filename, moduleName, options);\n      };\n      moduleRequire.resolve.paths = function (moduleName) {\n        return _this3._requireResolvePaths(from.filename, moduleName);\n      };\n      Object.defineProperty(moduleRequire, 'main', {\n        enumerable: true,\n        get: function get() {\n          var mainModule = from.parent;\n          while (mainModule && mainModule.parent && mainModule.id !== mainModule.parent.id) {\n            mainModule = mainModule.parent;\n          }\n          return mainModule;\n        }\n      });\n      return moduleRequire;\n    }\n  }, {\n    key: \"_createJestObjectFor\",\n    value: function _createJestObjectFor(from, localRequire) {\n      var _this4 = this;\n      var disableAutomock = function disableAutomock() {\n        _this4._shouldAutoMock = false;\n        return jestObject;\n      };\n      var enableAutomock = function enableAutomock() {\n        _this4._shouldAutoMock = true;\n        return jestObject;\n      };\n      var unmock = function unmock(moduleName) {\n        var moduleID = _this4._resolver.getModuleID(_this4._virtualMocks, from, moduleName);\n        _this4._explicitShouldMock[moduleID] = false;\n        return jestObject;\n      };\n      var deepUnmock = function deepUnmock(moduleName) {\n        var moduleID = _this4._resolver.getModuleID(_this4._virtualMocks, from, moduleName);\n        _this4._explicitShouldMock[moduleID] = false;\n        _this4._transitiveShouldMock[moduleID] = false;\n        return jestObject;\n      };\n      var mock = function mock(moduleName, mockFactory, options) {\n        if (mockFactory !== undefined) {\n          return setMockFactory(moduleName, mockFactory, options);\n        }\n        var moduleID = _this4._resolver.getModuleID(_this4._virtualMocks, from, moduleName);\n        _this4._explicitShouldMock[moduleID] = true;\n        return jestObject;\n      };\n      var setMockFactory = function setMockFactory(moduleName, mockFactory, options) {\n        _this4.setMock(from, moduleName, mockFactory, options);\n        return jestObject;\n      };\n      var clearAllMocks = function clearAllMocks() {\n        _this4.clearAllMocks();\n        return jestObject;\n      };\n      var resetAllMocks = function resetAllMocks() {\n        _this4.resetAllMocks();\n        return jestObject;\n      };\n      var restoreAllMocks = function restoreAllMocks() {\n        _this4.restoreAllMocks();\n        return jestObject;\n      };\n      var useFakeTimers = function useFakeTimers() {\n        _this4._environment.fakeTimers.useFakeTimers();\n        return jestObject;\n      };\n      var useRealTimers = function useRealTimers() {\n        _this4._environment.fakeTimers.useRealTimers();\n        return jestObject;\n      };\n      var resetModules = function resetModules() {\n        _this4.resetModules();\n        return jestObject;\n      };\n      var fn = this._moduleMocker.fn.bind(this._moduleMocker);\n      var spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n      var setTimeout = function setTimeout(timeout) {\n        _this4._environment.global.jasmine ? _this4._environment.global.jasmine._DEFAULT_TIMEOUT_INTERVAL = timeout : _this4._environment.global[Symbol.for('TEST_TIMEOUT_SYMBOL')] = timeout;\n        return jestObject;\n      };\n      var retryTimes = function retryTimes(numTestRetries) {\n        _this4._environment.global[Symbol.for('RETRY_TIMES')] = numTestRetries;\n        return jestObject;\n      };\n      var jestObject = {\n        addMatchers: function addMatchers(matchers) {\n          return _this4._environment.global.jasmine.addMatchers(matchers);\n        },\n        advanceTimersByTime: function advanceTimersByTime(msToRun) {\n          return _this4._environment.fakeTimers.advanceTimersByTime(msToRun);\n        },\n        autoMockOff: disableAutomock,\n        autoMockOn: enableAutomock,\n        clearAllMocks: clearAllMocks,\n        clearAllTimers: function clearAllTimers() {\n          return _this4._environment.fakeTimers.clearAllTimers();\n        },\n        deepUnmock: deepUnmock,\n        disableAutomock: disableAutomock,\n        doMock: mock,\n        dontMock: unmock,\n        enableAutomock: enableAutomock,\n        fn: fn,\n        genMockFromModule: function genMockFromModule(moduleName) {\n          return _this4._generateMock(from, moduleName);\n        },\n        isMockFunction: this._moduleMocker.isMockFunction,\n        mock: mock,\n        requireActual: localRequire.requireActual,\n        requireMock: localRequire.requireMock,\n        resetAllMocks: resetAllMocks,\n        resetModuleRegistry: resetModules,\n        resetModules: resetModules,\n        restoreAllMocks: restoreAllMocks,\n        retryTimes: retryTimes,\n        runAllImmediates: function runAllImmediates() {\n          return _this4._environment.fakeTimers.runAllImmediates();\n        },\n        runAllTicks: function runAllTicks() {\n          return _this4._environment.fakeTimers.runAllTicks();\n        },\n        runAllTimers: function runAllTimers() {\n          return _this4._environment.fakeTimers.runAllTimers();\n        },\n        runOnlyPendingTimers: function runOnlyPendingTimers() {\n          return _this4._environment.fakeTimers.runOnlyPendingTimers();\n        },\n        runTimersToTime: function runTimersToTime(msToRun) {\n          return _this4._environment.fakeTimers.advanceTimersByTime(msToRun);\n        },\n        setMock: function setMock(moduleName, mock) {\n          return setMockFactory(moduleName, function () {\n            return mock;\n          });\n        },\n        setTimeout: setTimeout,\n        spyOn: spyOn,\n        unmock: unmock,\n        useFakeTimers: useFakeTimers,\n        useRealTimers: useRealTimers\n      };\n      return jestObject;\n    }\n  }], [{\n    key: \"shouldInstrument\",\n    value: function shouldInstrument(filename, options, config) {\n      return (0, (_should_instrument || _load_should_instrument()).default)(filename, {\n        collectCoverage: options.collectCoverage,\n        collectCoverageFrom: options.collectCoverageFrom,\n        collectCoverageOnlyFrom: options.collectCoverageOnlyFrom\n      }, config);\n    }\n  }, {\n    key: \"createContext\",\n    value: function createContext(config, options) {\n      (0, (_jestUtil || _load_jestUtil()).createDirectory)(config.cacheDirectory);\n      var instance = Runtime.createHasteMap(config, {\n        console: options.console,\n        maxWorkers: options.maxWorkers,\n        resetCache: !config.cache,\n        watch: options.watch,\n        watchman: options.watchman\n      });\n      return instance.build().then(function (hasteMap) {\n        return {\n          config: config,\n          hasteFS: hasteMap.hasteFS,\n          moduleMap: hasteMap.moduleMap,\n          resolver: Runtime.createResolver(config, hasteMap.moduleMap)\n        };\n      }, function (error) {\n        throw error;\n      });\n    }\n  }, {\n    key: \"createHasteMap\",\n    value: function createHasteMap(config, options) {\n      var ignorePattern = new RegExp([config.cacheDirectory].concat(config.modulePathIgnorePatterns).join('|'));\n      return new (_jestHasteMap || _load_jestHasteMap()).default({\n        cacheDirectory: config.cacheDirectory,\n        console: options && options.console,\n        extensions: [(_jestSnapshot || _load_jestSnapshot()).default.EXTENSION].concat(config.moduleFileExtensions),\n        hasteImplModulePath: config.haste.hasteImplModulePath,\n        ignorePattern: ignorePattern,\n        maxWorkers: options && options.maxWorkers || 1,\n        mocksPattern: (0, (_jestRegexUtil || _load_jestRegexUtil()).escapePathForRegex)((_path || _load_path()).default.sep + '__mocks__' + (_path || _load_path()).default.sep),\n        name: config.name,\n        platforms: config.haste.platforms || ['ios', 'android'],\n        providesModuleNodeModules: config.haste.providesModuleNodeModules,\n        resetCache: options && options.resetCache,\n        retainAllFiles: false,\n        roots: config.roots,\n        useWatchman: options && options.watchman,\n        watch: options && options.watch\n      });\n    }\n  }, {\n    key: \"createResolver\",\n    value: function createResolver(config, moduleMap) {\n      return new (_jestResolve || _load_jestResolve()).default(moduleMap, {\n        browser: config.browser,\n        defaultPlatform: config.haste.defaultPlatform,\n        extensions: config.moduleFileExtensions.map(function (extension) {\n          return '.' + extension;\n        }),\n        hasCoreModules: true,\n        moduleDirectories: config.moduleDirectories,\n        moduleNameMapper: getModuleNameMapper(config),\n        modulePaths: config.modulePaths,\n        platforms: config.haste.platforms,\n        resolver: config.resolver,\n        rootDir: config.rootDir\n      });\n    }\n  }, {\n    key: \"runCLI\",\n    value: function runCLI(args, info) {\n      return (0, (_cli || _load_cli()).run)(args, info);\n    }\n  }, {\n    key: \"getCLIOptions\",\n    value: function getCLIOptions() {\n      return (_args || _load_args()).options;\n    }\n  }]);\n  return Runtime;\n}();\nRuntime.ScriptTransformer = (_script_transformer || _load_script_transformer()).default;\nmodule.exports = Runtime;","map":null,"metadata":{},"sourceType":"script"}