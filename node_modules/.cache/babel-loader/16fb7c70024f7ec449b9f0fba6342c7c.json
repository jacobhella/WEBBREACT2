{"ast":null,"code":"/**\n * Copyright (c) 2017-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _child_process;\nfunction _load_child_process() {\n  return _child_process = _interopRequireDefault(require('child_process'));\n}\nvar _types;\nfunction _load_types() {\n  return _types = require('./types');\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * This class wraps the child process and provides a nice interface to\n * communicate with. It takes care of:\n *\n *  - Re-spawning the process if it dies.\n *  - Queues calls while the worker is busy.\n *  - Re-sends the requests if the worker blew up.\n *\n * The reason for queueing them here (since childProcess.send also has an\n * internal queue) is because the worker could be doing asynchronous work, and\n * this would lead to the child process to read its receiving buffer and start a\n * second call. By queueing calls here, we don't send the next call to the\n * children until we receive the result of the previous one.\n *\n * As soon as a request starts to be processed by a worker, its \"processed\"\n * field is changed to \"true\", so that other workers which might encounter the\n * same call skip it.\n */\nexports.default = /*#__PURE__*/function () {\n  function _class(options) {\n    _classCallCheck(this, _class);\n    this._options = options;\n    this._queue = null;\n    this._initialize();\n  }\n  _createClass(_class, [{\n    key: \"getStdout\",\n    value: function getStdout() {\n      return this._child.stdout;\n    }\n  }, {\n    key: \"getStderr\",\n    value: function getStderr() {\n      return this._child.stderr;\n    }\n  }, {\n    key: \"send\",\n    value: function send(request, onProcessStart, onProcessEnd) {\n      var item = {\n        next: null,\n        onProcessEnd: onProcessEnd,\n        onProcessStart: onProcessStart,\n        request: request\n      };\n      if (this._last) {\n        this._last.next = item;\n      } else {\n        this._queue = item;\n      }\n      this._last = item;\n      this._process();\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var child = (_child_process || _load_child_process()).default.fork(require.resolve('./child'),\n      // $FlowFixMe: Flow does not work well with Object.assign.\n      Object.assign({\n        cwd: process.cwd(),\n        env: Object.assign({}, process.env, {\n          JEST_WORKER_ID: this._options.workerId\n        }),\n        // Suppress --debug / --inspect flags while preserving others (like --harmony).\n        execArgv: process.execArgv.filter(function (v) {\n          return !/^--(debug|inspect)/.test(v);\n        }),\n        silent: true\n      }, this._options.forkOptions));\n      child.on('message', this._receive.bind(this));\n      child.on('exit', this._exit.bind(this));\n\n      // $FlowFixMe: wrong \"ChildProcess.send\" signature.\n      child.send([(_types || _load_types()).CHILD_MESSAGE_INITIALIZE, false, this._options.workerPath]);\n      this._retries++;\n      this._child = child;\n      this._busy = false;\n\n      // If we exceeded the amount of retries, we will emulate an error reply\n      // coming from the child. This avoids code duplication related with cleaning\n      // the queue, and scheduling the next call.\n      if (this._retries > this._options.maxRetries) {\n        var error = new Error('Call retries were exceeded');\n        this._receive([(_types || _load_types()).PARENT_MESSAGE_ERROR, error.name, error.message, error.stack, {\n          type: 'WorkerError'\n        }]);\n      }\n    }\n  }, {\n    key: \"_process\",\n    value: function _process() {\n      if (this._busy) {\n        return;\n      }\n      var item = this._queue;\n\n      // Calls in the queue might have already been processed by another worker,\n      // so we have to skip them.\n      while (item && item.request[1]) {\n        item = item.next;\n      }\n      this._queue = item;\n      if (item) {\n        // Flag the call as processed, so that other workers know that they don't\n        // have to process it as well.\n        item.request[1] = true;\n\n        // Tell the parent that this item is starting to be processed.\n        item.onProcessStart(this);\n        this._retries = 0;\n        this._busy = true;\n\n        // $FlowFixMe: wrong \"ChildProcess.send\" signature.\n        this._child.send(item.request);\n      } else {\n        this._last = item;\n      }\n    }\n  }, {\n    key: \"_receive\",\n    value: function _receive(response /* Should be ParentMessage */) {\n      var item = this._queue;\n      if (!item) {\n        throw new TypeError('Unexpected response with an empty queue');\n      }\n      var onProcessEnd = item.onProcessEnd;\n      this._busy = false;\n      this._process();\n      switch (response[0]) {\n        case (_types || _load_types()).PARENT_MESSAGE_OK:\n          onProcessEnd(null, response[1]);\n          break;\n        case (_types || _load_types()).PARENT_MESSAGE_ERROR:\n          var error = response[4];\n          if (error != null && typeof error === 'object') {\n            var extra = error;\n            var NativeCtor = global[response[1]];\n            var Ctor = typeof NativeCtor === 'function' ? NativeCtor : Error;\n            error = new Ctor(response[2]);\n            // $FlowFixMe: adding custom properties to errors.\n            error.type = response[1];\n            error.stack = response[3];\n            for (var key in extra) {\n              // $FlowFixMe: adding custom properties to errors.\n              error[key] = extra[key];\n            }\n          }\n          onProcessEnd(error, null);\n          break;\n        default:\n          throw new TypeError('Unexpected response from worker: ' + response[0]);\n      }\n    }\n  }, {\n    key: \"_exit\",\n    value: function _exit(exitCode) {\n      if (exitCode !== 0) {\n        this._initialize();\n      }\n    }\n  }]);\n  return _class;\n}();","map":null,"metadata":{},"sourceType":"script"}