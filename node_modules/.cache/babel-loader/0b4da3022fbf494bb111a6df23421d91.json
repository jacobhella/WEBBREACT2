{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _jestMessageUtil;\nfunction _load_jestMessageUtil() {\n  return _jestMessageUtil = require('jest-message-util');\n}\nvar _set_global;\nfunction _load_set_global() {\n  return _set_global = _interopRequireDefault(require('./set_global'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * We don't know the type of arguments for a callback ahead of time which is why\n * we are disabling the flowtype/no-weak-types rule here.\n */\n\n/* eslint-disable flowtype/no-weak-types */\n\n/* eslint-enable flowtype/no-weak-types */\n\nvar MS_IN_A_YEAR = 31536000000;\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\nvar FakeTimers = /*#__PURE__*/function () {\n  function FakeTimers(_ref) {\n    var _this = this;\n    _classCallCheck(this, FakeTimers);\n    var global = _ref.global,\n      moduleMocker = _ref.moduleMocker,\n      timerConfig = _ref.timerConfig,\n      config = _ref.config,\n      maxLoops = _ref.maxLoops;\n    this._global = global;\n    this._timerConfig = timerConfig;\n    this._config = config;\n    this._maxLoops = maxLoops || 100000;\n    this._uuidCounter = 1;\n    this._moduleMocker = moduleMocker;\n\n    // Store original timer APIs for future reference\n    this._timerAPIs = {\n      clearImmediate: global.clearImmediate,\n      clearInterval: global.clearInterval,\n      clearTimeout: global.clearTimeout,\n      nextTick: global.process && global.process.nextTick,\n      setImmediate: global.setImmediate,\n      setInterval: global.setInterval,\n      setTimeout: global.setTimeout\n    };\n    this.reset();\n    this._createMocks();\n\n    // These globally-accessible function are now deprecated!\n    // They will go away very soon, so do not use them!\n    // Instead, use the versions available on the `jest` object\n    global.mockRunTicksRepeatedly = this.runAllTicks.bind(this);\n    global.mockRunTimersOnce = this.runOnlyPendingTimers.bind(this);\n    global.mockAdvanceTimersByTime = this.advanceTimersByTime.bind(this);\n    global.mockRunTimersRepeatedly = this.runAllTimers.bind(this);\n    global.mockClearTimers = this.clearAllTimers.bind(this);\n    global.mockGetTimersCount = function () {\n      return Object.keys(_this._timers).length;\n    };\n  }\n  _createClass(FakeTimers, [{\n    key: \"clearAllTimers\",\n    value: function clearAllTimers() {\n      var _this2 = this;\n      this._immediates.forEach(function (immediate) {\n        return _this2._fakeClearImmediate(immediate.uuid);\n      });\n      for (var uuid in this._timers) {\n        delete this._timers[uuid];\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._disposed = true;\n      this.clearAllTimers();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._cancelledTicks = {};\n      this._cancelledImmediates = {};\n      this._now = 0;\n      this._ticks = [];\n      this._immediates = [];\n      this._timers = {};\n    }\n  }, {\n    key: \"runAllTicks\",\n    value: function runAllTicks() {\n      this._checkFakeTimers();\n      // Only run a generous number of ticks and then bail.\n      // This is just to help avoid recursive loops\n      var i;\n      for (i = 0; i < this._maxLoops; i++) {\n        var tick = this._ticks.shift();\n        if (tick === undefined) {\n          break;\n        }\n        if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n          // Callback may throw, so update the map prior calling.\n          this._cancelledTicks[tick.uuid] = true;\n          tick.callback();\n        }\n      }\n      if (i === this._maxLoops) {\n        throw new Error('Ran ' + this._maxLoops + ' ticks, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n      }\n    }\n  }, {\n    key: \"runAllImmediates\",\n    value: function runAllImmediates() {\n      this._checkFakeTimers();\n      // Only run a generous number of immediates and then bail.\n      var i;\n      for (i = 0; i < this._maxLoops; i++) {\n        var immediate = this._immediates.shift();\n        if (immediate === undefined) {\n          break;\n        }\n        this._runImmediate(immediate);\n      }\n      if (i === this._maxLoops) {\n        throw new Error('Ran ' + this._maxLoops + ' immediates, and there are still more! Assuming ' + \"we've hit an infinite recursion and bailing out...\");\n      }\n    }\n  }, {\n    key: \"_runImmediate\",\n    value: function _runImmediate(immediate) {\n      if (!this._cancelledImmediates.hasOwnProperty(immediate.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledImmediates[immediate.uuid] = true;\n        immediate.callback();\n      }\n    }\n  }, {\n    key: \"runAllTimers\",\n    value: function runAllTimers() {\n      this._checkFakeTimers();\n      this.runAllTicks();\n      this.runAllImmediates();\n\n      // Only run a generous number of timers and then bail.\n      // This is just to help avoid recursive loops\n      var i;\n      for (i = 0; i < this._maxLoops; i++) {\n        var nextTimerHandle = this._getNextTimerHandle();\n\n        // If there are no more timer handles, stop!\n        if (nextTimerHandle === null) {\n          break;\n        }\n        this._runTimerHandle(nextTimerHandle);\n\n        // Some of the immediate calls could be enqueued\n        // during the previous handling of the timers, we should\n        // run them as well.\n        if (this._immediates.length) {\n          this.runAllImmediates();\n        }\n        if (this._ticks.length) {\n          this.runAllTicks();\n        }\n      }\n      if (i === this._maxLoops) {\n        throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n      }\n    }\n  }, {\n    key: \"runOnlyPendingTimers\",\n    value: function runOnlyPendingTimers() {\n      var timers = Object.assign({}, this._timers);\n      this._checkFakeTimers();\n      this._immediates.forEach(this._runImmediate, this);\n      Object.keys(timers).sort(function (left, right) {\n        return timers[left].expiry - timers[right].expiry;\n      }).forEach(this._runTimerHandle, this);\n    }\n  }, {\n    key: \"advanceTimersByTime\",\n    value: function advanceTimersByTime(msToRun) {\n      this._checkFakeTimers();\n      // Only run a generous number of timers and then bail.\n      // This is just to help avoid recursive loops\n      var i;\n      for (i = 0; i < this._maxLoops; i++) {\n        var timerHandle = this._getNextTimerHandle();\n\n        // If there are no more timer handles, stop!\n        if (timerHandle === null) {\n          break;\n        }\n        var nextTimerExpiry = this._timers[timerHandle].expiry;\n        if (this._now + msToRun < nextTimerExpiry) {\n          // There are no timers between now and the target we're running to, so\n          // adjust our time cursor and quit\n          this._now += msToRun;\n          break;\n        } else {\n          msToRun -= nextTimerExpiry - this._now;\n          this._now = nextTimerExpiry;\n          this._runTimerHandle(timerHandle);\n        }\n      }\n      if (i === this._maxLoops) {\n        throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n      }\n    }\n  }, {\n    key: \"runWithRealTimers\",\n    value: function runWithRealTimers(cb) {\n      var prevClearImmediate = this._global.clearImmediate;\n      var prevClearInterval = this._global.clearInterval;\n      var prevClearTimeout = this._global.clearTimeout;\n      var prevNextTick = this._global.process.nextTick;\n      var prevSetImmediate = this._global.setImmediate;\n      var prevSetInterval = this._global.setInterval;\n      var prevSetTimeout = this._global.setTimeout;\n      this.useRealTimers();\n      var cbErr = null;\n      var errThrown = false;\n      try {\n        cb();\n      } catch (e) {\n        errThrown = true;\n        cbErr = e;\n      }\n      this._global.clearImmediate = prevClearImmediate;\n      this._global.clearInterval = prevClearInterval;\n      this._global.clearTimeout = prevClearTimeout;\n      this._global.process.nextTick = prevNextTick;\n      this._global.setImmediate = prevSetImmediate;\n      this._global.setInterval = prevSetInterval;\n      this._global.setTimeout = prevSetTimeout;\n      if (errThrown) {\n        throw cbErr;\n      }\n    }\n  }, {\n    key: \"useRealTimers\",\n    value: function useRealTimers() {\n      var global = this._global;\n      (0, (_set_global || _load_set_global()).default)(global, 'clearImmediate', this._timerAPIs.clearImmediate);\n      (0, (_set_global || _load_set_global()).default)(global, 'clearInterval', this._timerAPIs.clearInterval);\n      (0, (_set_global || _load_set_global()).default)(global, 'clearTimeout', this._timerAPIs.clearTimeout);\n      (0, (_set_global || _load_set_global()).default)(global, 'setImmediate', this._timerAPIs.setImmediate);\n      (0, (_set_global || _load_set_global()).default)(global, 'setInterval', this._timerAPIs.setInterval);\n      (0, (_set_global || _load_set_global()).default)(global, 'setTimeout', this._timerAPIs.setTimeout);\n      global.process.nextTick = this._timerAPIs.nextTick;\n    }\n  }, {\n    key: \"useFakeTimers\",\n    value: function useFakeTimers() {\n      this._createMocks();\n      var global = this._global;\n      (0, (_set_global || _load_set_global()).default)(global, 'clearImmediate', this._fakeTimerAPIs.clearImmediate);\n      (0, (_set_global || _load_set_global()).default)(global, 'clearInterval', this._fakeTimerAPIs.clearInterval);\n      (0, (_set_global || _load_set_global()).default)(global, 'clearTimeout', this._fakeTimerAPIs.clearTimeout);\n      (0, (_set_global || _load_set_global()).default)(global, 'setImmediate', this._fakeTimerAPIs.setImmediate);\n      (0, (_set_global || _load_set_global()).default)(global, 'setInterval', this._fakeTimerAPIs.setInterval);\n      (0, (_set_global || _load_set_global()).default)(global, 'setTimeout', this._fakeTimerAPIs.setTimeout);\n      global.process.nextTick = this._fakeTimerAPIs.nextTick;\n    }\n  }, {\n    key: \"_checkFakeTimers\",\n    value: function _checkFakeTimers() {\n      if (this._global.setTimeout !== this._fakeTimerAPIs.setTimeout) {\n        this._global.console.warn(\"A function to advance timers was called but the timers API is not \" + \"mocked with fake timers. Call `jest.useFakeTimers()` in this \" + \"test or enable fake timers globally by setting \" + \"`\\\"timers\\\": \\\"fake\\\"` in \" + \"the configuration file. This warning is likely a result of a \" + \"default configuration change in Jest 15.\\n\\n\" + \"Release Blog Post: https://jestjs.io/blog/2016/09/01/jest-15.html\\n\" + \"Stack Trace:\\n\" + (0, (_jestMessageUtil || _load_jestMessageUtil()).formatStackTrace)(new Error().stack, this._config, {\n          noStackTrace: false\n        }));\n      }\n    }\n  }, {\n    key: \"_createMocks\",\n    value: function _createMocks() {\n      var _this3 = this;\n      var fn = function fn(impl) {\n        return _this3._moduleMocker.fn().mockImplementation(impl);\n      };\n      this._fakeTimerAPIs = {\n        clearImmediate: fn(this._fakeClearImmediate.bind(this)),\n        clearInterval: fn(this._fakeClearTimer.bind(this)),\n        clearTimeout: fn(this._fakeClearTimer.bind(this)),\n        nextTick: fn(this._fakeNextTick.bind(this)),\n        setImmediate: fn(this._fakeSetImmediate.bind(this)),\n        setInterval: fn(this._fakeSetInterval.bind(this)),\n        setTimeout: fn(this._fakeSetTimeout.bind(this))\n      };\n    }\n  }, {\n    key: \"_fakeClearTimer\",\n    value: function _fakeClearTimer(timerRef) {\n      var uuid = this._timerConfig.refToId(timerRef);\n      if (uuid && this._timers.hasOwnProperty(uuid)) {\n        delete this._timers[String(uuid)];\n      }\n    }\n  }, {\n    key: \"_fakeClearImmediate\",\n    value: function _fakeClearImmediate(uuid) {\n      this._cancelledImmediates[uuid] = true;\n    }\n  }, {\n    key: \"_fakeNextTick\",\n    value: function _fakeNextTick(_callback) {\n      if (this._disposed) {\n        return;\n      }\n      var args = [];\n      for (var ii = 1, ll = arguments.length; ii < ll; ii++) {\n        args.push(arguments[ii]);\n      }\n      var uuid = String(this._uuidCounter++);\n      this._ticks.push({\n        callback: function callback() {\n          return _callback.apply(null, args);\n        },\n        uuid: uuid\n      });\n      var cancelledTicks = this._cancelledTicks;\n      this._timerAPIs.nextTick(function () {\n        if (!cancelledTicks.hasOwnProperty(uuid)) {\n          // Callback may throw, so update the map prior calling.\n          cancelledTicks[uuid] = true;\n          _callback.apply(null, args);\n        }\n      });\n    }\n  }, {\n    key: \"_fakeSetImmediate\",\n    value: function _fakeSetImmediate(_callback2) {\n      if (this._disposed) {\n        return null;\n      }\n      var args = [];\n      for (var ii = 1, ll = arguments.length; ii < ll; ii++) {\n        args.push(arguments[ii]);\n      }\n      var uuid = this._uuidCounter++;\n      this._immediates.push({\n        callback: function callback() {\n          return _callback2.apply(null, args);\n        },\n        uuid: String(uuid)\n      });\n      var cancelledImmediates = this._cancelledImmediates;\n      this._timerAPIs.setImmediate(function () {\n        if (!cancelledImmediates.hasOwnProperty(uuid)) {\n          // Callback may throw, so update the map prior calling.\n          cancelledImmediates[String(uuid)] = true;\n          _callback2.apply(null, args);\n        }\n      });\n      return uuid;\n    }\n  }, {\n    key: \"_fakeSetInterval\",\n    value: function _fakeSetInterval(_callback3, intervalDelay) {\n      if (this._disposed) {\n        return null;\n      }\n      if (intervalDelay == null) {\n        intervalDelay = 0;\n      }\n      var args = [];\n      for (var ii = 2, ll = arguments.length; ii < ll; ii++) {\n        args.push(arguments[ii]);\n      }\n      var uuid = this._uuidCounter++;\n      this._timers[String(uuid)] = {\n        callback: function callback() {\n          return _callback3.apply(null, args);\n        },\n        expiry: this._now + intervalDelay,\n        interval: intervalDelay,\n        type: 'interval'\n      };\n      return this._timerConfig.idToRef(uuid);\n    }\n  }, {\n    key: \"_fakeSetTimeout\",\n    value: function _fakeSetTimeout(_callback4, delay) {\n      if (this._disposed) {\n        return null;\n      }\n\n      // eslint-disable-next-line no-bitwise\n      delay = Number(delay) | 0;\n      var args = [];\n      for (var ii = 2, ll = arguments.length; ii < ll; ii++) {\n        args.push(arguments[ii]);\n      }\n      var uuid = this._uuidCounter++;\n      this._timers[String(uuid)] = {\n        callback: function callback() {\n          return _callback4.apply(null, args);\n        },\n        expiry: this._now + delay,\n        interval: null,\n        type: 'timeout'\n      };\n      return this._timerConfig.idToRef(uuid);\n    }\n  }, {\n    key: \"_getNextTimerHandle\",\n    value: function _getNextTimerHandle() {\n      var nextTimerHandle = null;\n      var uuid;\n      var soonestTime = MS_IN_A_YEAR;\n      var timer;\n      for (uuid in this._timers) {\n        timer = this._timers[uuid];\n        if (timer.expiry < soonestTime) {\n          soonestTime = timer.expiry;\n          nextTimerHandle = uuid;\n        }\n      }\n      return nextTimerHandle;\n    }\n  }, {\n    key: \"_runTimerHandle\",\n    value: function _runTimerHandle(timerHandle) {\n      var timer = this._timers[timerHandle];\n      if (!timer) {\n        return;\n      }\n      switch (timer.type) {\n        case 'timeout':\n          var callback = timer.callback;\n          delete this._timers[timerHandle];\n          callback();\n          break;\n        case 'interval':\n          timer.expiry = this._now + timer.interval;\n          timer.callback();\n          break;\n        default:\n          throw new Error('Unexpected timer type: ' + timer.type);\n      }\n    }\n  }]);\n  return FakeTimers;\n}();\nexports.default = FakeTimers;","map":null,"metadata":{},"sourceType":"script"}