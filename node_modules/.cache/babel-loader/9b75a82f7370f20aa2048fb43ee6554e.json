{"ast":null,"code":"// Matches the scheme of a URL, eg \"http://\"\nvar schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nvar urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nvar fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n(function (UrlType) {\n  UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n  UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n  UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n  UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n  UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n  UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n  UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nfunction isAbsoluteUrl(input) {\n  return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n  return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n  return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n  return input.startsWith('file:');\n}\nfunction isRelative(input) {\n  return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n  var match = urlRegex.exec(input);\n  return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n  var match = fileRegex.exec(input);\n  var path = match[2];\n  return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n  return {\n    scheme: scheme,\n    user: user,\n    host: host,\n    port: port,\n    path: path,\n    query: query,\n    hash: hash,\n    type: UrlType.Absolute\n  };\n}\nfunction parseUrl(input) {\n  if (isSchemeRelativeUrl(input)) {\n    var _url = parseAbsoluteUrl('http:' + input);\n    _url.scheme = '';\n    _url.type = UrlType.SchemeRelative;\n    return _url;\n  }\n  if (isAbsolutePath(input)) {\n    var _url2 = parseAbsoluteUrl('http://foo.com' + input);\n    _url2.scheme = '';\n    _url2.host = '';\n    _url2.type = UrlType.AbsolutePath;\n    return _url2;\n  }\n  if (isFileUrl(input)) return parseFileUrl(input);\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n  var url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n  return url;\n}\nfunction stripPathFilename(path) {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  var index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n  normalizePath(base, base.type);\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n  var rel = type <= UrlType.RelativePath;\n  var pieces = url.path.split('/');\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  var pointer = 1;\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  var positive = 0;\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  var addTrailingSlash = false;\n  for (var i = 1; i < pieces.length; i++) {\n    var piece = pieces[i];\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n  var path = '';\n  for (var _i = 1; _i < pointer; _i++) {\n    path += '/' + pieces[_i];\n  }\n  if (!path || addTrailingSlash && !path.endsWith('/..')) {\n    path += '/';\n  }\n  url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n  if (!input && !base) return '';\n  var url = parseUrl(input);\n  var inputType = url.type;\n  if (base && inputType !== UrlType.Absolute) {\n    var baseUrl = parseUrl(base);\n    var baseType = baseUrl.type;\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n  normalizePath(url, inputType);\n  var queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n    case UrlType.RelativePath:\n      {\n        // The first char is always a \"/\", and we need it to be relative.\n        var path = url.path.slice(1);\n        if (!path) return queryHash || '.';\n        if (isRelative(base || input) && !isRelative(path)) {\n          // If base started with a leading \".\", or there is no base and input started with a \".\",\n          // then we need to ensure that the relative path starts with a \".\". We don't know if\n          // relative starts with a \"..\", though, so check before prepending.\n          return './' + path + queryHash;\n        }\n        return path + queryHash;\n      }\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\nexport { resolve as default };","map":null,"metadata":{},"sourceType":"module"}