{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar platform = require('os').platform();\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * Constants\n */\n\nvar DEFAULT_DELAY = common.DEFAULT_DELAY;\nvar CHANGE_EVENT = common.CHANGE_EVENT;\nvar DELETE_EVENT = common.DELETE_EVENT;\nvar ADD_EVENT = common.ADD_EVENT;\nvar ALL_EVENT = common.ALL_EVENT;\n\n/**\n * Export `NodeWatcher` class.\n */\n\nmodule.exports = NodeWatcher;\n\n/**\n * Watches `dir`.\n *\n * @class NodeWatcher\n * @param {String} dir\n * @param {Object} opts\n * @public\n */\n\nfunction NodeWatcher(dir, opts) {\n  common.assignOptions(this, opts);\n  this.watched = Object.create(null);\n  this.changeTimers = Object.create(null);\n  this.dirRegistery = Object.create(null);\n  this.root = path.resolve(dir);\n  this.watchdir = this.watchdir.bind(this);\n  this.register = this.register.bind(this);\n  this.checkedEmitError = this.checkedEmitError.bind(this);\n  this.watchdir(this.root);\n  common.recReaddir(this.root, this.watchdir, this.register, this.emit.bind(this, 'ready'), this.checkedEmitError, this.ignored);\n}\nNodeWatcher.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Register files that matches our globs to know what to type of event to\n * emit in the future.\n *\n * Registery looks like the following:\n *\n *  dirRegister => Map {\n *    dirpath => Map {\n *       filename => true\n *    }\n *  }\n *\n * @param {string} filepath\n * @return {boolean} whether or not we have registered the file.\n * @private\n */\n\nNodeWatcher.prototype.register = function (filepath) {\n  var relativePath = path.relative(this.root, filepath);\n  if (!common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n    return false;\n  }\n  var dir = path.dirname(filepath);\n  if (!this.dirRegistery[dir]) {\n    this.dirRegistery[dir] = Object.create(null);\n  }\n  var filename = path.basename(filepath);\n  this.dirRegistery[dir][filename] = true;\n  return true;\n};\n\n/**\n * Removes a file from the registery.\n *\n * @param {string} filepath\n * @private\n */\n\nNodeWatcher.prototype.unregister = function (filepath) {\n  var dir = path.dirname(filepath);\n  if (this.dirRegistery[dir]) {\n    var filename = path.basename(filepath);\n    delete this.dirRegistery[dir][filename];\n  }\n};\n\n/**\n * Removes a dir from the registery.\n *\n * @param {string} dirpath\n * @private\n */\n\nNodeWatcher.prototype.unregisterDir = function (dirpath) {\n  if (this.dirRegistery[dirpath]) {\n    delete this.dirRegistery[dirpath];\n  }\n};\n\n/**\n * Checks if a file or directory exists in the registery.\n *\n * @param {string} fullpath\n * @return {boolean}\n * @private\n */\n\nNodeWatcher.prototype.registered = function (fullpath) {\n  var dir = path.dirname(fullpath);\n  return this.dirRegistery[fullpath] || this.dirRegistery[dir] && this.dirRegistery[dir][path.basename(fullpath)];\n};\n\n/**\n * Determine if a given FS error can be ignored\n *\n * @private\n */\nfunction isIgnorableFileError(error) {\n  return error.code === 'ENOENT' ||\n  // Workaround Windows node issue #4337.\n  error.code === 'EPERM' && platform === 'win32';\n}\n\n/**\n * Emit \"error\" event if it's not an ignorable event\n *\n * @param error\n * @private\n */\nNodeWatcher.prototype.checkedEmitError = function (error) {\n  if (!isIgnorableFileError(error)) {\n    this.emit('error', error);\n  }\n};\n\n/**\n * Watch a directory.\n *\n * @param {string} dir\n * @private\n */\n\nNodeWatcher.prototype.watchdir = function (dir) {\n  if (this.watched[dir]) {\n    return;\n  }\n  var watcher = fs.watch(dir, {\n    persistent: true\n  }, this.normalizeChange.bind(this, dir));\n  this.watched[dir] = watcher;\n  watcher.on('error', this.checkedEmitError);\n  if (this.root !== dir) {\n    this.register(dir);\n  }\n};\n\n/**\n * Stop watching a directory.\n *\n * @param {string} dir\n * @private\n */\n\nNodeWatcher.prototype.stopWatching = function (dir) {\n  if (this.watched[dir]) {\n    this.watched[dir].close();\n    delete this.watched[dir];\n  }\n};\n\n/**\n * End watching.\n *\n * @public\n */\n\nNodeWatcher.prototype.close = function (callback) {\n  Object.keys(this.watched).forEach(this.stopWatching, this);\n  this.removeAllListeners();\n  if (typeof callback === 'function') {\n    setImmediate(callback.bind(null, null, true));\n  }\n};\n\n/**\n * On some platforms, as pointed out on the fs docs (most likely just win32)\n * the file argument might be missing from the fs event. Try to detect what\n * change by detecting if something was deleted or the most recent file change.\n *\n * @param {string} dir\n * @param {string} event\n * @param {string} file\n * @public\n */\n\nNodeWatcher.prototype.detectChangedFile = function (dir, event, callback) {\n  if (!this.dirRegistery[dir]) {\n    return;\n  }\n  var found = false;\n  var closest = {\n    mtime: 0\n  };\n  var c = 0;\n  Object.keys(this.dirRegistery[dir]).forEach(function (file, i, arr) {\n    fs.lstat(path.join(dir, file), function (error, stat) {\n      if (found) {\n        return;\n      }\n      if (error) {\n        if (isIgnorableFileError(error)) {\n          found = true;\n          callback(file);\n        } else {\n          this.emit('error', error);\n        }\n      } else {\n        if (stat.mtime > closest.mtime) {\n          stat.file = file;\n          closest = stat;\n        }\n        if (arr.length === ++c) {\n          callback(closest.file);\n        }\n      }\n    }.bind(this));\n  }, this);\n};\n\n/**\n * Normalize fs events and pass it on to be processed.\n *\n * @param {string} dir\n * @param {string} event\n * @param {string} file\n * @public\n */\n\nNodeWatcher.prototype.normalizeChange = function (dir, event, file) {\n  if (!file) {\n    this.detectChangedFile(dir, event, function (actualFile) {\n      if (actualFile) {\n        this.processChange(dir, event, actualFile);\n      }\n    }.bind(this));\n  } else {\n    this.processChange(dir, event, path.normalize(file));\n  }\n};\n\n/**\n * Process changes.\n *\n * @param {string} dir\n * @param {string} event\n * @param {string} file\n * @public\n */\n\nNodeWatcher.prototype.processChange = function (dir, event, file) {\n  var fullPath = path.join(dir, file);\n  var relativePath = path.join(path.relative(this.root, dir), file);\n  fs.lstat(fullPath, function (error, stat) {\n    if (error && error.code !== 'ENOENT') {\n      this.emit('error', error);\n    } else if (!error && stat.isDirectory()) {\n      // win32 emits usless change events on dirs.\n      if (event !== 'change') {\n        this.watchdir(fullPath);\n        if (common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n          this.emitEvent(ADD_EVENT, relativePath, stat);\n        }\n      }\n    } else {\n      var registered = this.registered(fullPath);\n      if (error && error.code === 'ENOENT') {\n        this.unregister(fullPath);\n        this.stopWatching(fullPath);\n        this.unregisterDir(fullPath);\n        if (registered) {\n          this.emitEvent(DELETE_EVENT, relativePath);\n        }\n      } else if (registered) {\n        this.emitEvent(CHANGE_EVENT, relativePath, stat);\n      } else {\n        if (this.register(fullPath)) {\n          this.emitEvent(ADD_EVENT, relativePath, stat);\n        }\n      }\n    }\n  }.bind(this));\n};\n\n/**\n * Triggers a 'change' event after debounding it to take care of duplicate\n * events on os x.\n *\n * @private\n */\n\nNodeWatcher.prototype.emitEvent = function (type, file, stat) {\n  var key = type + '-' + file;\n  var addKey = ADD_EVENT + '-' + file;\n  if (type === CHANGE_EVENT && this.changeTimers[addKey]) {\n    // Ignore the change event that is immediately fired after an add event.\n    // (This happens on Linux).\n    return;\n  }\n  clearTimeout(this.changeTimers[key]);\n  this.changeTimers[key] = setTimeout(function () {\n    delete this.changeTimers[key];\n    if (type === ADD_EVENT && stat.isDirectory()) {\n      // Recursively emit add events and watch for sub-files/folders\n      common.recReaddir(path.resolve(this.root, file), function emitAddDir(dir, stats) {\n        this.watchdir(dir);\n        this.rawEmitEvent(ADD_EVENT, path.relative(this.root, dir), stats);\n      }.bind(this), function emitAddFile(file, stats) {\n        this.register(file);\n        this.rawEmitEvent(ADD_EVENT, path.relative(this.root, file), stats);\n      }.bind(this), function endCallback() {}, this.checkedEmitError, this.ignored);\n    } else {\n      this.rawEmitEvent(type, file, stat);\n    }\n  }.bind(this), DEFAULT_DELAY);\n};\n\n/**\n * Actually emit the events\n */\nNodeWatcher.prototype.rawEmitEvent = function (type, file, stat) {\n  this.emit(type, file, this.root, stat);\n  this.emit(ALL_EVENT, type, file, this.root, stat);\n};","map":null,"metadata":{},"sourceType":"script"}