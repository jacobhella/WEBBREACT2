{"ast":null,"code":"/**\n * Copyright (c) 2018-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n'use strict';\n\nvar _defineProperty = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.deserialize = deserialize;\nexports.serialize = serialize;\nexports.readFileSync = readFileSync;\nexports.writeFileSync = writeFileSync;\nvar _fs;\nfunction _load_fs() {\n  return _fs = _interopRequireDefault(require('fs'));\n}\nvar _v;\nfunction _load_v() {\n  return _v = _interopRequireDefault(require('v8'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n// JSON and V8 serializers are both stable when it comes to compatibility. The\n// current JSON specification is well defined in RFC 8259, and V8 ensures that\n// the versions are compatible by encoding the serialization version in the own\n// generated buffer.\n\nvar JS_TYPE = '__$t__';\nvar JS_VALUE = '__$v__';\nvar JS_VF = '__$f__';\nfunction replacer(key, value) {\n  var _ref5, _ref6, _ref7, _ref8, _ref9;\n  // NaN cannot be in a switch statement, because NaN !== NaN.\n  if (Number.isNaN(value)) {\n    return _defineProperty({}, JS_TYPE, 'n');\n  }\n  switch (value) {\n    case undefined:\n      return _defineProperty({}, JS_TYPE, 'u');\n    case +Infinity:\n      return _defineProperty({}, JS_TYPE, '+');\n    case -Infinity:\n      return _defineProperty({}, JS_TYPE, '-');\n  }\n  switch (value && value.constructor) {\n    case Date:\n      return _ref5 = {}, _defineProperty(_ref5, JS_TYPE, 'd'), _defineProperty(_ref5, JS_VALUE, value.getTime()), _ref5;\n    case RegExp:\n      return _ref6 = {}, _defineProperty(_ref6, JS_TYPE, 'r'), _defineProperty(_ref6, JS_VALUE, value.source), _defineProperty(_ref6, JS_VF, value.flags), _ref6;\n    case Set:\n      return _ref7 = {}, _defineProperty(_ref7, JS_TYPE, 's'), _defineProperty(_ref7, JS_VALUE, Array.from(value)), _ref7;\n    case Map:\n      return _ref8 = {}, _defineProperty(_ref8, JS_TYPE, 'm'), _defineProperty(_ref8, JS_VALUE, Array.from(value)), _ref8;\n    case Buffer:\n      return _ref9 = {}, _defineProperty(_ref9, JS_TYPE, 'b'), _defineProperty(_ref9, JS_VALUE, value.toString('latin1')), _ref9;\n  }\n  return value;\n}\nfunction reviver(key, value) {\n  if (!value || typeof value !== 'object' && !value.hasOwnProperty(JS_TYPE)) {\n    return value;\n  }\n  switch (value[JS_TYPE]) {\n    case 'u':\n      return undefined;\n    case 'n':\n      return NaN;\n    case '+':\n      return +Infinity;\n    case '-':\n      return -Infinity;\n    case 'd':\n      return new Date(value[JS_VALUE]);\n    case 'r':\n      return new RegExp(value[JS_VALUE], value[JS_VF]);\n    case 's':\n      return new Set(value[JS_VALUE]);\n    case 'm':\n      return new Map(value[JS_VALUE]);\n    case 'b':\n      return Buffer.from(value[JS_VALUE], 'latin1');\n  }\n  return value;\n}\nfunction jsonStringify(content) {\n  // Not pretty, but the ES JSON spec says that \"toJSON\" will be called before\n  // getting into your replacer, so we have to remove them beforehand. See\n  // https://www.ecma-international.org/ecma-262/#sec-serializejsonproperty\n  // section 2.b for more information.\n\n  var dateToJSON = Date.prototype.toJSON;\n  var bufferToJSON = Buffer.prototype.toJSON;\n\n  /* eslint-disable no-extend-native */\n\n  try {\n    // $FlowFixMe: intentional removal of \"toJSON\" property.\n    Date.prototype.toJSON = undefined;\n    // $FlowFixMe: intentional removal of \"toJSON\" property.\n    Buffer.prototype.toJSON = undefined;\n    return JSON.stringify(content, replacer);\n  } finally {\n    // $FlowFixMe: intentional assignment of \"toJSON\" property.\n    Date.prototype.toJSON = dateToJSON;\n    // $FlowFixMe: intentional assignment of \"toJSON\" property.\n    Buffer.prototype.toJSON = bufferToJSON;\n  }\n\n  /* eslint-enable no-extend-native */\n}\n\nfunction jsonParse(content) {\n  return JSON.parse(content, reviver);\n}\n\n// In memory functions.\n\nfunction deserialize(buffer) {\n  // $FlowFixMe - Node 8+ only\n  return (_v || _load_v()).default.deserialize ? (_v || _load_v()).default.deserialize(buffer) : jsonParse(buffer.toString('utf8'));\n}\nfunction serialize(content) {\n  // $FlowFixMe - Node 8+ only\n  return (_v || _load_v()).default.serialize ? (_v || _load_v()).default.serialize(content) : Buffer.from(jsonStringify(content));\n}\n\n// Synchronous filesystem functions.\n\nfunction readFileSync(filePath) {\n  // $FlowFixMe - Node 8+ only\n  return (_v || _load_v()).default.deserialize ? (_v || _load_v()).default.deserialize((_fs || _load_fs()).default.readFileSync(filePath)) : jsonParse((_fs || _load_fs()).default.readFileSync(filePath, 'utf8'));\n}\nfunction writeFileSync(filePath, content) {\n  // $FlowFixMe - Node 8+ only\n  return (_v || _load_v()).default.serialize ? (_fs || _load_fs()).default.writeFileSync(filePath, (_v || _load_v()).default.serialize(content)) : (_fs || _load_fs()).default.writeFileSync(filePath, jsonStringify(content), 'utf8');\n}\nexports.default = {\n  deserialize: deserialize,\n  readFileSync: readFileSync,\n  serialize: serialize,\n  writeFileSync: writeFileSync\n};","map":null,"metadata":{},"sourceType":"script"}