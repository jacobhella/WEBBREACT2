{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\"use strict\";\n\nvar debug = require('debug')('istanbuljs'),\n  path = require('path'),\n  fs = require('fs'),\n  pathutils = require('./pathutils'),\n  sourceStore = require('./source-store'),\n  transformer = require('./transformer'),\n  SMC = require('source-map').SourceMapConsumer;\n\n/**\n * tracks source maps for registered files\n * @param {Object} opts [opts=undefined] options.\n * @param {Boolean} opts.verbose [opts.verbose=false] verbose mode\n * @param {String} opts.baseDir [opts.baseDir=null] alternate base directory\n *  to resolve sourcemap files\n * @param {String} opts.sourceStore [opts.sourceStore='memory'] - store that tracks\n *  embedded sources found in source maps, one of 'memory' or 'file'\n * @param {String} opts.tmpdir [opts.tmpdir=undefined] - temporary directory\n *   to use for storing files.\n * @constructor\n */\nfunction MapStore(opts) {\n  opts = opts || {};\n  this.baseDir = opts.baseDir || null;\n  this.verbose = opts.verbose || false;\n  this.sourceStore = sourceStore.create(opts.sourceStore, {\n    tmpdir: opts.tmpdir\n  });\n  this.data = {};\n}\n/**\n * registers a source map URL with this store. It makes some input sanity checks\n * and silently fails on malformed input.\n * @param transformedFilePath - the file path for which the source map is valid.\n *  This must *exactly* match the path stashed for the coverage object to be\n *  useful.\n * @param sourceMapUrl - the source map URL, **not** a comment\n */\nMapStore.prototype.registerURL = function (transformedFilePath, sourceMapUrl) {\n  var d = 'data:',\n    b64 = 'base64,',\n    pos;\n  if (sourceMapUrl.length > d.length && sourceMapUrl.substring(0, d.length) === d) {\n    pos = sourceMapUrl.indexOf(b64);\n    if (pos > 0) {\n      this.data[transformedFilePath] = {\n        type: 'encoded',\n        data: sourceMapUrl.substring(pos + b64.length)\n      };\n    } else {\n      debug('Unable to interpret source map URL: ' + sourceMapUrl);\n    }\n    return;\n  }\n  var dir = path.dirname(path.resolve(transformedFilePath)),\n    file = path.resolve(dir, sourceMapUrl);\n  this.data[transformedFilePath] = {\n    type: 'file',\n    data: file\n  };\n};\n/**\n * registers a source map object with this store. Makes some basic sanity checks\n * and silently fails on malformed input.\n * @param transformedFilePath - the file path for which the source map is valid\n * @param sourceMap - the source map object\n */\nMapStore.prototype.registerMap = function (transformedFilePath, sourceMap) {\n  if (sourceMap && sourceMap.version) {\n    this.data[transformedFilePath] = {\n      type: 'object',\n      data: sourceMap\n    };\n  } else {\n    debug('Invalid source map object:' + JSON.stringify(sourceMap, null, 2));\n  }\n};\n/**\n * transforms the coverage map provided into one that refers to original\n * sources when valid mappings have been registered with this store.\n * @param {CoverageMap} coverageMap - the coverage map to transform\n * @returns {Object} an object with 2 properties. `map` for the transformed\n * coverage map and `sourceFinder` which is a function to return the source\n * text for a file.\n */\nMapStore.prototype.transformCoverage = function (coverageMap) {\n  var that = this,\n    mappedCoverage,\n    sourceFinder;\n  sourceFinder = function sourceFinder(filePath) {\n    var content = that.sourceStore.getSource(filePath);\n    if (content !== null) {\n      return content;\n    }\n    if (pathutils.isAbsolute(filePath)) {\n      return fs.readFileSync(filePath, 'utf8');\n    }\n    return fs.readFileSync(pathutils.asAbsolute(filePath, that.baseDir));\n  };\n  coverageMap.files().forEach(function (file) {\n    var coverage = coverageMap.fileCoverageFor(file);\n    if (coverage.data.inputSourceMap && !that.data[file]) {\n      that.registerMap(file, coverage.data.inputSourceMap);\n    }\n  });\n  if (Object.keys(this.data).length === 0) {\n    return {\n      map: coverageMap,\n      sourceFinder: sourceFinder\n    };\n  }\n  mappedCoverage = transformer.create(function (filePath) {\n    try {\n      if (!that.data[filePath]) {\n        return null;\n      }\n      var d = that.data[filePath],\n        obj,\n        smc;\n      if (d.type === 'file') {\n        obj = JSON.parse(fs.readFileSync(d.data, 'utf8'));\n      } else if (d.type === 'encoded') {\n        obj = JSON.parse(new Buffer(d.data, 'base64').toString());\n      } else {\n        obj = d.data;\n      }\n      smc = new SMC(obj);\n      smc.sources.forEach(function (s) {\n        var content = smc.sourceContentFor(s),\n          sourceFilePath = pathutils.relativeTo(s, filePath);\n        if (content) {\n          that.sourceStore.registerSource(sourceFilePath, content);\n        }\n      });\n      return smc;\n    } catch (ex) {\n      debug('Error returning source map for ' + filePath);\n      debug(ex.stack);\n      return null;\n    }\n  }).transform(coverageMap);\n  return {\n    map: mappedCoverage,\n    sourceFinder: sourceFinder\n  };\n};\n\n/**\n * disposes temporary resources allocated by this map store\n */\nMapStore.prototype.dispose = function () {\n  this.sourceStore.dispose();\n};\nmodule.exports = {\n  MapStore: MapStore\n};","map":null,"metadata":{},"sourceType":"script"}