{"ast":null,"code":"var assign = require('object-assign');\nvar arrify = require('arrify');\nvar micromatch = require('micromatch');\nvar path = require('path');\nvar readPkgUp = require('read-pkg-up');\nvar requireMainFilename = require('require-main-filename');\nfunction TestExclude(opts) {\n  assign(this, {\n    cwd: process.cwd(),\n    include: false,\n    relativePath: true,\n    configKey: null,\n    // the key to load config from in package.json.\n    configPath: null,\n    // optionally override requireMainFilename.\n    configFound: false\n  }, opts);\n  if (typeof this.include === 'string') this.include = [this.include];\n  if (typeof this.exclude === 'string') this.exclude = [this.exclude];\n  if (!this.include && !this.exclude && this.configKey) {\n    assign(this, this.pkgConf(this.configKey, this.configPath));\n  }\n  if (!this.exclude || !Array.isArray(this.exclude)) {\n    this.exclude = exportFunc.defaultExclude;\n  }\n  if (this.include && this.include.length > 0) {\n    this.include = prepGlobPatterns(arrify(this.include));\n  } else {\n    this.include = false;\n  }\n  if (this.exclude.indexOf('**/node_modules/**') === -1) {\n    this.exclude.push('**/node_modules/**');\n  }\n  this.exclude = prepGlobPatterns([].concat(arrify(this.exclude)));\n  this.handleNegation();\n}\n\n// handle the special case of negative globs\n// (!**foo/bar); we create a new this.excludeNegated set\n// of rules, which is applied after excludes and we\n// move excluded include rules into this.excludes.\nTestExclude.prototype.handleNegation = function () {\n  if (Array.isArray(this.include)) {\n    var includeNegated = this.include.filter(function (e) {\n      return e.charAt(0) === '!';\n    }).map(function (e) {\n      return e.slice(1);\n    });\n    this.exclude.push.apply(this.exclude, prepGlobPatterns(includeNegated));\n    this.include = this.include.filter(function (e) {\n      return e.charAt(0) !== '!';\n    });\n  }\n  this.excludeNegated = this.exclude.filter(function (e) {\n    return e.charAt(0) === '!';\n  }).map(function (e) {\n    return e.slice(1);\n  });\n  this.exclude = this.exclude.filter(function (e) {\n    return e.charAt(0) !== '!';\n  });\n  this.excludeNegated = prepGlobPatterns(this.excludeNegated);\n};\nTestExclude.prototype.shouldInstrument = function (filename, relFile) {\n  var pathToCheck = filename;\n  if (this.relativePath) {\n    relFile = relFile || path.relative(this.cwd, filename);\n\n    // Don't instrument files that are outside of the current working directory.\n    if (/^\\.\\./.test(path.relative(this.cwd, filename))) return false;\n    pathToCheck = relFile.replace(/^\\.[\\\\/]/, ''); // remove leading './' or '.\\'.\n  }\n\n  return (!this.include || micromatch.any(pathToCheck, this.include, {\n    dotfiles: true\n  })) && (!micromatch.any(pathToCheck, this.exclude, {\n    dotfiles: true\n  }) || micromatch.any(pathToCheck, this.excludeNegated, {\n    dotfiles: true\n  }));\n};\nTestExclude.prototype.pkgConf = function (key, path) {\n  var obj = readPkgUp.sync({\n    cwd: path || requireMainFilename(require)\n  });\n  if (obj.pkg && obj.pkg[key] && typeof obj.pkg[key] === 'object') {\n    this.configFound = true;\n    return obj.pkg[key];\n  } else {\n    return {};\n  }\n};\nfunction prepGlobPatterns(patterns) {\n  return patterns.reduce(function (result, pattern) {\n    // Allow gitignore style of directory exclusion\n    if (!/\\/\\*\\*$/.test(pattern)) {\n      result = result.concat(pattern.replace(/\\/$/, '') + '/**');\n    }\n\n    // Any rules of the form **/foo.js, should also match foo.js.\n    if (/^\\*\\*\\//.test(pattern)) {\n      result = result.concat(pattern.replace(/^\\*\\*\\//, ''));\n    }\n    return result.concat(pattern);\n  }, []);\n}\nvar exportFunc = function exportFunc(opts) {\n  return new TestExclude(opts);\n};\nexportFunc.defaultExclude = ['coverage/**', 'packages/*/test/**', 'test/**', 'test{,-*}.js', '**/*{.,-}test.js', '**/__tests__/**', '**/node_modules/**'];\nmodule.exports = exportFunc;","map":null,"metadata":{},"sourceType":"script"}