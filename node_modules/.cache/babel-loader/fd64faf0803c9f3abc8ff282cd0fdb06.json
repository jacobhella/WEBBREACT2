{"ast":null,"code":"/**\n * Copyright (c) 2017-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _mergeStream;\nfunction _load_mergeStream() {\n  return _mergeStream = _interopRequireDefault(require('merge-stream'));\n}\nvar _os;\nfunction _load_os() {\n  return _os = _interopRequireDefault(require('os'));\n}\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _types;\nfunction _load_types() {\n  return _types = require('./types');\n}\nvar _worker;\nfunction _load_worker() {\n  return _worker = _interopRequireDefault(require('./worker'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/* istanbul ignore next */\nvar emptyMethod = function emptyMethod() {};\n\n/**\n * The Jest farm (publicly called \"Worker\") is a class that allows you to queue\n * methods across multiple child processes, in order to parallelize work. This\n * is done by providing an absolute path to a module that will be loaded on each\n * of the child processes, and bridged to the main process.\n *\n * Bridged methods are specified by using the \"exposedMethods\" property of the\n * options \"object\". This is an array of strings, where each of them corresponds\n * to the exported name in the loaded module.\n *\n * You can also control the amount of workers by using the \"numWorkers\" property\n * of the \"options\" object, and the settings passed to fork the process through\n * the \"forkOptions\" property. The amount of workers defaults to the amount of\n * CPUS minus one.\n *\n * Queueing calls can be done in two ways:\n *   - Standard method: calls will be redirected to the first available worker,\n *     so they will get executed as soon as they can.\n *\n *   - Sticky method: if a \"computeWorkerKey\" method is provided within the\n *   config, the resulting string of this method will be used as a key.\n *   Everytime this key is returned, it is guaranteed that your job will be\n *   processed by the same worker. This is specially useful if your workers are\n *   caching results.\n */\nexports.default = /*#__PURE__*/function () {\n  function _class(workerPath) {\n    var _this = this;\n    _classCallCheck(this, _class);\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var numWorkers = options.numWorkers || (_os || _load_os()).default.cpus().length - 1;\n    var workers = new Array(numWorkers);\n    var stdout = (0, (_mergeStream || _load_mergeStream()).default)();\n    var stderr = (0, (_mergeStream || _load_mergeStream()).default)();\n    if (!(_path || _load_path()).default.isAbsolute(workerPath)) {\n      workerPath = require.resolve(workerPath);\n    }\n    var sharedWorkerOptions = {\n      forkOptions: options.forkOptions || {},\n      maxRetries: options.maxRetries || 3,\n      workerPath: workerPath\n    };\n    for (var i = 0; i < numWorkers; i++) {\n      var workerOptions = Object.assign({}, sharedWorkerOptions, {\n        workerId: i + 1\n      });\n      var worker = new (_worker || _load_worker()).default(workerOptions);\n      var workerStdout = worker.getStdout();\n      var workerStderr = worker.getStderr();\n      if (workerStdout) {\n        stdout.add(workerStdout);\n      }\n      if (workerStderr) {\n        stderr.add(workerStderr);\n      }\n      workers[i] = worker;\n    }\n    var exposedMethods = options.exposedMethods;\n\n    // If no methods list is given, try getting it by auto-requiring the module.\n    if (!exposedMethods) {\n      // $FlowFixMe: This has to be a dynamic require.\n      var child = require(workerPath);\n      exposedMethods = Object.keys(child).filter(function (name) {\n        return typeof child[name] === 'function';\n      });\n      if (typeof child === 'function') {\n        exposedMethods.push('default');\n      }\n    }\n    exposedMethods.forEach(function (name) {\n      if (name.startsWith('_')) {\n        return;\n      }\n      if (_this.constructor.prototype.hasOwnProperty(name)) {\n        throw new TypeError('Cannot define a method called ' + name);\n      }\n\n      // $FlowFixMe: dynamic extension of the class instance is expected.\n      _this[name] = _this._makeCall.bind(_this, name);\n    });\n    this._stdout = stdout;\n    this._stderr = stderr;\n    this._ending = false;\n    this._cacheKeys = Object.create(null);\n    this._options = options;\n    this._workers = workers;\n    this._offset = 0;\n  }\n  _createClass(_class, [{\n    key: \"getStdout\",\n    value: function getStdout() {\n      return this._stdout;\n    }\n  }, {\n    key: \"getStderr\",\n    value: function getStderr() {\n      return this._stderr;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this._ending) {\n        throw new Error('Farm is ended, no more calls can be done to it');\n      }\n      var workers = this._workers;\n\n      // We do not cache the request object here. If so, it would only be only\n      // processed by one of the workers, and we want them all to close.\n      for (var i = 0; i < workers.length; i++) {\n        workers[i].send([(_types || _load_types()).CHILD_MESSAGE_END, false], emptyMethod, emptyMethod);\n      }\n      this._ending = true;\n    } // eslint-disable-next-line no-unclear-flowtypes\n  }, {\n    key: \"_makeCall\",\n    value: function _makeCall(method) {\n      var _this2 = this;\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      if (this._ending) {\n        throw new Error('Farm is ended, no more calls can be done to it');\n      }\n      return new Promise(function (resolve, reject) {\n        var computeWorkerKey = _this2._options.computeWorkerKey;\n        var workers = _this2._workers;\n        var length = workers.length;\n        var cacheKeys = _this2._cacheKeys;\n        var request = [(_types || _load_types()).CHILD_MESSAGE_CALL, false, method, args];\n        var worker = null;\n        var hash = null;\n        if (computeWorkerKey) {\n          hash = computeWorkerKey.apply(_this2, [method].concat(args));\n          worker = hash == null ? null : cacheKeys[hash];\n        }\n\n        // Do not use a fat arrow since we need the \"this\" value, which points to\n        // the worker that executed the call.\n        var onProcessStart = function onProcessStart(worker) {\n          if (hash != null) {\n            cacheKeys[hash] = worker;\n          }\n        };\n        var onProcessEnd = function onProcessEnd(error, result) {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(result);\n          }\n        };\n\n        // If a worker is pre-selected, use it...\n        if (worker) {\n          worker.send(request, onProcessStart, onProcessEnd);\n          return;\n        }\n\n        // ... otherwise use all workers, so the first one available will pick it.\n        for (var i = 0; i < length; i++) {\n          workers[(i + _this2._offset) % length].send(request, onProcessStart, onProcessEnd);\n        }\n        _this2._offset++;\n      });\n    }\n  }]);\n  return _class;\n}();","map":null,"metadata":{},"sourceType":"script"}