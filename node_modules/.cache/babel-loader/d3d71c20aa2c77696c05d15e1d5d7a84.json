{"ast":null,"code":"'use strict';\n\nvar _fs = require('fs');\nvar _fs2 = _interopRequireDefault(_fs);\nvar _path = require('path');\nvar _path2 = _interopRequireDefault(_path);\nvar _jestDiff = require('jest-diff');\nvar _jestDiff2 = _interopRequireDefault(_jestDiff);\nvar _jestMatcherUtils = require('jest-matcher-utils');\nvar _State = require('./State');\nvar _State2 = _interopRequireDefault(_State);\nvar _plugins = require('./plugins');\nvar _utils = require('./utils');\nvar utils = _interopRequireWildcard(_utils);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar fileExists = function fileExists(filePath, hasteFS) {\n  return hasteFS.exists(filePath) || _fs2.default.existsSync(filePath);\n};\nvar cleanup = function cleanup(hasteFS, update) {\n  var pattern = '\\\\.' + utils.SNAPSHOT_EXTENSION + '$';\n  var files = hasteFS.matchFiles(pattern);\n  var filesRemoved = files.filter(function (snapshotFile) {\n    return !fileExists(_path2.default.resolve(_path2.default.dirname(snapshotFile), '..', _path2.default.basename(snapshotFile, '.' + utils.SNAPSHOT_EXTENSION)), hasteFS);\n  }).map(function (snapshotFile) {\n    if (update === 'all') {\n      _fs2.default.unlinkSync(snapshotFile);\n    }\n  }).length;\n  return {\n    filesRemoved: filesRemoved\n  };\n};\nvar toMatchSnapshot = function toMatchSnapshot(received, propertyMatchers, testName) {\n  if (arguments.length === 3 && !propertyMatchers) {\n    throw new Error('Property matchers must be an object.\\n\\nTo provide a snapshot test name without property matchers, use: toMatchSnapshot(\"name\")');\n  }\n  return _toMatchSnapshot({\n    context: this,\n    propertyMatchers: propertyMatchers,\n    received: received,\n    testName: testName\n  });\n};\nvar toMatchInlineSnapshot = function toMatchInlineSnapshot(received, propertyMatchersOrInlineSnapshot, inlineSnapshot) {\n  var propertyMatchers;\n  if (typeof propertyMatchersOrInlineSnapshot === 'string') {\n    inlineSnapshot = propertyMatchersOrInlineSnapshot;\n  } else {\n    propertyMatchers = propertyMatchersOrInlineSnapshot;\n  }\n  return _toMatchSnapshot({\n    context: this,\n    inlineSnapshot: inlineSnapshot || '',\n    propertyMatchers: propertyMatchers,\n    received: received\n  });\n};\nvar _toMatchSnapshot = function _toMatchSnapshot(_ref) {\n  var context = _ref.context,\n    received = _ref.received,\n    propertyMatchers = _ref.propertyMatchers,\n    testName = _ref.testName,\n    inlineSnapshot = _ref.inlineSnapshot;\n  context.dontThrow && context.dontThrow();\n  testName = typeof propertyMatchers === 'string' ? propertyMatchers : testName;\n  var currentTestName = context.currentTestName,\n    isNot = context.isNot,\n    snapshotState = context.snapshotState;\n  if (isNot) {\n    var matcherName = typeof inlineSnapshot === 'string' ? 'toMatchInlineSnapshot' : 'toMatchSnapshot';\n    throw new Error(\"Jest: `.not` cannot be used with `.\".concat(matcherName, \"()`.\"));\n  }\n  if (!snapshotState) {\n    throw new Error('Jest: snapshot state must be initialized.');\n  }\n  var fullTestName = testName && currentTestName ? \"\".concat(currentTestName, \": \").concat(testName) : currentTestName || '';\n  if (typeof propertyMatchers === 'object') {\n    if (propertyMatchers === null) {\n      throw new Error(\"Property matchers must be an object.\");\n    }\n    var propertyPass = context.equals(received, propertyMatchers, [context.utils.iterableEquality, context.utils.subsetEquality]);\n    if (!propertyPass) {\n      var key = snapshotState.fail(fullTestName, received);\n      var _report = function _report() {\n        return \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('Received value'), \" does not match \") + \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)(\"snapshot properties for \\\"\".concat(key, \"\\\"\")), \".\\n\\n\") + \"Expected snapshot to match properties:\\n\" + \"  \".concat(context.utils.printExpected(propertyMatchers)) + \"\\nReceived:\\n\" + \"  \".concat(context.utils.printReceived(received));\n      };\n      return {\n        message: function message() {\n          return (0, _jestMatcherUtils.matcherHint)('.toMatchSnapshot', 'value', 'properties') + '\\n\\n' + _report();\n        },\n        name: 'toMatchSnapshot',\n        pass: false,\n        report: _report\n      };\n    } else {\n      received = utils.deepMerge(received, propertyMatchers);\n    }\n  }\n  var result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot: inlineSnapshot,\n    received: received,\n    testName: fullTestName\n  });\n  var pass = result.pass;\n  var actual = result.actual,\n    expected = result.expected;\n  var report;\n  if (pass) {\n    return {\n      message: function message() {\n        return '';\n      },\n      pass: true\n    };\n  } else if (!expected) {\n    report = function report() {\n      return \"New snapshot was \".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('not written'), \". The update flag \") + \"must be explicitly passed to write a new snapshot.\\n\\n\" + \"This is likely because this test is run in a continuous integration \" + \"(CI) environment in which snapshots are not written by default.\\n\\n\" + \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('Received value'), \" \") + \"\".concat(actual);\n    };\n  } else {\n    expected = (expected || '').trim();\n    actual = (actual || '').trim();\n    var diffMessage = (0, _jestDiff2.default)(expected, actual, {\n      aAnnotation: 'Snapshot',\n      bAnnotation: 'Received',\n      expand: snapshotState.expand\n    });\n    report = function report() {\n      return \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('Received value'), \" does not match \") + \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)(\"stored snapshot \\\"\".concat(result.key, \"\\\"\")), \".\\n\\n\") + (diffMessage || (0, _jestMatcherUtils.EXPECTED_COLOR)('- ' + (expected || '')) + '\\n' + (0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + actual));\n    };\n  }\n  // Passing the the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n  return {\n    actual: actual,\n    expected: expected,\n    message: function message() {\n      return (0, _jestMatcherUtils.matcherHint)('.toMatchSnapshot', 'value', '') + '\\n\\n' + report();\n    },\n    name: 'toMatchSnapshot',\n    pass: false,\n    report: report\n  };\n};\nvar toThrowErrorMatchingSnapshot = function toThrowErrorMatchingSnapshot(received, testName, fromPromise) {\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    fromPromise: fromPromise,\n    received: received,\n    testName: testName\n  });\n};\nvar toThrowErrorMatchingInlineSnapshot = function toThrowErrorMatchingInlineSnapshot(received, inlineSnapshot, fromPromise) {\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    fromPromise: fromPromise,\n    inlineSnapshot: inlineSnapshot || '',\n    received: received\n  });\n};\nvar _toThrowErrorMatchingSnapshot = function _toThrowErrorMatchingSnapshot(_ref2) {\n  var context = _ref2.context,\n    received = _ref2.received,\n    testName = _ref2.testName,\n    fromPromise = _ref2.fromPromise,\n    inlineSnapshot = _ref2.inlineSnapshot;\n  context.dontThrow && context.dontThrow();\n  var isNot = context.isNot;\n  var matcherName = typeof inlineSnapshot === 'string' ? 'toThrowErrorMatchingInlineSnapshot' : 'toThrowErrorMatchingSnapshot';\n  if (isNot) {\n    throw new Error(\"Jest: `.not` cannot be used with `.\".concat(matcherName, \"()`.\"));\n  }\n  var error;\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n  if (error === undefined) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(\".\".concat(matcherName), '() => {}', '') + '\\n\\n' + \"Expected the function to throw an error.\\n\" + \"But it didn't throw anything.\");\n  }\n  return _toMatchSnapshot({\n    context: context,\n    inlineSnapshot: inlineSnapshot,\n    received: error.message,\n    testName: testName\n  });\n};\nmodule.exports = {\n  EXTENSION: utils.SNAPSHOT_EXTENSION,\n  SnapshotState: _State2.default,\n  addSerializer: _plugins.addSerializer,\n  cleanup: cleanup,\n  getSerializers: _plugins.getSerializers,\n  toMatchInlineSnapshot: toMatchInlineSnapshot,\n  toMatchSnapshot: toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot: toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot: toThrowErrorMatchingSnapshot,\n  utils: utils\n};","map":null,"metadata":{},"sourceType":"script"}