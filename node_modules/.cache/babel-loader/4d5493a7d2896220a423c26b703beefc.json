{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = require('path'),\n  fs = require('fs'),\n  existsSync = fs.existsSync,\n  CAMEL_PATTERN = /([a-z])([A-Z])/g,\n  YML_PATTERN = /\\.ya?ml$/,\n  yaml = require('js-yaml'),\n  libReport = require('istanbul-lib-report'),\n  inputError = require('./input-error');\nfunction defaultConfig() {\n  var ret = {\n    verbose: false,\n    instrumentation: {\n      root: '.',\n      extensions: ['.js'],\n      'default-excludes': true,\n      excludes: [],\n      variable: '__coverage__',\n      compact: true,\n      'preserve-comments': false,\n      'complete-copy': false,\n      'save-baseline': false,\n      'baseline-file': './coverage/coverage-baseline.raw.json',\n      'include-all-sources': false,\n      'include-pid': false,\n      'es-modules': false,\n      'auto-wrap': false\n    },\n    reporting: {\n      print: 'summary',\n      reports: ['lcov'],\n      dir: './coverage',\n      summarizer: 'pkg',\n      'report-config': {}\n    },\n    hooks: {\n      'hook-run-in-context': false,\n      'hook-run-in-this-context': false,\n      'post-require-hook': null,\n      'handle-sigint': false\n    },\n    check: {\n      global: {\n        statements: 0,\n        lines: 0,\n        branches: 0,\n        functions: 0,\n        excludes: [] // Currently list of files (root + path). For future, extend to patterns.\n      },\n\n      each: {\n        statements: 0,\n        lines: 0,\n        branches: 0,\n        functions: 0,\n        excludes: []\n      }\n    }\n  };\n  ret.reporting.watermarks = libReport.getDefaultWatermarks();\n  ret.reporting['report-config'] = {};\n  return ret;\n}\nfunction dasherize(word) {\n  return word.replace(CAMEL_PATTERN, function (match, lch, uch) {\n    return lch + '-' + uch.toLowerCase();\n  });\n}\nfunction isScalar(v) {\n  if (v === null) {\n    return true;\n  }\n  return v !== undefined && !Array.isArray(v) && typeof v !== 'object';\n}\nfunction isObject(v) {\n  return typeof v === 'object' && v !== null && !Array.isArray(v);\n}\nfunction mergeObjects(explicit, template, bothWays) {\n  var ret = {},\n    keys = Object.keys(template);\n  if (bothWays) {\n    keys.push.apply(keys, Object.keys(explicit));\n  }\n  keys.forEach(function (k) {\n    var v1 = template[k],\n      v2 = explicit[k];\n    if (Array.isArray(v1)) {\n      ret[k] = Array.isArray(v2) && v2.length > 0 ? v2 : v1;\n    } else if (isObject(v1)) {\n      v2 = isObject(v2) ? v2 : {};\n      ret[k] = mergeObjects(v2, v1, bothWays);\n    } else if (!v1 && v2) {\n      ret[k] = v2;\n    } else {\n      ret[k] = isScalar(v2) ? v2 : v1;\n    }\n  });\n  return ret;\n}\nfunction mergeDefaults(explicit, implicit) {\n  explicit = explicit || {};\n  var initialMerge = mergeObjects(explicit || {}, implicit),\n    explicitReportConfig = (explicit.reporting || {})['report-config'] || {},\n    implicitReportConfig = initialMerge.reporting['report-config'] || {};\n  initialMerge.reporting['report-config'] = mergeObjects(explicitReportConfig, implicitReportConfig, true);\n  return initialMerge;\n}\nfunction addMethods() {\n  var args = Array.prototype.slice.call(arguments),\n    cons = args.shift();\n  args.forEach(function (arg) {\n    var property = dasherize(arg);\n    cons.prototype[arg] = function () {\n      return this.config[property];\n    };\n  });\n}\n\n/**\n * Object that returns instrumentation options\n * @class InstrumentOptions\n * @module config\n * @constructor\n * @param config the instrumentation part of the config object\n */\nfunction InstrumentOptions(config) {\n  this.config = config;\n}\n\n/**\n * returns if default excludes should be turned on. Used by the `cover` command.\n * @method defaultExcludes\n * @return {Boolean} true if default excludes should be turned on\n */\n/**\n * returns if non-JS files should be copied during instrumentation. Used by the\n * `instrument` command.\n * @method completeCopy\n * @return {Boolean} true if non-JS files should be copied\n */\n/**\n * the coverage variable name to use. Used by the `instrument` command.\n * @method variable\n * @return {String} the coverage variable name to use\n */\n/**\n * returns if the output should be compact JS. Used by the `instrument` command.\n * @method compact\n * @return {Boolean} true if the output should be compact\n */\n/**\n * returns if comments should be preserved in the generated JS. Used by the\n * `cover` and `instrument` commands.\n * @method preserveComments\n * @return {Boolean} true if comments should be preserved in the generated JS\n */\n/**\n * returns if a zero-coverage baseline file should be written as part of\n * instrumentation. This allows reporting to display numbers for files that have\n * no tests. Used by the  `instrument` command.\n * @method saveBaseline\n * @return {Boolean} true if a baseline coverage file should be written.\n */\n/**\n * Sets the baseline coverage filename. Used by the  `instrument` command.\n * @method baselineFile\n * @return {String} the name of the baseline coverage file.\n */\n/**\n * returns if comments the JS to instrument contains es6 Module syntax.\n * @method esModules\n * @return {Boolean} true if code contains es6 import/export statements.\n */\n/**\n * returns if the coverage filename should include the PID. Used by the  `instrument` command.\n * @method includePid\n * @return {Boolean} true to include pid in coverage filename.\n */\n\naddMethods(InstrumentOptions, 'extensions', 'defaultExcludes', 'completeCopy', 'variable', 'compact', 'preserveComments', 'saveBaseline', 'baselineFile', 'esModules', 'includeAllSources', 'includePid', 'autoWrap');\n\n/**\n * returns the root directory used by istanbul which is typically the root of the\n * source tree. Used by the `cover` and `report` commands.\n * @method root\n * @return {String} the root directory used by istanbul.\n */\nInstrumentOptions.prototype.root = function () {\n  return path.resolve(this.config.root);\n};\n/**\n * returns an array of fileset patterns that should be excluded for instrumentation.\n * Used by the `instrument` and `cover` commands.\n * @method excludes\n * @return {Array} an array of fileset patterns that should be excluded for\n *  instrumentation.\n */\nInstrumentOptions.prototype.excludes = function (excludeTests) {\n  var defs;\n  if (this.defaultExcludes()) {\n    defs = ['**/node_modules/**'];\n    if (excludeTests) {\n      defs = defs.concat(['**/test/**', '**/tests/**']);\n    }\n    return defs.concat(this.config.excludes);\n  }\n  return this.config.excludes;\n};\nInstrumentOptions.prototype.getInstrumenterOpts = function () {\n  return {\n    coverageVariable: this.variable(),\n    compact: this.compact(),\n    preserveComments: this.preserveComments(),\n    esModules: this.esModules(),\n    autoWrap: this.autoWrap()\n  };\n};\n\n/**\n * Object that returns reporting options\n * @class ReportingOptions\n * @module config\n * @constructor\n * @param config the reporting part of the config object\n */\nfunction ReportingOptions(config) {\n  this.config = config;\n}\n\n/**\n * returns the kind of information to be printed on the console. May be one\n * of `summary`, `detail`, `both` or `none`. Used by the\n * `cover` command.\n * @method print\n * @return {String} the kind of information to print to the console at the end\n * of the `cover` command execution.\n */\n/**\n * returns a list of reports that should be generated at the end of a run. Used\n * by the `cover` and `report` commands.\n * @method reports\n * @return {Array} an array of reports that should be produced\n */\n/**\n * returns the directory under which reports should be generated. Used by the\n * `cover` and `report` commands.\n *\n * @method dir\n * @return {String} the directory under which reports should be generated.\n */\n/**\n * returns an object that has keys that are report format names and values that are objects\n * containing detailed configuration for each format. Running `istanbul help config`\n * will give you all the keys per report format that can be overridden.\n * Used by the `cover` and `report` commands.\n * @method reportConfig\n * @return {Object} detailed report configuration per report format.\n */\naddMethods(ReportingOptions, 'print', 'reports', 'dir', 'reportConfig', 'summarizer');\nfunction isInvalidMark(v, key) {\n  var prefix = 'Watermark for [' + key + '] :';\n  if (v.length !== 2) {\n    return prefix + 'must be an array of length 2';\n  }\n  v[0] = Number(v[0]);\n  v[1] = Number(v[1]);\n  if (isNaN(v[0]) || isNaN(v[1])) {\n    return prefix + 'must have valid numbers';\n  }\n  if (v[0] < 0 || v[1] < 0) {\n    return prefix + 'must be positive numbers';\n  }\n  if (v[1] > 100) {\n    return prefix + 'cannot exceed 100';\n  }\n  if (v[1] <= v[0]) {\n    return prefix + 'low must be less than high';\n  }\n  return null;\n}\n\n/**\n * returns the low and high watermarks to be used to designate whether coverage\n * is `low`, `medium` or `high`. Statements, functions, branches and lines can\n * have independent watermarks. These are respected by all reports\n * that color for low, medium and high coverage. See the default configuration for exact syntax\n * using `istanbul help config`. Used by the `cover` and `report` commands.\n *\n * @method watermarks\n * @return {Object} an object containing low and high watermarks for statements,\n *  branches, functions and lines.\n */\nReportingOptions.prototype.watermarks = function () {\n  var v = this.config.watermarks,\n    defs = libReport.getDefaultWatermarks(),\n    ret = {};\n  Object.keys(defs).forEach(function (k) {\n    var mark = v[k],\n      //it will already be a non-zero length array because of the way the merge works\n      message = isInvalidMark(mark, k);\n    if (message) {\n      console.error(message);\n      ret[k] = defs[k];\n    } else {\n      ret[k] = mark;\n    }\n  });\n  return ret;\n};\n\n/**\n * Object that returns hook options. Note that istanbul does not provide an\n * option to hook `require`. This is always done by the `cover` command.\n * @class HookOptions\n * @module config\n * @constructor\n * @param config the hooks part of the config object\n */\nfunction HookOptions(config) {\n  this.config = config;\n}\n\n/**\n * returns if `vm.runInContext` needs to be hooked. Used by the `cover` command.\n * @method hookRunInContext\n * @return {Boolean} true if `vm.runInContext` needs to be hooked for coverage\n */\n/**\n * returns if `vm.runInThisContext` needs to be hooked, in addition to the standard\n * `require` hooks added by istanbul. This should be true for code that uses\n * RequireJS for example. Used by the `cover` command.\n * @method hookRunInThisContext\n * @return {Boolean} true if `vm.runInThisContext` needs to be hooked for coverage\n */\n/**\n * returns a path to JS file or a dependent module that should be used for\n * post-processing files after they have been required. See the `yui-istanbul` module for\n * an example of a post-require hook. This particular hook modifies the yui loader when\n * that file is required to add istanbul interceptors. Use by the `cover` command\n *\n * @method postRequireHook\n * @return {String} a path to a JS file or the name of a node module that needs\n * to be used as a `require` post-processor\n */\n/**\n * returns if istanbul needs to add a SIGINT (control-c, usually) handler to\n * save coverage information. Useful for getting code coverage out of processes\n * that run forever and need a SIGINT to terminate.\n * @method handleSigint\n * @return {Boolean} true if SIGINT needs to be hooked to write coverage information\n */\n\naddMethods(HookOptions, 'hookRunInContext', 'hookRunInThisContext', 'postRequireHook', 'handleSigint');\n\n/**\n * represents the istanbul configuration and provides sub-objects that can\n * return instrumentation, reporting and hook options respectively.\n * Usage\n * -----\n *\n *      var configObj = require('istanbul').config.loadFile();\n *\n *      console.log(configObj.reporting.reports());\n *\n * @class Configuration\n * @module config\n * @param {Object} obj  the base object to use as the configuration\n * @param {Object} overrides optional - override attributes that are merged into\n *  the base config\n * @constructor\n */\nfunction Configuration(obj, overrides) {\n  var config = mergeDefaults(obj, defaultConfig(true));\n  if (isObject(overrides)) {\n    config = mergeDefaults(overrides, config);\n  }\n  if (config.verbose) {\n    console.error('Using configuration');\n    console.error('-------------------');\n    console.error(yaml.safeDump(config, {\n      indent: 4,\n      flowLevel: 3\n    }));\n    console.error('-------------------\\n');\n  }\n  this.verbose = config.verbose;\n  this.instrumentation = new InstrumentOptions(config.instrumentation);\n  this.reporting = new ReportingOptions(config.reporting);\n  this.hooks = new HookOptions(config.hooks);\n  this.check = config.check; // Pass raw config sub-object.\n}\n\n/**\n * true if verbose logging is required\n * @property verbose\n * @type Boolean\n */\n/**\n * instrumentation options\n * @property instrumentation\n * @type InstrumentOptions\n */\n/**\n * reporting options\n * @property reporting\n * @type ReportingOptions\n */\n/**\n * hook options\n * @property hooks\n * @type HookOptions\n */\n\nfunction loadFile(file, overrides) {\n  var defaultConfigFile = path.resolve('.istanbul.yml'),\n    configObject;\n  if (file) {\n    if (!existsSync(file)) {\n      throw inputError.create('Invalid configuration file specified:' + file);\n    }\n  } else {\n    if (existsSync(defaultConfigFile)) {\n      file = defaultConfigFile;\n    }\n  }\n  if (file) {\n    if (overrides && overrides.verbose === true) {\n      console.error('Loading config: ' + file);\n    }\n    configObject = file.match(YML_PATTERN) ? yaml.safeLoad(fs.readFileSync(file, 'utf8'), {\n      filename: file\n    }) : require(path.resolve(file));\n  }\n  return new Configuration(configObject, overrides);\n}\nfunction loadObject(obj, overrides) {\n  return new Configuration(obj, overrides);\n}\n\n/**\n * methods to load the configuration object.\n * Usage\n * -----\n *\n *      var config = require('istanbul').config,\n *          configObj = config.loadFile();\n *\n *      console.log(configObj.reporting.reports());\n *\n * @class Config\n * @module main\n * @static\n */\nmodule.exports = {\n  /**\n   * loads the specified configuration file with optional overrides. Throws\n   * when a file is specified and it is not found.\n   * @method loadFile\n   * @static\n   * @param {String} file the file to load. If falsy, the default config file, if present, is loaded.\n   *  If not a default config is used.\n   * @param {Object} overrides - an object with override keys that are merged into the\n   *  config object loaded\n   * @return {Configuration} the config object with overrides applied\n   */\n  loadFile: loadFile,\n  /**\n   * loads the specified configuration object with optional overrides.\n   * @method loadObject\n   * @static\n   * @param {Object} obj the object to use as the base configuration.\n   * @param {Object} overrides - an object with override keys that are merged into the\n   *  config object\n   * @return {Configuration} the config object with overrides applied\n   */\n  loadObject: loadObject,\n  /**\n   * returns the default configuration object. Note that this is a plain object\n   * and not a `Configuration` instance.\n   * @method defaultConfig\n   * @static\n   * @return {Object} an object that represents the default config\n   */\n  defaultConfig: defaultConfig\n};","map":null,"metadata":{},"sourceType":"script"}