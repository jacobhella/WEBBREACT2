{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nvar _t = require(\"@babel/types\");\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\nvar _visitors = require(\"../visitors\");\nvar arrowFunctionExpression = _t.arrowFunctionExpression,\n  assignmentExpression = _t.assignmentExpression,\n  binaryExpression = _t.binaryExpression,\n  blockStatement = _t.blockStatement,\n  callExpression = _t.callExpression,\n  conditionalExpression = _t.conditionalExpression,\n  expressionStatement = _t.expressionStatement,\n  identifier = _t.identifier,\n  isIdentifier = _t.isIdentifier,\n  jsxIdentifier = _t.jsxIdentifier,\n  logicalExpression = _t.logicalExpression,\n  LOGICAL_OPERATORS = _t.LOGICAL_OPERATORS,\n  memberExpression = _t.memberExpression,\n  metaProperty = _t.metaProperty,\n  numericLiteral = _t.numericLiteral,\n  objectExpression = _t.objectExpression,\n  restElement = _t.restElement,\n  returnStatement = _t.returnStatement,\n  sequenceExpression = _t.sequenceExpression,\n  spreadElement = _t.spreadElement,\n  stringLiteral = _t.stringLiteral,\n  _super = _t.super,\n  thisExpression = _t.thisExpression,\n  toExpression = _t.toExpression,\n  unaryExpression = _t.unaryExpression;\nfunction toComputedKey() {\n  var key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n  return key;\n}\nfunction ensureBlock() {\n  var body = this.get(\"body\");\n  var bodyNode = body.node;\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n  var statements = [];\n  var stringPath = \"body\";\n  var key;\n  var listKey;\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n  this.node.body = blockStatement(statements);\n  var parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n  hoistFunctionEnvironment(this);\n}\nfunction setType(path, type) {\n  path.node.type = type;\n}\nfunction arrowFunctionToExpression() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    _ref$allowInsertArrow = _ref.allowInsertArrow,\n    allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,\n    _ref$allowInsertArrow2 = _ref.allowInsertArrowWithRest,\n    allowInsertArrowWithRest = _ref$allowInsertArrow2 === void 0 ? allowInsertArrow : _ref$allowInsertArrow2,\n    _ref$specCompliant = _ref.specCompliant,\n    specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant,\n    _ref$noNewArrows = _ref.noNewArrows,\n    noNewArrows = _ref$noNewArrows === void 0 ? !specCompliant : _ref$noNewArrows;\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n  var _hoistFunctionEnviron = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow, allowInsertArrowWithRest),\n    thisBinding = _hoistFunctionEnviron.thisBinding,\n    fn = _hoistFunctionEnviron.fnPath;\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n  if (!noNewArrows) {\n    var checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n    return fn.get(\"callee.object\");\n  }\n  return fn;\n}\nvar getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression: function CallExpression(child, _ref2) {\n    var allSuperCalls = _ref2.allSuperCalls;\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n}, _helperEnvironmentVisitor.default]);\nfunction hoistFunctionEnvironment(fnPath) {\n  var noNewArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var allowInsertArrowWithRest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var arrowParent;\n  var thisEnvFn = fnPath.findParent(function (p) {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  var inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n  var _getScopeInformation = getScopeInformation(fnPath),\n    thisPaths = _getScopeInformation.thisPaths,\n    argumentsPaths = _getScopeInformation.argumentsPaths,\n    newTargetPaths = _getScopeInformation.newTargetPaths,\n    superProps = _getScopeInformation.superProps,\n    superCalls = _getScopeInformation.superCalls;\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"When using '@babel/plugin-transform-arrow-functions', \" + \"it's not possible to compile `super()` in an arrow function without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    if (!allowInsertArrowWithRest) {\n      throw superCalls[0].buildCodeFrameError(\"When using '@babel/plugin-transform-parameters', \" + \"it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    var allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls: allSuperCalls\n    });\n    var superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(function (superCall) {\n      var callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n  if (argumentsPaths.length > 0) {\n    var argumentsBinding = getBinding(thisEnvFn, \"arguments\", function () {\n      var args = function args() {\n        return identifier(\"arguments\");\n      };\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(function (argumentsChild) {\n      var argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n  if (newTargetPaths.length > 0) {\n    var newTargetBinding = getBinding(thisEnvFn, \"newtarget\", function () {\n      return metaProperty(identifier(\"new\"), identifier(\"target\"));\n    });\n    newTargetPaths.forEach(function (targetChild) {\n      var targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"When using '@babel/plugin-transform-arrow-functions', \" + \"it's not possible to compile `super.prop` in an arrow function without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    var flatSuperProps = superProps.reduce(function (acc, superProp) {\n      return acc.concat(standardizeSuperProperty(superProp));\n    }, []);\n    flatSuperProps.forEach(function (superProp) {\n      var key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      var superParentPath = superProp.parentPath;\n      var isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      var isCall = superParentPath.isCallExpression({\n        callee: superProp.node\n      });\n      var isTaggedTemplate = superParentPath.isTaggedTemplateExpression({\n        tag: superProp.node\n      });\n      var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      var args = [];\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n      if (isAssignment) {\n        var value = superParentPath.node.right;\n        args.push(value);\n      }\n      var call = callExpression(identifier(superBinding), args);\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superParentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superParentPath.replaceWith(call);\n      } else if (isTaggedTemplate) {\n        superProp.replaceWith(callExpression(memberExpression(call, identifier(\"bind\"), false), [thisExpression()]));\n        thisPaths.push(superProp.get(\"arguments.0\"));\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n  var thisBinding;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(function (thisChild) {\n        var thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n  return {\n    thisBinding: thisBinding,\n    fnPath: fnPath\n  };\n}\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    var assignmentPath = superProp.parentPath;\n    var op = assignmentPath.node.operator.slice(0, -1);\n    var value = assignmentPath.node.right;\n    var isLogicalAssignment = isLogicalOp(op);\n    if (superProp.node.computed) {\n      var tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      var object = superProp.node.object;\n      var property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      var _object = superProp.node.object;\n      var _property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(_object, _property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(_object, identifier(_property.name)), value));\n    }\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    var updateExpr = superProp.parentPath;\n    var _tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    var parts = [assignmentExpression(\"=\", _tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(_tmp.name), numericLiteral(1)))];\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(_tmp.name));\n    }\n    updateExpr.replaceWith(sequenceExpression(parts));\n    var left = updateExpr.get(\"expressions.0.right\");\n    var right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n  return [superProp];\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\nvar assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression: function CallExpression(child, _ref3) {\n    var supers = _ref3.supers,\n      thisBinding = _ref3.thisBinding;\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n}, _helperEnvironmentVisitor.default]);\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", function (thisBinding) {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding: thisBinding\n    });\n  });\n}\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", function () {\n    var argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  var op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, \"superprop_\".concat(op, \":\").concat(propName || \"\"), function () {\n    var argsList = [];\n    var fnBody;\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      var method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n    if (isAssignment) {\n      var valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\nfunction getBinding(thisEnvFn, key, init) {\n  var cacheKey = \"binding:\" + key;\n  var data = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    var id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n  return data;\n}\nvar getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression: function ThisExpression(child, _ref4) {\n    var thisPaths = _ref4.thisPaths;\n    thisPaths.push(child);\n  },\n  JSXIdentifier: function JSXIdentifier(child, _ref5) {\n    var thisPaths = _ref5.thisPaths;\n    if (child.node.name !== \"this\") return;\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n    thisPaths.push(child);\n  },\n  CallExpression: function CallExpression(child, _ref6) {\n    var superCalls = _ref6.superCalls;\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n  MemberExpression: function MemberExpression(child, _ref7) {\n    var superProps = _ref7.superProps;\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n  Identifier: function Identifier(child, _ref8) {\n    var argumentsPaths = _ref8.argumentsPaths;\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    var curr = child.scope;\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n    argumentsPaths.push(child);\n  },\n  MetaProperty: function MetaProperty(child, _ref9) {\n    var newTargetPaths = _ref9.newTargetPaths;\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n}, _helperEnvironmentVisitor.default]);\nfunction getScopeInformation(fnPath) {\n  var thisPaths = [];\n  var argumentsPaths = [];\n  var newTargetPaths = [];\n  var superProps = [];\n  var superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths: thisPaths,\n    argumentsPaths: argumentsPaths,\n    newTargetPaths: newTargetPaths,\n    superProps: superProps,\n    superCalls: superCalls\n  });\n  return {\n    thisPaths: thisPaths,\n    argumentsPaths: argumentsPaths,\n    newTargetPaths: newTargetPaths,\n    superProps: superProps,\n    superCalls: superCalls\n  };\n}","map":null,"metadata":{},"sourceType":"script"}