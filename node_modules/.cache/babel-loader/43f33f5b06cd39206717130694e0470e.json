{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar _symbol = require(\"babel-runtime/core-js/symbol\");\nvar _symbol2 = _interopRequireDefault(_symbol);\nvar _plugin = require(\"../plugin\");\nvar _plugin2 = _interopRequireDefault(_plugin);\nvar _babelTypes = require(\"babel-types\");\nvar t = _interopRequireWildcard(_babelTypes);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar SUPER_THIS_BOUND = (0, _symbol2.default)(\"super this bound\");\nvar superVisitor = {\n  CallExpression: function CallExpression(path) {\n    if (!path.get(\"callee\").isSuper()) return;\n    var node = path.node;\n    if (node[SUPER_THIS_BOUND]) return;\n    node[SUPER_THIS_BOUND] = true;\n    path.replaceWith(t.assignmentExpression(\"=\", this.id, node));\n  }\n};\nexports.default = new _plugin2.default({\n  name: \"internal.shadowFunctions\",\n  visitor: {\n    ThisExpression: function ThisExpression(path) {\n      remap(path, \"this\");\n    },\n    ReferencedIdentifier: function ReferencedIdentifier(path) {\n      if (path.node.name === \"arguments\") {\n        remap(path, \"arguments\");\n      }\n    }\n  }\n});\nfunction shouldShadow(path, shadowPath) {\n  if (path.is(\"_forceShadow\")) {\n    return true;\n  } else {\n    return shadowPath;\n  }\n}\nfunction remap(path, key) {\n  var shadowPath = path.inShadow(key);\n  if (!shouldShadow(path, shadowPath)) return;\n  var shadowFunction = path.node._shadowedFunctionLiteral;\n  var currentFunction = void 0;\n  var passedShadowFunction = false;\n  var fnPath = path.find(function (innerPath) {\n    if (innerPath.parentPath && innerPath.parentPath.isClassProperty() && innerPath.key === \"value\") {\n      return true;\n    }\n    if (path === innerPath) return false;\n    if (innerPath.isProgram() || innerPath.isFunction()) {\n      currentFunction = currentFunction || innerPath;\n    }\n    if (innerPath.isProgram()) {\n      passedShadowFunction = true;\n      return true;\n    } else if (innerPath.isFunction() && !innerPath.isArrowFunctionExpression()) {\n      if (shadowFunction) {\n        if (innerPath === shadowFunction || innerPath.node === shadowFunction.node) return true;\n      } else {\n        if (!innerPath.is(\"shadow\")) return true;\n      }\n      passedShadowFunction = true;\n      return false;\n    }\n    return false;\n  });\n  if (shadowFunction && fnPath.isProgram() && !shadowFunction.isProgram()) {\n    fnPath = path.findParent(function (p) {\n      return p.isProgram() || p.isFunction();\n    });\n  }\n  if (fnPath === currentFunction) return;\n  if (!passedShadowFunction) return;\n  var cached = fnPath.getData(key);\n  if (!cached) {\n    var id = path.scope.generateUidIdentifier(key);\n    fnPath.setData(key, id);\n    cached = id;\n    var classPath = fnPath.findParent(function (p) {\n      return p.isClass();\n    });\n    var hasSuperClass = !!(classPath && classPath.node && classPath.node.superClass);\n    if (key === \"this\" && fnPath.isMethod({\n      kind: \"constructor\"\n    }) && hasSuperClass) {\n      fnPath.scope.push({\n        id: id\n      });\n      fnPath.traverse(superVisitor, {\n        id: id\n      });\n    } else {\n      var init = key === \"this\" ? t.thisExpression() : t.identifier(key);\n      if (shadowFunction) init._shadowedFunctionLiteral = shadowFunction;\n      fnPath.scope.push({\n        id: id,\n        init: init\n      });\n    }\n  }\n  var node = t.cloneDeep(cached);\n  node.loc = path.node.loc;\n  return path.replaceWith(node);\n}\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}