{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.anyTypeAnnotation = anyTypeAnnotation;\nexports.argumentPlaceholder = argumentPlaceholder;\nexports.arrayExpression = arrayExpression;\nexports.arrayPattern = arrayPattern;\nexports.arrayTypeAnnotation = arrayTypeAnnotation;\nexports.arrowFunctionExpression = arrowFunctionExpression;\nexports.assignmentExpression = assignmentExpression;\nexports.assignmentPattern = assignmentPattern;\nexports.awaitExpression = awaitExpression;\nexports.bigIntLiteral = bigIntLiteral;\nexports.binaryExpression = binaryExpression;\nexports.bindExpression = bindExpression;\nexports.blockStatement = blockStatement;\nexports.booleanLiteral = booleanLiteral;\nexports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\nexports.booleanTypeAnnotation = booleanTypeAnnotation;\nexports.breakStatement = breakStatement;\nexports.callExpression = callExpression;\nexports.catchClause = catchClause;\nexports.classAccessorProperty = classAccessorProperty;\nexports.classBody = classBody;\nexports.classDeclaration = classDeclaration;\nexports.classExpression = classExpression;\nexports.classImplements = classImplements;\nexports.classMethod = classMethod;\nexports.classPrivateMethod = classPrivateMethod;\nexports.classPrivateProperty = classPrivateProperty;\nexports.classProperty = classProperty;\nexports.conditionalExpression = conditionalExpression;\nexports.continueStatement = continueStatement;\nexports.debuggerStatement = debuggerStatement;\nexports.decimalLiteral = decimalLiteral;\nexports.declareClass = declareClass;\nexports.declareExportAllDeclaration = declareExportAllDeclaration;\nexports.declareExportDeclaration = declareExportDeclaration;\nexports.declareFunction = declareFunction;\nexports.declareInterface = declareInterface;\nexports.declareModule = declareModule;\nexports.declareModuleExports = declareModuleExports;\nexports.declareOpaqueType = declareOpaqueType;\nexports.declareTypeAlias = declareTypeAlias;\nexports.declareVariable = declareVariable;\nexports.declaredPredicate = declaredPredicate;\nexports.decorator = decorator;\nexports.directive = directive;\nexports.directiveLiteral = directiveLiteral;\nexports.doExpression = doExpression;\nexports.doWhileStatement = doWhileStatement;\nexports.emptyStatement = emptyStatement;\nexports.emptyTypeAnnotation = emptyTypeAnnotation;\nexports.enumBooleanBody = enumBooleanBody;\nexports.enumBooleanMember = enumBooleanMember;\nexports.enumDeclaration = enumDeclaration;\nexports.enumDefaultedMember = enumDefaultedMember;\nexports.enumNumberBody = enumNumberBody;\nexports.enumNumberMember = enumNumberMember;\nexports.enumStringBody = enumStringBody;\nexports.enumStringMember = enumStringMember;\nexports.enumSymbolBody = enumSymbolBody;\nexports.existsTypeAnnotation = existsTypeAnnotation;\nexports.exportAllDeclaration = exportAllDeclaration;\nexports.exportDefaultDeclaration = exportDefaultDeclaration;\nexports.exportDefaultSpecifier = exportDefaultSpecifier;\nexports.exportNamedDeclaration = exportNamedDeclaration;\nexports.exportNamespaceSpecifier = exportNamespaceSpecifier;\nexports.exportSpecifier = exportSpecifier;\nexports.expressionStatement = expressionStatement;\nexports.file = file;\nexports.forInStatement = forInStatement;\nexports.forOfStatement = forOfStatement;\nexports.forStatement = forStatement;\nexports.functionDeclaration = functionDeclaration;\nexports.functionExpression = functionExpression;\nexports.functionTypeAnnotation = functionTypeAnnotation;\nexports.functionTypeParam = functionTypeParam;\nexports.genericTypeAnnotation = genericTypeAnnotation;\nexports.identifier = identifier;\nexports.ifStatement = ifStatement;\nexports.import = _import;\nexports.importAttribute = importAttribute;\nexports.importDeclaration = importDeclaration;\nexports.importDefaultSpecifier = importDefaultSpecifier;\nexports.importNamespaceSpecifier = importNamespaceSpecifier;\nexports.importSpecifier = importSpecifier;\nexports.indexedAccessType = indexedAccessType;\nexports.inferredPredicate = inferredPredicate;\nexports.interfaceDeclaration = interfaceDeclaration;\nexports.interfaceExtends = interfaceExtends;\nexports.interfaceTypeAnnotation = interfaceTypeAnnotation;\nexports.interpreterDirective = interpreterDirective;\nexports.intersectionTypeAnnotation = intersectionTypeAnnotation;\nexports.jSXAttribute = exports.jsxAttribute = jsxAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;\nexports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;\nexports.jSXElement = exports.jsxElement = jsxElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;\nexports.jSXFragment = exports.jsxFragment = jsxFragment;\nexports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;\nexports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;\nexports.jSXText = exports.jsxText = jsxText;\nexports.labeledStatement = labeledStatement;\nexports.logicalExpression = logicalExpression;\nexports.memberExpression = memberExpression;\nexports.metaProperty = metaProperty;\nexports.mixedTypeAnnotation = mixedTypeAnnotation;\nexports.moduleExpression = moduleExpression;\nexports.newExpression = newExpression;\nexports.noop = noop;\nexports.nullLiteral = nullLiteral;\nexports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\nexports.nullableTypeAnnotation = nullableTypeAnnotation;\nexports.numberLiteral = NumberLiteral;\nexports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = numberTypeAnnotation;\nexports.numericLiteral = numericLiteral;\nexports.objectExpression = objectExpression;\nexports.objectMethod = objectMethod;\nexports.objectPattern = objectPattern;\nexports.objectProperty = objectProperty;\nexports.objectTypeAnnotation = objectTypeAnnotation;\nexports.objectTypeCallProperty = objectTypeCallProperty;\nexports.objectTypeIndexer = objectTypeIndexer;\nexports.objectTypeInternalSlot = objectTypeInternalSlot;\nexports.objectTypeProperty = objectTypeProperty;\nexports.objectTypeSpreadProperty = objectTypeSpreadProperty;\nexports.opaqueType = opaqueType;\nexports.optionalCallExpression = optionalCallExpression;\nexports.optionalIndexedAccessType = optionalIndexedAccessType;\nexports.optionalMemberExpression = optionalMemberExpression;\nexports.parenthesizedExpression = parenthesizedExpression;\nexports.pipelineBareFunction = pipelineBareFunction;\nexports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\nexports.pipelineTopicExpression = pipelineTopicExpression;\nexports.placeholder = placeholder;\nexports.privateName = privateName;\nexports.program = program;\nexports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\nexports.recordExpression = recordExpression;\nexports.regExpLiteral = regExpLiteral;\nexports.regexLiteral = RegexLiteral;\nexports.restElement = restElement;\nexports.restProperty = RestProperty;\nexports.returnStatement = returnStatement;\nexports.sequenceExpression = sequenceExpression;\nexports.spreadElement = spreadElement;\nexports.spreadProperty = SpreadProperty;\nexports.staticBlock = staticBlock;\nexports.stringLiteral = stringLiteral;\nexports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = stringTypeAnnotation;\nexports.super = _super;\nexports.switchCase = switchCase;\nexports.switchStatement = switchStatement;\nexports.symbolTypeAnnotation = symbolTypeAnnotation;\nexports.taggedTemplateExpression = taggedTemplateExpression;\nexports.templateElement = templateElement;\nexports.templateLiteral = templateLiteral;\nexports.thisExpression = thisExpression;\nexports.thisTypeAnnotation = thisTypeAnnotation;\nexports.throwStatement = throwStatement;\nexports.topicReference = topicReference;\nexports.tryStatement = tryStatement;\nexports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;\nexports.tSArrayType = exports.tsArrayType = tsArrayType;\nexports.tSAsExpression = exports.tsAsExpression = tsAsExpression;\nexports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\nexports.tSConditionalType = exports.tsConditionalType = tsConditionalType;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\nexports.tSConstructorType = exports.tsConstructorType = tsConstructorType;\nexports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = tsEnumMember;\nexports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;\nexports.tSFunctionType = exports.tsFunctionType = tsFunctionType;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\nexports.tSImportType = exports.tsImportType = tsImportType;\nexports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;\nexports.tSInferType = exports.tsInferType = tsInferType;\nexports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;\nexports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;\nexports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;\nexports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;\nexports.tSLiteralType = exports.tsLiteralType = tsLiteralType;\nexports.tSMappedType = exports.tsMappedType = tsMappedType;\nexports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;\nexports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;\nexports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\nexports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;\nexports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;\nexports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;\nexports.tSOptionalType = exports.tsOptionalType = tsOptionalType;\nexports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;\nexports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;\nexports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;\nexports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;\nexports.tSRestType = exports.tsRestType = tsRestType;\nexports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;\nexports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;\nexports.tSThisType = exports.tsThisType = tsThisType;\nexports.tSTupleType = exports.tsTupleType = tsTupleType;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;\nexports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;\nexports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;\nexports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;\nexports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\nexports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;\nexports.tSTypeReference = exports.tsTypeReference = tsTypeReference;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;\nexports.tSUnionType = exports.tsUnionType = tsUnionType;\nexports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;\nexports.tupleExpression = tupleExpression;\nexports.tupleTypeAnnotation = tupleTypeAnnotation;\nexports.typeAlias = typeAlias;\nexports.typeAnnotation = typeAnnotation;\nexports.typeCastExpression = typeCastExpression;\nexports.typeParameter = typeParameter;\nexports.typeParameterDeclaration = typeParameterDeclaration;\nexports.typeParameterInstantiation = typeParameterInstantiation;\nexports.typeofTypeAnnotation = typeofTypeAnnotation;\nexports.unaryExpression = unaryExpression;\nexports.unionTypeAnnotation = unionTypeAnnotation;\nexports.updateExpression = updateExpression;\nexports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\nexports.variableDeclaration = variableDeclaration;\nexports.variableDeclarator = variableDeclarator;\nexports.variance = variance;\nexports.voidTypeAnnotation = voidTypeAnnotation;\nexports.whileStatement = whileStatement;\nexports.withStatement = withStatement;\nexports.yieldExpression = yieldExpression;\nvar _validateNode = require(\"../validateNode\");\nvar _deprecationWarning = require(\"../../utils/deprecationWarning\");\nfunction arrayExpression() {\n  var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return (0, _validateNode.default)({\n    type: \"ArrayExpression\",\n    elements: elements\n  });\n}\nfunction assignmentExpression(operator, left, right) {\n  return (0, _validateNode.default)({\n    type: \"AssignmentExpression\",\n    operator: operator,\n    left: left,\n    right: right\n  });\n}\nfunction binaryExpression(operator, left, right) {\n  return (0, _validateNode.default)({\n    type: \"BinaryExpression\",\n    operator: operator,\n    left: left,\n    right: right\n  });\n}\nfunction interpreterDirective(value) {\n  return (0, _validateNode.default)({\n    type: \"InterpreterDirective\",\n    value: value\n  });\n}\nfunction directive(value) {\n  return (0, _validateNode.default)({\n    type: \"Directive\",\n    value: value\n  });\n}\nfunction directiveLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"DirectiveLiteral\",\n    value: value\n  });\n}\nfunction blockStatement(body) {\n  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return (0, _validateNode.default)({\n    type: \"BlockStatement\",\n    body: body,\n    directives: directives\n  });\n}\nfunction breakStatement() {\n  var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return (0, _validateNode.default)({\n    type: \"BreakStatement\",\n    label: label\n  });\n}\nfunction callExpression(callee, _arguments) {\n  return (0, _validateNode.default)({\n    type: \"CallExpression\",\n    callee: callee,\n    arguments: _arguments\n  });\n}\nfunction catchClause() {\n  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var body = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, _validateNode.default)({\n    type: \"CatchClause\",\n    param: param,\n    body: body\n  });\n}\nfunction conditionalExpression(test, consequent, alternate) {\n  return (0, _validateNode.default)({\n    type: \"ConditionalExpression\",\n    test: test,\n    consequent: consequent,\n    alternate: alternate\n  });\n}\nfunction continueStatement() {\n  var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return (0, _validateNode.default)({\n    type: \"ContinueStatement\",\n    label: label\n  });\n}\nfunction debuggerStatement() {\n  return {\n    type: \"DebuggerStatement\"\n  };\n}\nfunction doWhileStatement(test, body) {\n  return (0, _validateNode.default)({\n    type: \"DoWhileStatement\",\n    test: test,\n    body: body\n  });\n}\nfunction emptyStatement() {\n  return {\n    type: \"EmptyStatement\"\n  };\n}\nfunction expressionStatement(expression) {\n  return (0, _validateNode.default)({\n    type: \"ExpressionStatement\",\n    expression: expression\n  });\n}\nfunction file(program) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var tokens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"File\",\n    program: program,\n    comments: comments,\n    tokens: tokens\n  });\n}\nfunction forInStatement(left, right, body) {\n  return (0, _validateNode.default)({\n    type: \"ForInStatement\",\n    left: left,\n    right: right,\n    body: body\n  });\n}\nfunction forStatement() {\n  var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var test = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"ForStatement\",\n    init: init,\n    test: test,\n    update: update,\n    body: body\n  });\n}\nfunction functionDeclaration() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var params = arguments.length > 1 ? arguments[1] : undefined;\n  var body = arguments.length > 2 ? arguments[2] : undefined;\n  var generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return (0, _validateNode.default)({\n    type: \"FunctionDeclaration\",\n    id: id,\n    params: params,\n    body: body,\n    generator: generator,\n    async: async\n  });\n}\nfunction functionExpression() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var params = arguments.length > 1 ? arguments[1] : undefined;\n  var body = arguments.length > 2 ? arguments[2] : undefined;\n  var generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return (0, _validateNode.default)({\n    type: \"FunctionExpression\",\n    id: id,\n    params: params,\n    body: body,\n    generator: generator,\n    async: async\n  });\n}\nfunction identifier(name) {\n  return (0, _validateNode.default)({\n    type: \"Identifier\",\n    name: name\n  });\n}\nfunction ifStatement(test, consequent) {\n  var alternate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"IfStatement\",\n    test: test,\n    consequent: consequent,\n    alternate: alternate\n  });\n}\nfunction labeledStatement(label, body) {\n  return (0, _validateNode.default)({\n    type: \"LabeledStatement\",\n    label: label,\n    body: body\n  });\n}\nfunction stringLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"StringLiteral\",\n    value: value\n  });\n}\nfunction numericLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"NumericLiteral\",\n    value: value\n  });\n}\nfunction nullLiteral() {\n  return {\n    type: \"NullLiteral\"\n  };\n}\nfunction booleanLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"BooleanLiteral\",\n    value: value\n  });\n}\nfunction regExpLiteral(pattern) {\n  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  return (0, _validateNode.default)({\n    type: \"RegExpLiteral\",\n    pattern: pattern,\n    flags: flags\n  });\n}\nfunction logicalExpression(operator, left, right) {\n  return (0, _validateNode.default)({\n    type: \"LogicalExpression\",\n    operator: operator,\n    left: left,\n    right: right\n  });\n}\nfunction memberExpression(object, property) {\n  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var optional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"MemberExpression\",\n    object: object,\n    property: property,\n    computed: computed,\n    optional: optional\n  });\n}\nfunction newExpression(callee, _arguments) {\n  return (0, _validateNode.default)({\n    type: \"NewExpression\",\n    callee: callee,\n    arguments: _arguments\n  });\n}\nfunction program(body) {\n  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var sourceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"script\";\n  var interpreter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"Program\",\n    body: body,\n    directives: directives,\n    sourceType: sourceType,\n    interpreter: interpreter,\n    sourceFile: null\n  });\n}\nfunction objectExpression(properties) {\n  return (0, _validateNode.default)({\n    type: \"ObjectExpression\",\n    properties: properties\n  });\n}\nfunction objectMethod() {\n  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"method\";\n  var key = arguments.length > 1 ? arguments[1] : undefined;\n  var params = arguments.length > 2 ? arguments[2] : undefined;\n  var body = arguments.length > 3 ? arguments[3] : undefined;\n  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var generator = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var async = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  return (0, _validateNode.default)({\n    type: \"ObjectMethod\",\n    kind: kind,\n    key: key,\n    params: params,\n    body: body,\n    computed: computed,\n    generator: generator,\n    async: async\n  });\n}\nfunction objectProperty(key, value) {\n  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var shorthand = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var decorators = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  return (0, _validateNode.default)({\n    type: \"ObjectProperty\",\n    key: key,\n    value: value,\n    computed: computed,\n    shorthand: shorthand,\n    decorators: decorators\n  });\n}\nfunction restElement(argument) {\n  return (0, _validateNode.default)({\n    type: \"RestElement\",\n    argument: argument\n  });\n}\nfunction returnStatement() {\n  var argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return (0, _validateNode.default)({\n    type: \"ReturnStatement\",\n    argument: argument\n  });\n}\nfunction sequenceExpression(expressions) {\n  return (0, _validateNode.default)({\n    type: \"SequenceExpression\",\n    expressions: expressions\n  });\n}\nfunction parenthesizedExpression(expression) {\n  return (0, _validateNode.default)({\n    type: \"ParenthesizedExpression\",\n    expression: expression\n  });\n}\nfunction switchCase() {\n  var test = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var consequent = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, _validateNode.default)({\n    type: \"SwitchCase\",\n    test: test,\n    consequent: consequent\n  });\n}\nfunction switchStatement(discriminant, cases) {\n  return (0, _validateNode.default)({\n    type: \"SwitchStatement\",\n    discriminant: discriminant,\n    cases: cases\n  });\n}\nfunction thisExpression() {\n  return {\n    type: \"ThisExpression\"\n  };\n}\nfunction throwStatement(argument) {\n  return (0, _validateNode.default)({\n    type: \"ThrowStatement\",\n    argument: argument\n  });\n}\nfunction tryStatement(block) {\n  var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var finalizer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TryStatement\",\n    block: block,\n    handler: handler,\n    finalizer: finalizer\n  });\n}\nfunction unaryExpression(operator, argument) {\n  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (0, _validateNode.default)({\n    type: \"UnaryExpression\",\n    operator: operator,\n    argument: argument,\n    prefix: prefix\n  });\n}\nfunction updateExpression(operator, argument) {\n  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _validateNode.default)({\n    type: \"UpdateExpression\",\n    operator: operator,\n    argument: argument,\n    prefix: prefix\n  });\n}\nfunction variableDeclaration(kind, declarations) {\n  return (0, _validateNode.default)({\n    type: \"VariableDeclaration\",\n    kind: kind,\n    declarations: declarations\n  });\n}\nfunction variableDeclarator(id) {\n  var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"VariableDeclarator\",\n    id: id,\n    init: init\n  });\n}\nfunction whileStatement(test, body) {\n  return (0, _validateNode.default)({\n    type: \"WhileStatement\",\n    test: test,\n    body: body\n  });\n}\nfunction withStatement(object, body) {\n  return (0, _validateNode.default)({\n    type: \"WithStatement\",\n    object: object,\n    body: body\n  });\n}\nfunction assignmentPattern(left, right) {\n  return (0, _validateNode.default)({\n    type: \"AssignmentPattern\",\n    left: left,\n    right: right\n  });\n}\nfunction arrayPattern(elements) {\n  return (0, _validateNode.default)({\n    type: \"ArrayPattern\",\n    elements: elements\n  });\n}\nfunction arrowFunctionExpression(params, body) {\n  var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _validateNode.default)({\n    type: \"ArrowFunctionExpression\",\n    params: params,\n    body: body,\n    async: async,\n    expression: null\n  });\n}\nfunction classBody(body) {\n  return (0, _validateNode.default)({\n    type: \"ClassBody\",\n    body: body\n  });\n}\nfunction classExpression() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var body = arguments.length > 2 ? arguments[2] : undefined;\n  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"ClassExpression\",\n    id: id,\n    superClass: superClass,\n    body: body,\n    decorators: decorators\n  });\n}\nfunction classDeclaration(id) {\n  var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var body = arguments.length > 2 ? arguments[2] : undefined;\n  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"ClassDeclaration\",\n    id: id,\n    superClass: superClass,\n    body: body,\n    decorators: decorators\n  });\n}\nfunction exportAllDeclaration(source) {\n  return (0, _validateNode.default)({\n    type: \"ExportAllDeclaration\",\n    source: source\n  });\n}\nfunction exportDefaultDeclaration(declaration) {\n  return (0, _validateNode.default)({\n    type: \"ExportDefaultDeclaration\",\n    declaration: declaration\n  });\n}\nfunction exportNamedDeclaration() {\n  var declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"ExportNamedDeclaration\",\n    declaration: declaration,\n    specifiers: specifiers,\n    source: source\n  });\n}\nfunction exportSpecifier(local, exported) {\n  return (0, _validateNode.default)({\n    type: \"ExportSpecifier\",\n    local: local,\n    exported: exported\n  });\n}\nfunction forOfStatement(left, right, body) {\n  var _await = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return (0, _validateNode.default)({\n    type: \"ForOfStatement\",\n    left: left,\n    right: right,\n    body: body,\n    await: _await\n  });\n}\nfunction importDeclaration(specifiers, source) {\n  return (0, _validateNode.default)({\n    type: \"ImportDeclaration\",\n    specifiers: specifiers,\n    source: source\n  });\n}\nfunction importDefaultSpecifier(local) {\n  return (0, _validateNode.default)({\n    type: \"ImportDefaultSpecifier\",\n    local: local\n  });\n}\nfunction importNamespaceSpecifier(local) {\n  return (0, _validateNode.default)({\n    type: \"ImportNamespaceSpecifier\",\n    local: local\n  });\n}\nfunction importSpecifier(local, imported) {\n  return (0, _validateNode.default)({\n    type: \"ImportSpecifier\",\n    local: local,\n    imported: imported\n  });\n}\nfunction metaProperty(meta, property) {\n  return (0, _validateNode.default)({\n    type: \"MetaProperty\",\n    meta: meta,\n    property: property\n  });\n}\nfunction classMethod() {\n  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"method\";\n  var key = arguments.length > 1 ? arguments[1] : undefined;\n  var params = arguments.length > 2 ? arguments[2] : undefined;\n  var body = arguments.length > 3 ? arguments[3] : undefined;\n  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var generator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var async = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassMethod\",\n    kind: kind,\n    key: key,\n    params: params,\n    body: body,\n    computed: computed,\n    static: _static,\n    generator: generator,\n    async: async\n  });\n}\nfunction objectPattern(properties) {\n  return (0, _validateNode.default)({\n    type: \"ObjectPattern\",\n    properties: properties\n  });\n}\nfunction spreadElement(argument) {\n  return (0, _validateNode.default)({\n    type: \"SpreadElement\",\n    argument: argument\n  });\n}\nfunction _super() {\n  return {\n    type: \"Super\"\n  };\n}\nfunction taggedTemplateExpression(tag, quasi) {\n  return (0, _validateNode.default)({\n    type: \"TaggedTemplateExpression\",\n    tag: tag,\n    quasi: quasi\n  });\n}\nfunction templateElement(value) {\n  var tail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (0, _validateNode.default)({\n    type: \"TemplateElement\",\n    value: value,\n    tail: tail\n  });\n}\nfunction templateLiteral(quasis, expressions) {\n  return (0, _validateNode.default)({\n    type: \"TemplateLiteral\",\n    quasis: quasis,\n    expressions: expressions\n  });\n}\nfunction yieldExpression() {\n  var argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (0, _validateNode.default)({\n    type: \"YieldExpression\",\n    argument: argument,\n    delegate: delegate\n  });\n}\nfunction awaitExpression(argument) {\n  return (0, _validateNode.default)({\n    type: \"AwaitExpression\",\n    argument: argument\n  });\n}\nfunction _import() {\n  return {\n    type: \"Import\"\n  };\n}\nfunction bigIntLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"BigIntLiteral\",\n    value: value\n  });\n}\nfunction exportNamespaceSpecifier(exported) {\n  return (0, _validateNode.default)({\n    type: \"ExportNamespaceSpecifier\",\n    exported: exported\n  });\n}\nfunction optionalMemberExpression(object, property) {\n  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var optional = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"OptionalMemberExpression\",\n    object: object,\n    property: property,\n    computed: computed,\n    optional: optional\n  });\n}\nfunction optionalCallExpression(callee, _arguments, optional) {\n  return (0, _validateNode.default)({\n    type: \"OptionalCallExpression\",\n    callee: callee,\n    arguments: _arguments,\n    optional: optional\n  });\n}\nfunction classProperty(key) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassProperty\",\n    key: key,\n    value: value,\n    typeAnnotation: typeAnnotation,\n    decorators: decorators,\n    computed: computed,\n    static: _static\n  });\n}\nfunction classAccessorProperty(key) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassAccessorProperty\",\n    key: key,\n    value: value,\n    typeAnnotation: typeAnnotation,\n    decorators: decorators,\n    computed: computed,\n    static: _static\n  });\n}\nfunction classPrivateProperty(key) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var decorators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var _static = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassPrivateProperty\",\n    key: key,\n    value: value,\n    decorators: decorators,\n    static: _static\n  });\n}\nfunction classPrivateMethod() {\n  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"method\";\n  var key = arguments.length > 1 ? arguments[1] : undefined;\n  var params = arguments.length > 2 ? arguments[2] : undefined;\n  var body = arguments.length > 3 ? arguments[3] : undefined;\n  var _static = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassPrivateMethod\",\n    kind: kind,\n    key: key,\n    params: params,\n    body: body,\n    static: _static\n  });\n}\nfunction privateName(id) {\n  return (0, _validateNode.default)({\n    type: \"PrivateName\",\n    id: id\n  });\n}\nfunction staticBlock(body) {\n  return (0, _validateNode.default)({\n    type: \"StaticBlock\",\n    body: body\n  });\n}\nfunction anyTypeAnnotation() {\n  return {\n    type: \"AnyTypeAnnotation\"\n  };\n}\nfunction arrayTypeAnnotation(elementType) {\n  return (0, _validateNode.default)({\n    type: \"ArrayTypeAnnotation\",\n    elementType: elementType\n  });\n}\nfunction booleanTypeAnnotation() {\n  return {\n    type: \"BooleanTypeAnnotation\"\n  };\n}\nfunction booleanLiteralTypeAnnotation(value) {\n  return (0, _validateNode.default)({\n    type: \"BooleanLiteralTypeAnnotation\",\n    value: value\n  });\n}\nfunction nullLiteralTypeAnnotation() {\n  return {\n    type: \"NullLiteralTypeAnnotation\"\n  };\n}\nfunction classImplements(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"ClassImplements\",\n    id: id,\n    typeParameters: typeParameters\n  });\n}\nfunction declareClass(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"DeclareClass\",\n    id: id,\n    typeParameters: typeParameters,\n    extends: _extends,\n    body: body\n  });\n}\nfunction declareFunction(id) {\n  return (0, _validateNode.default)({\n    type: \"DeclareFunction\",\n    id: id\n  });\n}\nfunction declareInterface(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"DeclareInterface\",\n    id: id,\n    typeParameters: typeParameters,\n    extends: _extends,\n    body: body\n  });\n}\nfunction declareModule(id, body) {\n  var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"DeclareModule\",\n    id: id,\n    body: body,\n    kind: kind\n  });\n}\nfunction declareModuleExports(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"DeclareModuleExports\",\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction declareTypeAlias(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var right = arguments.length > 2 ? arguments[2] : undefined;\n  return (0, _validateNode.default)({\n    type: \"DeclareTypeAlias\",\n    id: id,\n    typeParameters: typeParameters,\n    right: right\n  });\n}\nfunction declareOpaqueType(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"DeclareOpaqueType\",\n    id: id,\n    typeParameters: typeParameters,\n    supertype: supertype\n  });\n}\nfunction declareVariable(id) {\n  return (0, _validateNode.default)({\n    type: \"DeclareVariable\",\n    id: id\n  });\n}\nfunction declareExportDeclaration() {\n  var declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"DeclareExportDeclaration\",\n    declaration: declaration,\n    specifiers: specifiers,\n    source: source\n  });\n}\nfunction declareExportAllDeclaration(source) {\n  return (0, _validateNode.default)({\n    type: \"DeclareExportAllDeclaration\",\n    source: source\n  });\n}\nfunction declaredPredicate(value) {\n  return (0, _validateNode.default)({\n    type: \"DeclaredPredicate\",\n    value: value\n  });\n}\nfunction existsTypeAnnotation() {\n  return {\n    type: \"ExistsTypeAnnotation\"\n  };\n}\nfunction functionTypeAnnotation() {\n  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var params = arguments.length > 1 ? arguments[1] : undefined;\n  var rest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var returnType = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"FunctionTypeAnnotation\",\n    typeParameters: typeParameters,\n    params: params,\n    rest: rest,\n    returnType: returnType\n  });\n}\nfunction functionTypeParam() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var typeAnnotation = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, _validateNode.default)({\n    type: \"FunctionTypeParam\",\n    name: name,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction genericTypeAnnotation(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"GenericTypeAnnotation\",\n    id: id,\n    typeParameters: typeParameters\n  });\n}\nfunction inferredPredicate() {\n  return {\n    type: \"InferredPredicate\"\n  };\n}\nfunction interfaceExtends(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"InterfaceExtends\",\n    id: id,\n    typeParameters: typeParameters\n  });\n}\nfunction interfaceDeclaration(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"InterfaceDeclaration\",\n    id: id,\n    typeParameters: typeParameters,\n    extends: _extends,\n    body: body\n  });\n}\nfunction interfaceTypeAnnotation() {\n  var _extends = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var body = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, _validateNode.default)({\n    type: \"InterfaceTypeAnnotation\",\n    extends: _extends,\n    body: body\n  });\n}\nfunction intersectionTypeAnnotation(types) {\n  return (0, _validateNode.default)({\n    type: \"IntersectionTypeAnnotation\",\n    types: types\n  });\n}\nfunction mixedTypeAnnotation() {\n  return {\n    type: \"MixedTypeAnnotation\"\n  };\n}\nfunction emptyTypeAnnotation() {\n  return {\n    type: \"EmptyTypeAnnotation\"\n  };\n}\nfunction nullableTypeAnnotation(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"NullableTypeAnnotation\",\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction numberLiteralTypeAnnotation(value) {\n  return (0, _validateNode.default)({\n    type: \"NumberLiteralTypeAnnotation\",\n    value: value\n  });\n}\nfunction numberTypeAnnotation() {\n  return {\n    type: \"NumberTypeAnnotation\"\n  };\n}\nfunction objectTypeAnnotation(properties) {\n  var indexers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var callProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var internalSlots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var exact = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeAnnotation\",\n    properties: properties,\n    indexers: indexers,\n    callProperties: callProperties,\n    internalSlots: internalSlots,\n    exact: exact\n  });\n}\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeInternalSlot\",\n    id: id,\n    value: value,\n    optional: optional,\n    static: _static,\n    method: method\n  });\n}\nfunction objectTypeCallProperty(value) {\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeCallProperty\",\n    value: value,\n    static: null\n  });\n}\nfunction objectTypeIndexer() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var key = arguments.length > 1 ? arguments[1] : undefined;\n  var value = arguments.length > 2 ? arguments[2] : undefined;\n  var variance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeIndexer\",\n    id: id,\n    key: key,\n    value: value,\n    variance: variance,\n    static: null\n  });\n}\nfunction objectTypeProperty(key, value) {\n  var variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeProperty\",\n    key: key,\n    value: value,\n    variance: variance,\n    kind: null,\n    method: null,\n    optional: null,\n    proto: null,\n    static: null\n  });\n}\nfunction objectTypeSpreadProperty(argument) {\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeSpreadProperty\",\n    argument: argument\n  });\n}\nfunction opaqueType(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var impltype = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"OpaqueType\",\n    id: id,\n    typeParameters: typeParameters,\n    supertype: supertype,\n    impltype: impltype\n  });\n}\nfunction qualifiedTypeIdentifier(id, qualification) {\n  return (0, _validateNode.default)({\n    type: \"QualifiedTypeIdentifier\",\n    id: id,\n    qualification: qualification\n  });\n}\nfunction stringLiteralTypeAnnotation(value) {\n  return (0, _validateNode.default)({\n    type: \"StringLiteralTypeAnnotation\",\n    value: value\n  });\n}\nfunction stringTypeAnnotation() {\n  return {\n    type: \"StringTypeAnnotation\"\n  };\n}\nfunction symbolTypeAnnotation() {\n  return {\n    type: \"SymbolTypeAnnotation\"\n  };\n}\nfunction thisTypeAnnotation() {\n  return {\n    type: \"ThisTypeAnnotation\"\n  };\n}\nfunction tupleTypeAnnotation(types) {\n  return (0, _validateNode.default)({\n    type: \"TupleTypeAnnotation\",\n    types: types\n  });\n}\nfunction typeofTypeAnnotation(argument) {\n  return (0, _validateNode.default)({\n    type: \"TypeofTypeAnnotation\",\n    argument: argument\n  });\n}\nfunction typeAlias(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var right = arguments.length > 2 ? arguments[2] : undefined;\n  return (0, _validateNode.default)({\n    type: \"TypeAlias\",\n    id: id,\n    typeParameters: typeParameters,\n    right: right\n  });\n}\nfunction typeAnnotation(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TypeAnnotation\",\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction typeCastExpression(expression, typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TypeCastExpression\",\n    expression: expression,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction typeParameter() {\n  var bound = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TypeParameter\",\n    bound: bound,\n    default: _default,\n    variance: variance,\n    name: null\n  });\n}\nfunction typeParameterDeclaration(params) {\n  return (0, _validateNode.default)({\n    type: \"TypeParameterDeclaration\",\n    params: params\n  });\n}\nfunction typeParameterInstantiation(params) {\n  return (0, _validateNode.default)({\n    type: \"TypeParameterInstantiation\",\n    params: params\n  });\n}\nfunction unionTypeAnnotation(types) {\n  return (0, _validateNode.default)({\n    type: \"UnionTypeAnnotation\",\n    types: types\n  });\n}\nfunction variance(kind) {\n  return (0, _validateNode.default)({\n    type: \"Variance\",\n    kind: kind\n  });\n}\nfunction voidTypeAnnotation() {\n  return {\n    type: \"VoidTypeAnnotation\"\n  };\n}\nfunction enumDeclaration(id, body) {\n  return (0, _validateNode.default)({\n    type: \"EnumDeclaration\",\n    id: id,\n    body: body\n  });\n}\nfunction enumBooleanBody(members) {\n  return (0, _validateNode.default)({\n    type: \"EnumBooleanBody\",\n    members: members,\n    explicitType: null,\n    hasUnknownMembers: null\n  });\n}\nfunction enumNumberBody(members) {\n  return (0, _validateNode.default)({\n    type: \"EnumNumberBody\",\n    members: members,\n    explicitType: null,\n    hasUnknownMembers: null\n  });\n}\nfunction enumStringBody(members) {\n  return (0, _validateNode.default)({\n    type: \"EnumStringBody\",\n    members: members,\n    explicitType: null,\n    hasUnknownMembers: null\n  });\n}\nfunction enumSymbolBody(members) {\n  return (0, _validateNode.default)({\n    type: \"EnumSymbolBody\",\n    members: members,\n    hasUnknownMembers: null\n  });\n}\nfunction enumBooleanMember(id) {\n  return (0, _validateNode.default)({\n    type: \"EnumBooleanMember\",\n    id: id,\n    init: null\n  });\n}\nfunction enumNumberMember(id, init) {\n  return (0, _validateNode.default)({\n    type: \"EnumNumberMember\",\n    id: id,\n    init: init\n  });\n}\nfunction enumStringMember(id, init) {\n  return (0, _validateNode.default)({\n    type: \"EnumStringMember\",\n    id: id,\n    init: init\n  });\n}\nfunction enumDefaultedMember(id) {\n  return (0, _validateNode.default)({\n    type: \"EnumDefaultedMember\",\n    id: id\n  });\n}\nfunction indexedAccessType(objectType, indexType) {\n  return (0, _validateNode.default)({\n    type: \"IndexedAccessType\",\n    objectType: objectType,\n    indexType: indexType\n  });\n}\nfunction optionalIndexedAccessType(objectType, indexType) {\n  return (0, _validateNode.default)({\n    type: \"OptionalIndexedAccessType\",\n    objectType: objectType,\n    indexType: indexType,\n    optional: null\n  });\n}\nfunction jsxAttribute(name) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"JSXAttribute\",\n    name: name,\n    value: value\n  });\n}\nfunction jsxClosingElement(name) {\n  return (0, _validateNode.default)({\n    type: \"JSXClosingElement\",\n    name: name\n  });\n}\nfunction jsxElement(openingElement) {\n  var closingElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var children = arguments.length > 2 ? arguments[2] : undefined;\n  var selfClosing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"JSXElement\",\n    openingElement: openingElement,\n    closingElement: closingElement,\n    children: children,\n    selfClosing: selfClosing\n  });\n}\nfunction jsxEmptyExpression() {\n  return {\n    type: \"JSXEmptyExpression\"\n  };\n}\nfunction jsxExpressionContainer(expression) {\n  return (0, _validateNode.default)({\n    type: \"JSXExpressionContainer\",\n    expression: expression\n  });\n}\nfunction jsxSpreadChild(expression) {\n  return (0, _validateNode.default)({\n    type: \"JSXSpreadChild\",\n    expression: expression\n  });\n}\nfunction jsxIdentifier(name) {\n  return (0, _validateNode.default)({\n    type: \"JSXIdentifier\",\n    name: name\n  });\n}\nfunction jsxMemberExpression(object, property) {\n  return (0, _validateNode.default)({\n    type: \"JSXMemberExpression\",\n    object: object,\n    property: property\n  });\n}\nfunction jsxNamespacedName(namespace, name) {\n  return (0, _validateNode.default)({\n    type: \"JSXNamespacedName\",\n    namespace: namespace,\n    name: name\n  });\n}\nfunction jsxOpeningElement(name, attributes) {\n  var selfClosing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _validateNode.default)({\n    type: \"JSXOpeningElement\",\n    name: name,\n    attributes: attributes,\n    selfClosing: selfClosing\n  });\n}\nfunction jsxSpreadAttribute(argument) {\n  return (0, _validateNode.default)({\n    type: \"JSXSpreadAttribute\",\n    argument: argument\n  });\n}\nfunction jsxText(value) {\n  return (0, _validateNode.default)({\n    type: \"JSXText\",\n    value: value\n  });\n}\nfunction jsxFragment(openingFragment, closingFragment, children) {\n  return (0, _validateNode.default)({\n    type: \"JSXFragment\",\n    openingFragment: openingFragment,\n    closingFragment: closingFragment,\n    children: children\n  });\n}\nfunction jsxOpeningFragment() {\n  return {\n    type: \"JSXOpeningFragment\"\n  };\n}\nfunction jsxClosingFragment() {\n  return {\n    type: \"JSXClosingFragment\"\n  };\n}\nfunction noop() {\n  return {\n    type: \"Noop\"\n  };\n}\nfunction placeholder(expectedNode, name) {\n  return (0, _validateNode.default)({\n    type: \"Placeholder\",\n    expectedNode: expectedNode,\n    name: name\n  });\n}\nfunction v8IntrinsicIdentifier(name) {\n  return (0, _validateNode.default)({\n    type: \"V8IntrinsicIdentifier\",\n    name: name\n  });\n}\nfunction argumentPlaceholder() {\n  return {\n    type: \"ArgumentPlaceholder\"\n  };\n}\nfunction bindExpression(object, callee) {\n  return (0, _validateNode.default)({\n    type: \"BindExpression\",\n    object: object,\n    callee: callee\n  });\n}\nfunction importAttribute(key, value) {\n  return (0, _validateNode.default)({\n    type: \"ImportAttribute\",\n    key: key,\n    value: value\n  });\n}\nfunction decorator(expression) {\n  return (0, _validateNode.default)({\n    type: \"Decorator\",\n    expression: expression\n  });\n}\nfunction doExpression(body) {\n  var async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (0, _validateNode.default)({\n    type: \"DoExpression\",\n    body: body,\n    async: async\n  });\n}\nfunction exportDefaultSpecifier(exported) {\n  return (0, _validateNode.default)({\n    type: \"ExportDefaultSpecifier\",\n    exported: exported\n  });\n}\nfunction recordExpression(properties) {\n  return (0, _validateNode.default)({\n    type: \"RecordExpression\",\n    properties: properties\n  });\n}\nfunction tupleExpression() {\n  var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return (0, _validateNode.default)({\n    type: \"TupleExpression\",\n    elements: elements\n  });\n}\nfunction decimalLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"DecimalLiteral\",\n    value: value\n  });\n}\nfunction moduleExpression(body) {\n  return (0, _validateNode.default)({\n    type: \"ModuleExpression\",\n    body: body\n  });\n}\nfunction topicReference() {\n  return {\n    type: \"TopicReference\"\n  };\n}\nfunction pipelineTopicExpression(expression) {\n  return (0, _validateNode.default)({\n    type: \"PipelineTopicExpression\",\n    expression: expression\n  });\n}\nfunction pipelineBareFunction(callee) {\n  return (0, _validateNode.default)({\n    type: \"PipelineBareFunction\",\n    callee: callee\n  });\n}\nfunction pipelinePrimaryTopicReference() {\n  return {\n    type: \"PipelinePrimaryTopicReference\"\n  };\n}\nfunction tsParameterProperty(parameter) {\n  return (0, _validateNode.default)({\n    type: \"TSParameterProperty\",\n    parameter: parameter\n  });\n}\nfunction tsDeclareFunction() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var params = arguments.length > 2 ? arguments[2] : undefined;\n  var returnType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"TSDeclareFunction\",\n    id: id,\n    typeParameters: typeParameters,\n    params: params,\n    returnType: returnType\n  });\n}\nfunction tsDeclareMethod() {\n  var decorators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var key = arguments.length > 1 ? arguments[1] : undefined;\n  var typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var params = arguments.length > 3 ? arguments[3] : undefined;\n  var returnType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  return (0, _validateNode.default)({\n    type: \"TSDeclareMethod\",\n    decorators: decorators,\n    key: key,\n    typeParameters: typeParameters,\n    params: params,\n    returnType: returnType\n  });\n}\nfunction tsQualifiedName(left, right) {\n  return (0, _validateNode.default)({\n    type: \"TSQualifiedName\",\n    left: left,\n    right: right\n  });\n}\nfunction tsCallSignatureDeclaration() {\n  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var parameters = arguments.length > 1 ? arguments[1] : undefined;\n  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSCallSignatureDeclaration\",\n    typeParameters: typeParameters,\n    parameters: parameters,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsConstructSignatureDeclaration() {\n  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var parameters = arguments.length > 1 ? arguments[1] : undefined;\n  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSConstructSignatureDeclaration\",\n    typeParameters: typeParameters,\n    parameters: parameters,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsPropertySignature(key) {\n  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var initializer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSPropertySignature\",\n    key: key,\n    typeAnnotation: typeAnnotation,\n    initializer: initializer,\n    kind: null\n  });\n}\nfunction tsMethodSignature(key) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var parameters = arguments.length > 2 ? arguments[2] : undefined;\n  var typeAnnotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"TSMethodSignature\",\n    key: key,\n    typeParameters: typeParameters,\n    parameters: parameters,\n    typeAnnotation: typeAnnotation,\n    kind: null\n  });\n}\nfunction tsIndexSignature(parameters) {\n  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSIndexSignature\",\n    parameters: parameters,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsAnyKeyword() {\n  return {\n    type: \"TSAnyKeyword\"\n  };\n}\nfunction tsBooleanKeyword() {\n  return {\n    type: \"TSBooleanKeyword\"\n  };\n}\nfunction tsBigIntKeyword() {\n  return {\n    type: \"TSBigIntKeyword\"\n  };\n}\nfunction tsIntrinsicKeyword() {\n  return {\n    type: \"TSIntrinsicKeyword\"\n  };\n}\nfunction tsNeverKeyword() {\n  return {\n    type: \"TSNeverKeyword\"\n  };\n}\nfunction tsNullKeyword() {\n  return {\n    type: \"TSNullKeyword\"\n  };\n}\nfunction tsNumberKeyword() {\n  return {\n    type: \"TSNumberKeyword\"\n  };\n}\nfunction tsObjectKeyword() {\n  return {\n    type: \"TSObjectKeyword\"\n  };\n}\nfunction tsStringKeyword() {\n  return {\n    type: \"TSStringKeyword\"\n  };\n}\nfunction tsSymbolKeyword() {\n  return {\n    type: \"TSSymbolKeyword\"\n  };\n}\nfunction tsUndefinedKeyword() {\n  return {\n    type: \"TSUndefinedKeyword\"\n  };\n}\nfunction tsUnknownKeyword() {\n  return {\n    type: \"TSUnknownKeyword\"\n  };\n}\nfunction tsVoidKeyword() {\n  return {\n    type: \"TSVoidKeyword\"\n  };\n}\nfunction tsThisType() {\n  return {\n    type: \"TSThisType\"\n  };\n}\nfunction tsFunctionType() {\n  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var parameters = arguments.length > 1 ? arguments[1] : undefined;\n  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSFunctionType\",\n    typeParameters: typeParameters,\n    parameters: parameters,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsConstructorType() {\n  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var parameters = arguments.length > 1 ? arguments[1] : undefined;\n  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSConstructorType\",\n    typeParameters: typeParameters,\n    parameters: parameters,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsTypeReference(typeName) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSTypeReference\",\n    typeName: typeName,\n    typeParameters: typeParameters\n  });\n}\nfunction tsTypePredicate(parameterName) {\n  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var asserts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSTypePredicate\",\n    parameterName: parameterName,\n    typeAnnotation: typeAnnotation,\n    asserts: asserts\n  });\n}\nfunction tsTypeQuery(exprName) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSTypeQuery\",\n    exprName: exprName,\n    typeParameters: typeParameters\n  });\n}\nfunction tsTypeLiteral(members) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeLiteral\",\n    members: members\n  });\n}\nfunction tsArrayType(elementType) {\n  return (0, _validateNode.default)({\n    type: \"TSArrayType\",\n    elementType: elementType\n  });\n}\nfunction tsTupleType(elementTypes) {\n  return (0, _validateNode.default)({\n    type: \"TSTupleType\",\n    elementTypes: elementTypes\n  });\n}\nfunction tsOptionalType(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSOptionalType\",\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsRestType(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSRestType\",\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsNamedTupleMember(label, elementType) {\n  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _validateNode.default)({\n    type: \"TSNamedTupleMember\",\n    label: label,\n    elementType: elementType,\n    optional: optional\n  });\n}\nfunction tsUnionType(types) {\n  return (0, _validateNode.default)({\n    type: \"TSUnionType\",\n    types: types\n  });\n}\nfunction tsIntersectionType(types) {\n  return (0, _validateNode.default)({\n    type: \"TSIntersectionType\",\n    types: types\n  });\n}\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n  return (0, _validateNode.default)({\n    type: \"TSConditionalType\",\n    checkType: checkType,\n    extendsType: extendsType,\n    trueType: trueType,\n    falseType: falseType\n  });\n}\nfunction tsInferType(typeParameter) {\n  return (0, _validateNode.default)({\n    type: \"TSInferType\",\n    typeParameter: typeParameter\n  });\n}\nfunction tsParenthesizedType(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSParenthesizedType\",\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsTypeOperator(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeOperator\",\n    typeAnnotation: typeAnnotation,\n    operator: null\n  });\n}\nfunction tsIndexedAccessType(objectType, indexType) {\n  return (0, _validateNode.default)({\n    type: \"TSIndexedAccessType\",\n    objectType: objectType,\n    indexType: indexType\n  });\n}\nfunction tsMappedType(typeParameter) {\n  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var nameType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSMappedType\",\n    typeParameter: typeParameter,\n    typeAnnotation: typeAnnotation,\n    nameType: nameType\n  });\n}\nfunction tsLiteralType(literal) {\n  return (0, _validateNode.default)({\n    type: \"TSLiteralType\",\n    literal: literal\n  });\n}\nfunction tsExpressionWithTypeArguments(expression) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSExpressionWithTypeArguments\",\n    expression: expression,\n    typeParameters: typeParameters\n  });\n}\nfunction tsInterfaceDeclaration(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"TSInterfaceDeclaration\",\n    id: id,\n    typeParameters: typeParameters,\n    extends: _extends,\n    body: body\n  });\n}\nfunction tsInterfaceBody(body) {\n  return (0, _validateNode.default)({\n    type: \"TSInterfaceBody\",\n    body: body\n  });\n}\nfunction tsTypeAliasDeclaration(id) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var typeAnnotation = arguments.length > 2 ? arguments[2] : undefined;\n  return (0, _validateNode.default)({\n    type: \"TSTypeAliasDeclaration\",\n    id: id,\n    typeParameters: typeParameters,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsInstantiationExpression(expression) {\n  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSInstantiationExpression\",\n    expression: expression,\n    typeParameters: typeParameters\n  });\n}\nfunction tsAsExpression(expression, typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSAsExpression\",\n    expression: expression,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsSatisfiesExpression(expression, typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSSatisfiesExpression\",\n    expression: expression,\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsTypeAssertion(typeAnnotation, expression) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeAssertion\",\n    typeAnnotation: typeAnnotation,\n    expression: expression\n  });\n}\nfunction tsEnumDeclaration(id, members) {\n  return (0, _validateNode.default)({\n    type: \"TSEnumDeclaration\",\n    id: id,\n    members: members\n  });\n}\nfunction tsEnumMember(id) {\n  var initializer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSEnumMember\",\n    id: id,\n    initializer: initializer\n  });\n}\nfunction tsModuleDeclaration(id, body) {\n  return (0, _validateNode.default)({\n    type: \"TSModuleDeclaration\",\n    id: id,\n    body: body\n  });\n}\nfunction tsModuleBlock(body) {\n  return (0, _validateNode.default)({\n    type: \"TSModuleBlock\",\n    body: body\n  });\n}\nfunction tsImportType(argument) {\n  var qualifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSImportType\",\n    argument: argument,\n    qualifier: qualifier,\n    typeParameters: typeParameters\n  });\n}\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n  return (0, _validateNode.default)({\n    type: \"TSImportEqualsDeclaration\",\n    id: id,\n    moduleReference: moduleReference,\n    isExport: null\n  });\n}\nfunction tsExternalModuleReference(expression) {\n  return (0, _validateNode.default)({\n    type: \"TSExternalModuleReference\",\n    expression: expression\n  });\n}\nfunction tsNonNullExpression(expression) {\n  return (0, _validateNode.default)({\n    type: \"TSNonNullExpression\",\n    expression: expression\n  });\n}\nfunction tsExportAssignment(expression) {\n  return (0, _validateNode.default)({\n    type: \"TSExportAssignment\",\n    expression: expression\n  });\n}\nfunction tsNamespaceExportDeclaration(id) {\n  return (0, _validateNode.default)({\n    type: \"TSNamespaceExportDeclaration\",\n    id: id\n  });\n}\nfunction tsTypeAnnotation(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeAnnotation\",\n    typeAnnotation: typeAnnotation\n  });\n}\nfunction tsTypeParameterInstantiation(params) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeParameterInstantiation\",\n    params: params\n  });\n}\nfunction tsTypeParameterDeclaration(params) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeParameterDeclaration\",\n    params: params\n  });\n}\nfunction tsTypeParameter() {\n  var constraint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var name = arguments.length > 2 ? arguments[2] : undefined;\n  return (0, _validateNode.default)({\n    type: \"TSTypeParameter\",\n    constraint: constraint,\n    default: _default,\n    name: name\n  });\n}\nfunction NumberLiteral(value) {\n  (0, _deprecationWarning.default)(\"NumberLiteral\", \"NumericLiteral\", \"The node type \");\n  return numericLiteral(value);\n}\nfunction RegexLiteral(pattern) {\n  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  (0, _deprecationWarning.default)(\"RegexLiteral\", \"RegExpLiteral\", \"The node type \");\n  return regExpLiteral(pattern, flags);\n}\nfunction RestProperty(argument) {\n  (0, _deprecationWarning.default)(\"RestProperty\", \"RestElement\", \"The node type \");\n  return restElement(argument);\n}\nfunction SpreadProperty(argument) {\n  (0, _deprecationWarning.default)(\"SpreadProperty\", \"SpreadElement\", \"The node type \");\n  return spreadElement(argument);\n}","map":null,"metadata":{},"sourceType":"script"}