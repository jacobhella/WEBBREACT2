{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _renamer = require(\"./lib/renamer\");\nvar _index = require(\"../index\");\nvar _binding = require(\"./binding\");\nvar _globals = require(\"globals\");\nvar _t = require(\"@babel/types\");\nvar _cache = require(\"../cache\");\nvar NOT_LOCAL_BINDING = _t.NOT_LOCAL_BINDING,\n  callExpression = _t.callExpression,\n  cloneNode = _t.cloneNode,\n  getBindingIdentifiers = _t.getBindingIdentifiers,\n  identifier = _t.identifier,\n  isArrayExpression = _t.isArrayExpression,\n  isBinary = _t.isBinary,\n  isClass = _t.isClass,\n  isClassBody = _t.isClassBody,\n  isClassDeclaration = _t.isClassDeclaration,\n  isExportAllDeclaration = _t.isExportAllDeclaration,\n  isExportDefaultDeclaration = _t.isExportDefaultDeclaration,\n  isExportNamedDeclaration = _t.isExportNamedDeclaration,\n  isFunctionDeclaration = _t.isFunctionDeclaration,\n  isIdentifier = _t.isIdentifier,\n  isImportDeclaration = _t.isImportDeclaration,\n  isLiteral = _t.isLiteral,\n  isMethod = _t.isMethod,\n  isModuleSpecifier = _t.isModuleSpecifier,\n  isNullLiteral = _t.isNullLiteral,\n  isObjectExpression = _t.isObjectExpression,\n  isProperty = _t.isProperty,\n  isPureish = _t.isPureish,\n  isRegExpLiteral = _t.isRegExpLiteral,\n  isSuper = _t.isSuper,\n  isTaggedTemplateExpression = _t.isTaggedTemplateExpression,\n  isTemplateLiteral = _t.isTemplateLiteral,\n  isThisExpression = _t.isThisExpression,\n  isUnaryExpression = _t.isUnaryExpression,\n  isVariableDeclaration = _t.isVariableDeclaration,\n  matchesPattern = _t.matchesPattern,\n  memberExpression = _t.memberExpression,\n  numericLiteral = _t.numericLiteral,\n  toIdentifier = _t.toIdentifier,\n  unaryExpression = _t.unaryExpression,\n  variableDeclaration = _t.variableDeclaration,\n  variableDeclarator = _t.variableDeclarator,\n  isRecordExpression = _t.isRecordExpression,\n  isTupleExpression = _t.isTupleExpression,\n  isObjectProperty = _t.isObjectProperty,\n  isTopicReference = _t.isTopicReference,\n  isMetaProperty = _t.isMetaProperty,\n  isPrivateName = _t.isPrivateName,\n  isExportDeclaration = _t.isExportDeclaration;\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isImportDeclaration(node) || isExportDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          var _iterator = _createForOfIteratorHelper(node.specifiers),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var e = _step.value;\n              gatherNodeParts(e, parts);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {\n        parts.push(node.value);\n      }\n      break;\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      var _iterator2 = _createForOfIteratorHelper(node.properties),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _e = _step2.value;\n          gatherNodeParts(_e, parts);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      break;\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\nvar collectorVisitor = {\n  ForStatement: function ForStatement(path) {\n    var declar = path.get(\"init\");\n    if (declar.isVar()) {\n      var scope = path.scope;\n      var parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n  Declaration: function Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n  ImportDeclaration: function ImportDeclaration(path) {\n    var parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n  ForXStatement: function ForXStatement(path, state) {\n    var left = path.get(\"left\");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      var scope = path.scope;\n      var parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n  ExportDeclaration: {\n    exit: function exit(path) {\n      var node = path.node,\n        scope = path.scope;\n      if (isExportAllDeclaration(node)) return;\n      var declar = node.declaration;\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        var id = declar.id;\n        if (!id) return;\n        var binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        var _iterator3 = _createForOfIteratorHelper(declar.declarations),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var decl = _step3.value;\n            for (var _i = 0, _Object$keys = Object.keys(getBindingIdentifiers(decl)); _i < _Object$keys.length; _i++) {\n              var name = _Object$keys[_i];\n              var _binding2 = scope.getBinding(name);\n              _binding2 == null ? void 0 : _binding2.reference(path);\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  },\n  LabeledStatement: function LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n  AssignmentExpression: function AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n  UpdateExpression: function UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n  UnaryExpression: function UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n  BlockScoped: function BlockScoped(path) {\n    var scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    var parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n    if (path.isClassDeclaration() && path.node.id) {\n      var id = path.node.id;\n      var name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n  CatchClause: function CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n  Function: function Function(path) {\n    var params = path.get(\"params\");\n    var _iterator4 = _createForOfIteratorHelper(params),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var param = _step4.value;\n        path.scope.registerBinding(\"param\", param);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n  ClassExpression: function ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n};\nvar uid = 0;\nvar Scope = /*#__PURE__*/function () {\n  function Scope(path) {\n    _classCallCheck(this, Scope);\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    var node = path.node;\n    var cached = _cache.scope.get(node);\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n    _cache.scope.set(node, this);\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n  _createClass(Scope, [{\n    key: \"traverse\",\n    value: function traverse(node, opts, state) {\n      (0, _index.default)(node, opts, this, state, this.path);\n    }\n  }, {\n    key: \"generateDeclaredUidIdentifier\",\n    value: function generateDeclaredUidIdentifier(name) {\n      var id = this.generateUidIdentifier(name);\n      this.push({\n        id: id\n      });\n      return cloneNode(id);\n    }\n  }, {\n    key: \"generateUidIdentifier\",\n    value: function generateUidIdentifier(name) {\n      return identifier(this.generateUid(name));\n    }\n  }, {\n    key: \"generateUid\",\n    value: function generateUid() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"temp\";\n      name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n      var uid;\n      var i = 1;\n      do {\n        uid = this._generateUid(name, i);\n        i++;\n      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n      var program = this.getProgramParent();\n      program.references[uid] = true;\n      program.uids[uid] = true;\n      return uid;\n    }\n  }, {\n    key: \"_generateUid\",\n    value: function _generateUid(name, i) {\n      var id = name;\n      if (i > 1) id += i;\n      return \"_\".concat(id);\n    }\n  }, {\n    key: \"generateUidBasedOnNode\",\n    value: function generateUidBasedOnNode(node, defaultName) {\n      var parts = [];\n      gatherNodeParts(node, parts);\n      var id = parts.join(\"$\");\n      id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n      return this.generateUid(id.slice(0, 20));\n    }\n  }, {\n    key: \"generateUidIdentifierBasedOnNode\",\n    value: function generateUidIdentifierBasedOnNode(node, defaultName) {\n      return identifier(this.generateUidBasedOnNode(node, defaultName));\n    }\n  }, {\n    key: \"isStatic\",\n    value: function isStatic(node) {\n      if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n        return true;\n      }\n      if (isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n        if (binding) {\n          return binding.constant;\n        } else {\n          return this.hasBinding(node.name);\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"maybeGenerateMemoised\",\n    value: function maybeGenerateMemoised(node, dontPush) {\n      if (this.isStatic(node)) {\n        return null;\n      } else {\n        var id = this.generateUidIdentifierBasedOnNode(node);\n        if (!dontPush) {\n          this.push({\n            id: id\n          });\n          return cloneNode(id);\n        }\n        return id;\n      }\n    }\n  }, {\n    key: \"checkBlockScopedCollisions\",\n    value: function checkBlockScopedCollisions(local, kind, name, id) {\n      if (kind === \"param\") return;\n      if (local.kind === \"local\") return;\n      var duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && kind === \"const\";\n      if (duplicate) {\n        throw this.hub.buildError(id, \"Duplicate declaration \\\"\".concat(name, \"\\\"\"), TypeError);\n      }\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(oldName, newName) {\n      var binding = this.getBinding(oldName);\n      if (binding) {\n        newName || (newName = this.generateUidIdentifier(oldName).name);\n        var renamer = new _renamer.default(binding, oldName, newName);\n        return renamer.rename(arguments[2]);\n      }\n    }\n  }, {\n    key: \"_renameFromMap\",\n    value: function _renameFromMap(map, oldName, newName, value) {\n      if (map[oldName]) {\n        map[newName] = value;\n        map[oldName] = null;\n      }\n    }\n  }, {\n    key: \"dump\",\n    value: function dump() {\n      var sep = \"-\".repeat(60);\n      console.log(sep);\n      var scope = this;\n      do {\n        console.log(\"#\", scope.block.type);\n        for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {\n          var name = _Object$keys2[_i2];\n          var binding = scope.bindings[name];\n          console.log(\" -\", name, {\n            constant: binding.constant,\n            references: binding.references,\n            violations: binding.constantViolations.length,\n            kind: binding.kind\n          });\n        }\n      } while (scope = scope.parent);\n      console.log(sep);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(node, i, arrayLikeIsIterable) {\n      if (isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n        if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n          return node;\n        }\n      }\n      if (isArrayExpression(node)) {\n        return node;\n      }\n      if (isIdentifier(node, {\n        name: \"arguments\"\n      })) {\n        return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n      }\n      var helperName;\n      var args = [node];\n      if (i === true) {\n        helperName = \"toConsumableArray\";\n      } else if (typeof i === \"number\") {\n        args.push(numericLiteral(i));\n        helperName = \"slicedToArray\";\n      } else {\n        helperName = \"toArray\";\n      }\n      if (arrayLikeIsIterable) {\n        args.unshift(this.hub.addHelper(helperName));\n        helperName = \"maybeArrayLike\";\n      }\n      return callExpression(this.hub.addHelper(helperName), args);\n    }\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(name) {\n      return !!this.getLabel(name);\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel(name) {\n      return this.labels.get(name);\n    }\n  }, {\n    key: \"registerLabel\",\n    value: function registerLabel(path) {\n      this.labels.set(path.node.label.name, path);\n    }\n  }, {\n    key: \"registerDeclaration\",\n    value: function registerDeclaration(path) {\n      if (path.isLabeledStatement()) {\n        this.registerLabel(path);\n      } else if (path.isFunctionDeclaration()) {\n        this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n      } else if (path.isVariableDeclaration()) {\n        var declarations = path.get(\"declarations\");\n        var kind = path.node.kind;\n        var _iterator5 = _createForOfIteratorHelper(declarations),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var declar = _step5.value;\n            this.registerBinding(kind === \"using\" ? \"const\" : kind, declar);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else if (path.isClassDeclaration()) {\n        if (path.node.declare) return;\n        this.registerBinding(\"let\", path);\n      } else if (path.isImportDeclaration()) {\n        var isTypeDeclaration = path.node.importKind === \"type\" || path.node.importKind === \"typeof\";\n        var specifiers = path.get(\"specifiers\");\n        var _iterator6 = _createForOfIteratorHelper(specifiers),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var specifier = _step6.value;\n            var isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === \"type\" || specifier.node.importKind === \"typeof\");\n            this.registerBinding(isTypeSpecifier ? \"unknown\" : \"module\", specifier);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } else if (path.isExportDeclaration()) {\n        var _declar = path.get(\"declaration\");\n        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {\n          this.registerDeclaration(_declar);\n        }\n      } else {\n        this.registerBinding(\"unknown\", path);\n      }\n    }\n  }, {\n    key: \"buildUndefinedNode\",\n    value: function buildUndefinedNode() {\n      return unaryExpression(\"void\", numericLiteral(0), true);\n    }\n  }, {\n    key: \"registerConstantViolation\",\n    value: function registerConstantViolation(path) {\n      var ids = path.getBindingIdentifiers();\n      for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {\n        var name = _Object$keys3[_i3];\n        var binding = this.getBinding(name);\n        if (binding) binding.reassign(path);\n      }\n    }\n  }, {\n    key: \"registerBinding\",\n    value: function registerBinding(kind, path) {\n      var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;\n      if (!kind) throw new ReferenceError(\"no `kind`\");\n      if (path.isVariableDeclaration()) {\n        var declarators = path.get(\"declarations\");\n        var _iterator7 = _createForOfIteratorHelper(declarators),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var declar = _step7.value;\n            this.registerBinding(kind, declar);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        return;\n      }\n      var parent = this.getProgramParent();\n      var ids = path.getOuterBindingIdentifiers(true);\n      for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {\n        var name = _Object$keys4[_i4];\n        parent.references[name] = true;\n        var _iterator8 = _createForOfIteratorHelper(ids[name]),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var id = _step8.value;\n            var local = this.getOwnBinding(name);\n            if (local) {\n              if (local.identifier === id) continue;\n              this.checkBlockScopedCollisions(local, kind, name, id);\n            }\n            if (local) {\n              this.registerConstantViolation(bindingPath);\n            } else {\n              this.bindings[name] = new _binding.default({\n                identifier: id,\n                scope: this,\n                path: bindingPath,\n                kind: kind\n              });\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n    }\n  }, {\n    key: \"addGlobal\",\n    value: function addGlobal(node) {\n      this.globals[node.name] = node;\n    }\n  }, {\n    key: \"hasUid\",\n    value: function hasUid(name) {\n      var scope = this;\n      do {\n        if (scope.uids[name]) return true;\n      } while (scope = scope.parent);\n      return false;\n    }\n  }, {\n    key: \"hasGlobal\",\n    value: function hasGlobal(name) {\n      var scope = this;\n      do {\n        if (scope.globals[name]) return true;\n      } while (scope = scope.parent);\n      return false;\n    }\n  }, {\n    key: \"hasReference\",\n    value: function hasReference(name) {\n      return !!this.getProgramParent().references[name];\n    }\n  }, {\n    key: \"isPure\",\n    value: function isPure(node, constantsOnly) {\n      if (isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n        if (!binding) return false;\n        if (constantsOnly) return binding.constant;\n        return true;\n      } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {\n        return true;\n      } else if (isClass(node)) {\n        var _node$decorators;\n        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n          return false;\n        }\n        if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {\n          return false;\n        }\n        return this.isPure(node.body, constantsOnly);\n      } else if (isClassBody(node)) {\n        var _iterator9 = _createForOfIteratorHelper(node.body),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var method = _step9.value;\n            if (!this.isPure(method, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n        return true;\n      } else if (isBinary(node)) {\n        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n      } else if (isArrayExpression(node) || isTupleExpression(node)) {\n        var _iterator10 = _createForOfIteratorHelper(node.elements),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var elem = _step10.value;\n            if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n        return true;\n      } else if (isObjectExpression(node) || isRecordExpression(node)) {\n        var _iterator11 = _createForOfIteratorHelper(node.properties),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var prop = _step11.value;\n            if (!this.isPure(prop, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n        return true;\n      } else if (isMethod(node)) {\n        var _node$decorators2;\n        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n        if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {\n          return false;\n        }\n        return true;\n      } else if (isProperty(node)) {\n        var _node$decorators3;\n        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n        if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {\n          return false;\n        }\n        if (isObjectProperty(node) || node.static) {\n          if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n            return false;\n          }\n        }\n        return true;\n      } else if (isUnaryExpression(node)) {\n        return this.isPure(node.argument, constantsOnly);\n      } else if (isTaggedTemplateExpression(node)) {\n        return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n      } else if (isTemplateLiteral(node)) {\n        var _iterator12 = _createForOfIteratorHelper(node.expressions),\n          _step12;\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var expression = _step12.value;\n            if (!this.isPure(expression, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n        return true;\n      } else {\n        return isPureish(node);\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(key, val) {\n      return this.data[key] = val;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(key) {\n      var scope = this;\n      do {\n        var data = scope.data[key];\n        if (data != null) return data;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"removeData\",\n    value: function removeData(key) {\n      var scope = this;\n      do {\n        var data = scope.data[key];\n        if (data != null) scope.data[key] = null;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      if (!this.inited) {\n        this.inited = true;\n        this.crawl();\n      }\n    }\n  }, {\n    key: \"crawl\",\n    value: function crawl() {\n      var path = this.path;\n      this.references = Object.create(null);\n      this.bindings = Object.create(null);\n      this.globals = Object.create(null);\n      this.uids = Object.create(null);\n      this.data = Object.create(null);\n      var programParent = this.getProgramParent();\n      if (programParent.crawling) return;\n      var state = {\n        references: [],\n        constantViolations: [],\n        assignments: []\n      };\n      this.crawling = true;\n      if (path.type !== \"Program\" && collectorVisitor._exploded) {\n        var _iterator13 = _createForOfIteratorHelper(collectorVisitor.enter),\n          _step13;\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var _visit = _step13.value;\n            _visit(path, state);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n        var typeVisitors = collectorVisitor[path.type];\n        if (typeVisitors) {\n          var _iterator14 = _createForOfIteratorHelper(typeVisitors.enter),\n            _step14;\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var visit = _step14.value;\n              visit(path, state);\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        }\n      }\n      path.traverse(collectorVisitor, state);\n      this.crawling = false;\n      var _iterator15 = _createForOfIteratorHelper(state.assignments),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _path = _step15.value;\n          var ids = _path.getBindingIdentifiers();\n          for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {\n            var name = _Object$keys5[_i5];\n            if (_path.scope.getBinding(name)) continue;\n            programParent.addGlobal(ids[name]);\n          }\n          _path.scope.registerConstantViolation(_path);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n      var _iterator16 = _createForOfIteratorHelper(state.references),\n        _step16;\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var ref = _step16.value;\n          var binding = ref.scope.getBinding(ref.node.name);\n          if (binding) {\n            binding.reference(ref);\n          } else {\n            programParent.addGlobal(ref.node);\n          }\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n      var _iterator17 = _createForOfIteratorHelper(state.constantViolations),\n        _step17;\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var _path2 = _step17.value;\n          _path2.scope.registerConstantViolation(_path2);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(opts) {\n      var path = this.path;\n      if (path.isPattern()) {\n        path = this.getPatternParent().path;\n      } else if (!path.isBlockStatement() && !path.isProgram()) {\n        path = this.getBlockParent().path;\n      }\n      if (path.isSwitchStatement()) {\n        path = (this.getFunctionParent() || this.getProgramParent()).path;\n      }\n      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n        path.ensureBlock();\n        path = path.get(\"body\");\n      }\n      var unique = opts.unique;\n      var kind = opts.kind || \"var\";\n      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n      var dataKey = \"declaration:\".concat(kind, \":\").concat(blockHoist);\n      var declarPath = !unique && path.getData(dataKey);\n      if (!declarPath) {\n        var declar = variableDeclaration(kind, []);\n        declar._blockHoist = blockHoist;\n        var _path$unshiftContaine = path.unshiftContainer(\"body\", [declar]);\n        var _path$unshiftContaine2 = _slicedToArray(_path$unshiftContaine, 1);\n        declarPath = _path$unshiftContaine2[0];\n        if (!unique) path.setData(dataKey, declarPath);\n      }\n      var declarator = variableDeclarator(opts.id, opts.init);\n      var len = declarPath.node.declarations.push(declarator);\n      path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n    }\n  }, {\n    key: \"getProgramParent\",\n    value: function getProgramParent() {\n      var scope = this;\n      do {\n        if (scope.path.isProgram()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n      throw new Error(\"Couldn't find a Program\");\n    }\n  }, {\n    key: \"getFunctionParent\",\n    value: function getFunctionParent() {\n      var scope = this;\n      do {\n        if (scope.path.isFunctionParent()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n      return null;\n    }\n  }, {\n    key: \"getBlockParent\",\n    value: function getBlockParent() {\n      var scope = this;\n      do {\n        if (scope.path.isBlockParent()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n      throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n    }\n  }, {\n    key: \"getPatternParent\",\n    value: function getPatternParent() {\n      var scope = this;\n      do {\n        if (!scope.path.isPattern()) {\n          return scope.getBlockParent();\n        }\n      } while (scope = scope.parent.parent);\n      throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n    }\n  }, {\n    key: \"getAllBindings\",\n    value: function getAllBindings() {\n      var ids = Object.create(null);\n      var scope = this;\n      do {\n        for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {\n          var key = _Object$keys6[_i6];\n          if (key in ids === false) {\n            ids[key] = scope.bindings[key];\n          }\n        }\n        scope = scope.parent;\n      } while (scope);\n      return ids;\n    }\n  }, {\n    key: \"getAllBindingsOfKind\",\n    value: function getAllBindingsOfKind() {\n      var ids = Object.create(null);\n      for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {\n        kinds[_key] = arguments[_key];\n      }\n      for (var _i7 = 0, _kinds = kinds; _i7 < _kinds.length; _i7++) {\n        var kind = _kinds[_i7];\n        var scope = this;\n        do {\n          for (var _i8 = 0, _Object$keys7 = Object.keys(scope.bindings); _i8 < _Object$keys7.length; _i8++) {\n            var name = _Object$keys7[_i8];\n            var binding = scope.bindings[name];\n            if (binding.kind === kind) ids[name] = binding;\n          }\n          scope = scope.parent;\n        } while (scope);\n      }\n      return ids;\n    }\n  }, {\n    key: \"bindingIdentifierEquals\",\n    value: function bindingIdentifierEquals(name, node) {\n      return this.getBindingIdentifier(name) === node;\n    }\n  }, {\n    key: \"getBinding\",\n    value: function getBinding(name) {\n      var scope = this;\n      var previousPath;\n      do {\n        var binding = scope.getOwnBinding(name);\n        if (binding) {\n          var _previousPath;\n          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n            return binding;\n          }\n        } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n        previousPath = scope.path;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"getOwnBinding\",\n    value: function getOwnBinding(name) {\n      return this.bindings[name];\n    }\n  }, {\n    key: \"getBindingIdentifier\",\n    value: function getBindingIdentifier(name) {\n      var _this$getBinding;\n      return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n    }\n  }, {\n    key: \"getOwnBindingIdentifier\",\n    value: function getOwnBindingIdentifier(name) {\n      var binding = this.bindings[name];\n      return binding == null ? void 0 : binding.identifier;\n    }\n  }, {\n    key: \"hasOwnBinding\",\n    value: function hasOwnBinding(name) {\n      return !!this.getOwnBinding(name);\n    }\n  }, {\n    key: \"hasBinding\",\n    value: function hasBinding(name, opts) {\n      var _opts, _opts2, _opts3;\n      if (!name) return false;\n      if (this.hasOwnBinding(name)) return true;\n      {\n        if (typeof opts === \"boolean\") opts = {\n          noGlobals: opts\n        };\n      }\n      if (this.parentHasBinding(name, opts)) return true;\n      if (!((_opts = opts) != null && _opts.noUids) && this.hasUid(name)) return true;\n      if (!((_opts2 = opts) != null && _opts2.noGlobals) && Scope.globals.includes(name)) return true;\n      if (!((_opts3 = opts) != null && _opts3.noGlobals) && Scope.contextVariables.includes(name)) return true;\n      return false;\n    }\n  }, {\n    key: \"parentHasBinding\",\n    value: function parentHasBinding(name, opts) {\n      var _this$parent;\n      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);\n    }\n  }, {\n    key: \"moveBindingTo\",\n    value: function moveBindingTo(name, scope) {\n      var info = this.getBinding(name);\n      if (info) {\n        info.scope.removeOwnBinding(name);\n        info.scope = scope;\n        scope.bindings[name] = info;\n      }\n    }\n  }, {\n    key: \"removeOwnBinding\",\n    value: function removeOwnBinding(name) {\n      delete this.bindings[name];\n    }\n  }, {\n    key: \"removeBinding\",\n    value: function removeBinding(name) {\n      var _this$getBinding2;\n      (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n      var scope = this;\n      do {\n        if (scope.uids[name]) {\n          scope.uids[name] = false;\n        }\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      var _parent;\n      var parent,\n        path = this.path;\n      do {\n        var shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n        path = path.parentPath;\n        if (shouldSkip && path.isMethod()) path = path.parentPath;\n        if (path && path.isScope()) parent = path;\n      } while (path && !parent);\n      return (_parent = parent) == null ? void 0 : _parent.scope;\n    }\n  }, {\n    key: \"parentBlock\",\n    get: function get() {\n      return this.path.parent;\n    }\n  }, {\n    key: \"hub\",\n    get: function get() {\n      return this.path.hub;\n    }\n  }]);\n  return Scope;\n}();\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":null,"metadata":{},"sourceType":"script"}