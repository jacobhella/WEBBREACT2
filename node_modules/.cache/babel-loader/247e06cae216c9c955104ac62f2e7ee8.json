{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\nvar _t = require(\"@babel/types\");\nvar _parser = require(\"@babel/parser\");\nvar _codeFrame = require(\"@babel/code-frame\");\nvar isCallExpression = _t.isCallExpression,\n  isExpressionStatement = _t.isExpressionStatement,\n  isFunction = _t.isFunction,\n  isIdentifier = _t.isIdentifier,\n  isJSXIdentifier = _t.isJSXIdentifier,\n  isNewExpression = _t.isNewExpression,\n  isPlaceholder = _t.isPlaceholder,\n  isStatement = _t.isStatement,\n  isStringLiteral = _t.isStringLiteral,\n  removePropertiesDeep = _t.removePropertiesDeep,\n  traverse = _t.traverse;\nvar PATTERN = /^[_$A-Z0-9]+$/;\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  var placeholderWhitelist = opts.placeholderWhitelist,\n    placeholderPattern = opts.placeholderPattern,\n    preserveComments = opts.preserveComments,\n    syntacticPlaceholders = opts.syntacticPlaceholders;\n  var ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments: preserveComments\n  });\n  formatter.validate(ast);\n  var syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  var legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  var isLegacyRef = {\n    value: undefined\n  };\n  traverse(ast, placeholderVisitorHandler, {\n    syntactic: syntactic,\n    legacy: legacy,\n    isLegacyRef: isLegacyRef,\n    placeholderWhitelist: placeholderWhitelist,\n    placeholderPattern: placeholderPattern,\n    syntacticPlaceholders: syntacticPlaceholders\n  });\n  return Object.assign({\n    ast: ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n  var name;\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n  ancestors = ancestors.slice();\n  var _ancestors = ancestors[ancestors.length - 1],\n    parent = _ancestors.node,\n    key = _ancestors.key;\n  var type;\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (isNewExpression(parent) && key === \"arguments\" || isCallExpression(parent) && key === \"arguments\" || isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n  var _ref = state.isLegacyRef.value ? state.legacy : state.syntactic,\n    placeholders = _ref.placeholders,\n    placeholderNames = _ref.placeholderNames;\n  placeholders.push({\n    name: name,\n    type: type,\n    resolve: function resolve(ast) {\n      return resolveAncestors(ast, ancestors);\n    },\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\nfunction resolveAncestors(ast, ancestors) {\n  var parent = ast;\n  for (var i = 0; i < ancestors.length - 1; i++) {\n    var _ancestors$i = ancestors[i],\n      _key = _ancestors$i.key,\n      _index = _ancestors$i.index;\n    if (_index === undefined) {\n      parent = parent[_key];\n    } else {\n      parent = parent[_key][_index];\n    }\n  }\n  var _ancestors2 = ancestors[ancestors.length - 1],\n    key = _ancestors2.key,\n    index = _ancestors2.index;\n  return {\n    parent: parent,\n    key: key,\n    index: index\n  };\n}\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  var plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins: plugins\n  });\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    var loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}