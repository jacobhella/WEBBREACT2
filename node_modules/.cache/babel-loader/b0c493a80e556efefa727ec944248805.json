{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar Buffer = /*#__PURE__*/function () {\n  function Buffer(map) {\n    _classCallCheck(this, Buffer);\n    this._map = null;\n    this._buf = \"\";\n    this._str = \"\";\n    this._appendCount = 0;\n    this._last = 0;\n    this._queue = [];\n    this._queueCursor = 0;\n    this._canMarkIdName = true;\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = {\n      identifierName: undefined,\n      identifierNamePos: undefined,\n      line: undefined,\n      column: undefined,\n      filename: undefined\n    };\n    this._map = map;\n    this._allocQueue();\n  }\n  _createClass(Buffer, [{\n    key: \"_allocQueue\",\n    value: function _allocQueue() {\n      var queue = this._queue;\n      for (var i = 0; i < 16; i++) {\n        queue.push({\n          char: 0,\n          repeat: 1,\n          line: undefined,\n          column: undefined,\n          identifierName: undefined,\n          identifierNamePos: undefined,\n          filename: \"\"\n        });\n      }\n    }\n  }, {\n    key: \"_pushQueue\",\n    value: function _pushQueue(char, repeat, line, column, filename) {\n      var cursor = this._queueCursor;\n      if (cursor === this._queue.length) {\n        this._allocQueue();\n      }\n      var item = this._queue[cursor];\n      item.char = char;\n      item.repeat = repeat;\n      item.line = line;\n      item.column = column;\n      item.filename = filename;\n      this._queueCursor++;\n    }\n  }, {\n    key: \"_popQueue\",\n    value: function _popQueue() {\n      if (this._queueCursor === 0) {\n        throw new Error(\"Cannot pop from empty queue\");\n      }\n      return this._queue[--this._queueCursor];\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      this._flush();\n      var map = this._map;\n      var result = {\n        code: (this._buf + this._str).trimRight(),\n        decodedMap: map == null ? void 0 : map.getDecoded(),\n        get __mergedMap() {\n          return this.map;\n        },\n        get map() {\n          var resultMap = map ? map.get() : null;\n          result.map = resultMap;\n          return resultMap;\n        },\n        set map(value) {\n          Object.defineProperty(result, \"map\", {\n            value: value,\n            writable: true\n          });\n        },\n        get rawMappings() {\n          var mappings = map == null ? void 0 : map.getRawMappings();\n          result.rawMappings = mappings;\n          return mappings;\n        },\n        set rawMappings(value) {\n          Object.defineProperty(result, \"rawMappings\", {\n            value: value,\n            writable: true\n          });\n        }\n      };\n      return result;\n    }\n  }, {\n    key: \"append\",\n    value: function append(str, maybeNewline) {\n      this._flush();\n      this._append(str, this._sourcePosition, maybeNewline);\n    }\n  }, {\n    key: \"appendChar\",\n    value: function appendChar(char) {\n      this._flush();\n      this._appendChar(char, 1, this._sourcePosition);\n    }\n  }, {\n    key: \"queue\",\n    value: function queue(char) {\n      if (char === 10) {\n        while (this._queueCursor !== 0) {\n          var _char = this._queue[this._queueCursor - 1].char;\n          if (_char !== 32 && _char !== 9) {\n            break;\n          }\n          this._queueCursor--;\n        }\n      }\n      var sourcePosition = this._sourcePosition;\n      this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);\n    }\n  }, {\n    key: \"queueIndentation\",\n    value: function queueIndentation(char, repeat) {\n      this._pushQueue(char, repeat, undefined, undefined, undefined);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush() {\n      var queueCursor = this._queueCursor;\n      var queue = this._queue;\n      for (var i = 0; i < queueCursor; i++) {\n        var item = queue[i];\n        this._appendChar(item.char, item.repeat, item);\n      }\n      this._queueCursor = 0;\n    }\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(char, repeat, sourcePos) {\n      this._last = char;\n      this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n      if (char !== 10) {\n        this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);\n        this._position.column += repeat;\n      } else {\n        this._position.line++;\n        this._position.column = 0;\n      }\n      if (this._canMarkIdName) {\n        sourcePos.identifierName = undefined;\n        sourcePos.identifierNamePos = undefined;\n      }\n    }\n  }, {\n    key: \"_append\",\n    value: function _append(str, sourcePos, maybeNewline) {\n      var len = str.length;\n      var position = this._position;\n      this._last = str.charCodeAt(len - 1);\n      if (++this._appendCount > 4096) {\n        +this._str;\n        this._buf += this._str;\n        this._str = str;\n        this._appendCount = 0;\n      } else {\n        this._str += str;\n      }\n      if (!maybeNewline && !this._map) {\n        position.column += len;\n        return;\n      }\n      var column = sourcePos.column,\n        identifierName = sourcePos.identifierName,\n        identifierNamePos = sourcePos.identifierNamePos,\n        filename = sourcePos.filename;\n      var line = sourcePos.line;\n      if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {\n        sourcePos.identifierName = undefined;\n        sourcePos.identifierNamePos = undefined;\n      }\n      var i = str.indexOf(\"\\n\");\n      var last = 0;\n      if (i !== 0) {\n        this._mark(line, column, identifierName, identifierNamePos, filename);\n      }\n      while (i !== -1) {\n        position.line++;\n        position.column = 0;\n        last = i + 1;\n        if (last < len && line !== undefined) {\n          this._mark(++line, 0, null, null, filename);\n        }\n        i = str.indexOf(\"\\n\", last);\n      }\n      position.column += len - last;\n    }\n  }, {\n    key: \"_mark\",\n    value: function _mark(line, column, identifierName, identifierNamePos, filename) {\n      var _this$_map;\n      (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);\n    }\n  }, {\n    key: \"removeTrailingNewline\",\n    value: function removeTrailingNewline() {\n      var queueCursor = this._queueCursor;\n      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {\n        this._queueCursor--;\n      }\n    }\n  }, {\n    key: \"removeLastSemicolon\",\n    value: function removeLastSemicolon() {\n      var queueCursor = this._queueCursor;\n      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {\n        this._queueCursor--;\n      }\n    }\n  }, {\n    key: \"getLastChar\",\n    value: function getLastChar() {\n      var queueCursor = this._queueCursor;\n      return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n    }\n  }, {\n    key: \"getNewlineCount\",\n    value: function getNewlineCount() {\n      var queueCursor = this._queueCursor;\n      var count = 0;\n      if (queueCursor === 0) return this._last === 10 ? 1 : 0;\n      for (var i = queueCursor - 1; i >= 0; i--) {\n        if (this._queue[i].char !== 10) {\n          break;\n        }\n        count++;\n      }\n      return count === queueCursor && this._last === 10 ? count + 1 : count;\n    }\n  }, {\n    key: \"endsWithCharAndNewline\",\n    value: function endsWithCharAndNewline() {\n      var queue = this._queue;\n      var queueCursor = this._queueCursor;\n      if (queueCursor !== 0) {\n        var lastCp = queue[queueCursor - 1].char;\n        if (lastCp !== 10) return;\n        if (queueCursor > 1) {\n          return queue[queueCursor - 2].char;\n        } else {\n          return this._last;\n        }\n      }\n    }\n  }, {\n    key: \"hasContent\",\n    value: function hasContent() {\n      return this._queueCursor !== 0 || !!this._last;\n    }\n  }, {\n    key: \"exactSource\",\n    value: function exactSource(loc, cb) {\n      if (!this._map) return cb();\n      this.source(\"start\", loc);\n      var identifierName = loc.identifierName;\n      var sourcePos = this._sourcePosition;\n      if (identifierName) {\n        this._canMarkIdName = false;\n        sourcePos.identifierName = identifierName;\n      }\n      cb();\n      if (identifierName) {\n        this._canMarkIdName = true;\n        sourcePos.identifierName = undefined;\n        sourcePos.identifierNamePos = undefined;\n      }\n      this.source(\"end\", loc);\n    }\n  }, {\n    key: \"source\",\n    value: function source(prop, loc) {\n      if (!this._map) return;\n      this._normalizePosition(prop, loc, 0, 0);\n    }\n  }, {\n    key: \"sourceWithOffset\",\n    value: function sourceWithOffset(prop, loc, lineOffset, columnOffset) {\n      if (!this._map) return;\n      this._normalizePosition(prop, loc, lineOffset, columnOffset);\n    }\n  }, {\n    key: \"withSource\",\n    value: function withSource(prop, loc, cb) {\n      if (!this._map) return cb();\n      this.source(prop, loc);\n      cb();\n    }\n  }, {\n    key: \"_normalizePosition\",\n    value: function _normalizePosition(prop, loc, lineOffset, columnOffset) {\n      var pos = loc[prop];\n      var target = this._sourcePosition;\n      if (pos) {\n        target.line = pos.line + lineOffset;\n        target.column = pos.column + columnOffset;\n        target.filename = loc.filename;\n      }\n    }\n  }, {\n    key: \"getCurrentColumn\",\n    value: function getCurrentColumn() {\n      var queue = this._queue;\n      var queueCursor = this._queueCursor;\n      var lastIndex = -1;\n      var len = 0;\n      for (var i = 0; i < queueCursor; i++) {\n        var item = queue[i];\n        if (item.char === 10) {\n          lastIndex = len;\n        }\n        len += item.repeat;\n      }\n      return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n    }\n  }, {\n    key: \"getCurrentLine\",\n    value: function getCurrentLine() {\n      var count = 0;\n      var queue = this._queue;\n      for (var i = 0; i < this._queueCursor; i++) {\n        if (queue[i].char === 10) {\n          count++;\n        }\n      }\n      return this._position.line + count;\n    }\n  }]);\n  return Buffer;\n}();\nexports.default = Buffer;","map":null,"metadata":{},"sourceType":"script"}