{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _taggedTemplateLiteral = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/taggedTemplateLiteral\");\nvar _templateObject;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nfunction helpers() {\n  var data = require(\"@babel/helpers\");\n  helpers = function helpers() {\n    return data;\n  };\n  return data;\n}\nfunction _generator() {\n  var data = require(\"@babel/generator\");\n  _generator = function _generator() {\n    return data;\n  };\n  return data;\n}\nfunction _template() {\n  var data = require(\"@babel/template\");\n  _template = function _template() {\n    return data;\n  };\n  return data;\n}\nfunction _t() {\n  var data = require(\"@babel/types\");\n  _t = function _t() {\n    return data;\n  };\n  return data;\n}\nvar _file = require(\"../transformation/file/file\");\nvar _t2 = _t(),\n  arrayExpression = _t2.arrayExpression,\n  assignmentExpression = _t2.assignmentExpression,\n  binaryExpression = _t2.binaryExpression,\n  blockStatement = _t2.blockStatement,\n  callExpression = _t2.callExpression,\n  cloneNode = _t2.cloneNode,\n  conditionalExpression = _t2.conditionalExpression,\n  exportNamedDeclaration = _t2.exportNamedDeclaration,\n  exportSpecifier = _t2.exportSpecifier,\n  expressionStatement = _t2.expressionStatement,\n  functionExpression = _t2.functionExpression,\n  identifier = _t2.identifier,\n  memberExpression = _t2.memberExpression,\n  objectExpression = _t2.objectExpression,\n  program = _t2.program,\n  stringLiteral = _t2.stringLiteral,\n  unaryExpression = _t2.unaryExpression,\n  variableDeclaration = _t2.variableDeclaration,\n  variableDeclarator = _t2.variableDeclarator;\nvar buildUmdWrapper = function buildUmdWrapper(replacements) {\n  return _template().default.statement(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    (function (root, factory) {\\n      if (typeof define === \\\"function\\\" && define.amd) {\\n        define(AMD_ARGUMENTS, factory);\\n      } else if (typeof exports === \\\"object\\\") {\\n        factory(COMMON_ARGUMENTS);\\n      } else {\\n        factory(BROWSER_ARGUMENTS);\\n      }\\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\\n      FACTORY_BODY\\n    });\\n  \"])))(replacements);\n};\nfunction buildGlobal(allowlist) {\n  var namespace = identifier(\"babelHelpers\");\n  var body = [];\n  var container = functionExpression(null, [identifier(\"global\")], blockStatement(body));\n  var tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", identifier(\"global\")), stringLiteral(\"undefined\")), identifier(\"self\"), identifier(\"global\"))]))]);\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, assignmentExpression(\"=\", memberExpression(identifier(\"global\"), namespace), objectExpression([])))]));\n  buildHelpers(body, namespace, allowlist);\n  return tree;\n}\nfunction buildModule(allowlist) {\n  var body = [];\n  var refs = buildHelpers(body, null, allowlist);\n  body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(function (name) {\n    return exportSpecifier(cloneNode(refs[name]), identifier(name));\n  })));\n  return program(body, [], \"module\");\n}\nfunction buildUmd(allowlist) {\n  var namespace = identifier(\"babelHelpers\");\n  var body = [];\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, identifier(\"global\"))]));\n  buildHelpers(body, namespace, allowlist);\n  return program([buildUmdWrapper({\n    FACTORY_PARAMETERS: identifier(\"global\"),\n    BROWSER_ARGUMENTS: assignmentExpression(\"=\", memberExpression(identifier(\"root\"), namespace), objectExpression([])),\n    COMMON_ARGUMENTS: identifier(\"exports\"),\n    AMD_ARGUMENTS: arrayExpression([stringLiteral(\"exports\")]),\n    FACTORY_BODY: body,\n    UMD_ROOT: identifier(\"this\")\n  })]);\n}\nfunction buildVar(allowlist) {\n  var namespace = identifier(\"babelHelpers\");\n  var body = [];\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, objectExpression([]))]));\n  var tree = program(body);\n  buildHelpers(body, namespace, allowlist);\n  body.push(expressionStatement(namespace));\n  return tree;\n}\nfunction buildHelpers(body, namespace, allowlist) {\n  var getHelperReference = function getHelperReference(name) {\n    return namespace ? memberExpression(namespace, identifier(name)) : identifier(\"_\".concat(name));\n  };\n  var refs = {};\n  helpers().list.forEach(function (name) {\n    if (allowlist && allowlist.indexOf(name) < 0) return;\n    var ref = refs[name] = getHelperReference(name);\n    helpers().ensure(name, _file.default);\n    var _helpers$get = helpers().get(name, getHelperReference, ref),\n      nodes = _helpers$get.nodes;\n    body.push.apply(body, _toConsumableArray(nodes));\n  });\n  return refs;\n}\nfunction _default(allowlist) {\n  var outputType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"global\";\n  var tree;\n  var build = {\n    global: buildGlobal,\n    module: buildModule,\n    umd: buildUmd,\n    var: buildVar\n  }[outputType];\n  if (build) {\n    tree = build(allowlist);\n  } else {\n    throw new Error(\"Unsupported output type \".concat(outputType));\n  }\n  return (0, _generator().default)(tree).code;\n}\n0 && 0;","map":null,"metadata":{},"sourceType":"script"}