{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = queueRunner;\nvar _p_cancelable = require('./p_cancelable');\nvar _p_cancelable2 = _interopRequireDefault(_p_cancelable);\nvar _p_timeout = require('./p_timeout');\nvar _p_timeout2 = _interopRequireDefault(_p_timeout);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n// Try getting the real promise object from the context, if available. Someone\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\nfunction queueRunner(options) {\n  var token = new _p_cancelable2.default(function (onCancel, resolve) {\n    onCancel(resolve);\n  });\n  var mapper = function mapper(_ref) {\n    var fn = _ref.fn,\n      timeout = _ref.timeout;\n    var _ref$initError = _ref.initError;\n    var initError = _ref$initError === undefined ? new Error() : _ref$initError;\n    var promise = new Promise(function (resolve) {\n      var next = function next(err) {\n        if (err) {\n          options.fail.apply(null, arguments);\n        }\n        resolve();\n      };\n      next.fail = function () {\n        options.fail.apply(null, arguments);\n        resolve();\n      };\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve();\n      }\n    });\n    promise = Promise.race([promise, token]);\n    if (!timeout) {\n      return promise;\n    }\n    var timeoutMs = timeout();\n    return (0, _p_timeout2.default)(promise, timeoutMs, options.clearTimeout, options.setTimeout, function () {\n      initError.message = 'Timeout - Async callback was not invoked within the ' + timeoutMs + 'ms timeout specified by jest.setTimeout.';\n      options.onException(initError);\n    });\n  };\n  var result = options.queueableFns.reduce(function (promise, fn) {\n    return promise.then(function () {\n      return mapper(fn);\n    });\n  }, Promise.resolve());\n  return {\n    cancel: token.cancel.bind(token),\n    catch: result.catch.bind(result),\n    then: result.then.bind(result)\n  };\n}","map":null,"metadata":{},"sourceType":"script"}