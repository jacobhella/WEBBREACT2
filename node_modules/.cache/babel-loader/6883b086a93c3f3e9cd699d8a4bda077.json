{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.wrapAnsiString = exports.getSummary = exports.pluralize = exports.relativePath = exports.formatTestPath = exports.trimAndFormatPath = exports.printDisplayName = undefined;\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return']) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n  };\n}();\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _chalk;\nfunction _load_chalk() {\n  return _chalk = _interopRequireDefault(require('chalk'));\n}\nvar _slash;\nfunction _load_slash() {\n  return _slash = _interopRequireDefault(require('slash'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar PROGRESS_BAR_WIDTH = 40;\nvar printDisplayName = exports.printDisplayName = function (config) {\n  var displayName = config.displayName;\n  if (displayName) {\n    return (_chalk || _load_chalk()).default.supportsColor ? (_chalk || _load_chalk()).default.reset.inverse.white(\" \".concat(displayName, \" \")) : displayName;\n  }\n  return '';\n};\nvar trimAndFormatPath = exports.trimAndFormatPath = function (pad, config, testPath, columns) {\n  var maxLength = columns - pad;\n  var relative = relativePath(config, testPath);\n  var basename = relative.basename;\n  var dirname = relative.dirname;\n\n  // length is ok\n\n  if ((dirname + (_path || _load_path()).default.sep + basename).length <= maxLength) {\n    return (0, (_slash || _load_slash()).default)((_chalk || _load_chalk()).default.dim(dirname + (_path || _load_path()).default.sep) + (_chalk || _load_chalk()).default.bold(basename));\n  }\n\n  // we can fit trimmed dirname and full basename\n  var basenameLength = basename.length;\n  if (basenameLength + 4 < maxLength) {\n    var dirnameLength = maxLength - 4 - basenameLength;\n    dirname = '...' + dirname.slice(dirname.length - dirnameLength, dirname.length);\n    return (0, (_slash || _load_slash()).default)((_chalk || _load_chalk()).default.dim(dirname + (_path || _load_path()).default.sep) + (_chalk || _load_chalk()).default.bold(basename));\n  }\n  if (basenameLength + 4 === maxLength) {\n    return (0, (_slash || _load_slash()).default)((_chalk || _load_chalk()).default.dim('...' + (_path || _load_path()).default.sep) + (_chalk || _load_chalk()).default.bold(basename));\n  }\n\n  // can't fit dirname, but can fit trimmed basename\n  return (0, (_slash || _load_slash()).default)((_chalk || _load_chalk()).default.bold('...' + basename.slice(basename.length - maxLength - 4, basename.length)));\n};\nvar formatTestPath = exports.formatTestPath = function (config, testPath) {\n  var _relativePath = relativePath(config, testPath);\n  var dirname = _relativePath.dirname,\n    basename = _relativePath.basename;\n  return (0, (_slash || _load_slash()).default)((_chalk || _load_chalk()).default.dim(dirname + (_path || _load_path()).default.sep) + (_chalk || _load_chalk()).default.bold(basename));\n};\nvar relativePath = exports.relativePath = function (config, testPath) {\n  // this function can be called with ProjectConfigs or GlobalConfigs. GlobalConfigs\n  // do not have config.cwd, only config.rootDir. Try using config.cwd, fallback\n  // to config.rootDir. (Also, some unit just use config.rootDir, which is ok)\n  testPath = (_path || _load_path()).default.relative(config.cwd || config.rootDir, testPath);\n  var dirname = (_path || _load_path()).default.dirname(testPath);\n  var basename = (_path || _load_path()).default.basename(testPath);\n  return {\n    basename: basename,\n    dirname: dirname\n  };\n};\nvar pluralize = exports.pluralize = function (word, count) {\n  return \"\".concat(count, \" \").concat(word).concat(count === 1 ? '' : 's');\n};\nvar getSummary = exports.getSummary = function (aggregatedResults, options) {\n  var runTime = (Date.now() - aggregatedResults.startTime) / 1000;\n  if (options && options.roundTime) {\n    runTime = Math.floor(runTime);\n  }\n  var estimatedTime = options && options.estimatedTime || 0;\n  var snapshotResults = aggregatedResults.snapshot;\n  var snapshotsAdded = snapshotResults.added;\n  var snapshotsFailed = snapshotResults.unmatched;\n  var snapshotsOutdated = snapshotResults.unchecked;\n  var snapshotsFilesRemoved = snapshotResults.filesRemoved;\n  var snapshotsDidUpdate = snapshotResults.didUpdate;\n  var snapshotsPassed = snapshotResults.matched;\n  var snapshotsTotal = snapshotResults.total;\n  var snapshotsUpdated = snapshotResults.updated;\n  var suitesFailed = aggregatedResults.numFailedTestSuites;\n  var suitesPassed = aggregatedResults.numPassedTestSuites;\n  var suitesPending = aggregatedResults.numPendingTestSuites;\n  var suitesRun = suitesFailed + suitesPassed;\n  var suitesTotal = aggregatedResults.numTotalTestSuites;\n  var testsFailed = aggregatedResults.numFailedTests;\n  var testsPassed = aggregatedResults.numPassedTests;\n  var testsPending = aggregatedResults.numPendingTests;\n  var testsTotal = aggregatedResults.numTotalTests;\n  var width = options && options.width || 0;\n  var suites = (_chalk || _load_chalk()).default.bold('Test Suites: ') + (suitesFailed ? (_chalk || _load_chalk()).default.bold.red(\"\".concat(suitesFailed, \" failed\")) + ', ' : '') + (suitesPending ? (_chalk || _load_chalk()).default.bold.yellow(\"\".concat(suitesPending, \" skipped\")) + ', ' : '') + (suitesPassed ? (_chalk || _load_chalk()).default.bold.green(\"\".concat(suitesPassed, \" passed\")) + ', ' : '') + (suitesRun !== suitesTotal ? suitesRun + ' of ' + suitesTotal : suitesTotal) + \" total\";\n  var tests = (_chalk || _load_chalk()).default.bold('Tests:       ') + (testsFailed ? (_chalk || _load_chalk()).default.bold.red(\"\".concat(testsFailed, \" failed\")) + ', ' : '') + (testsPending ? (_chalk || _load_chalk()).default.bold.yellow(\"\".concat(testsPending, \" skipped\")) + ', ' : '') + (testsPassed ? (_chalk || _load_chalk()).default.bold.green(\"\".concat(testsPassed, \" passed\")) + ', ' : '') + \"\".concat(testsTotal, \" total\");\n  var snapshots = (_chalk || _load_chalk()).default.bold('Snapshots:   ') + (snapshotsFailed ? (_chalk || _load_chalk()).default.bold.red(\"\".concat(snapshotsFailed, \" failed\")) + ', ' : '') + (snapshotsOutdated && !snapshotsDidUpdate ? (_chalk || _load_chalk()).default.bold.yellow(\"\".concat(snapshotsOutdated, \" obsolete\")) + ', ' : '') + (snapshotsOutdated && snapshotsDidUpdate ? (_chalk || _load_chalk()).default.bold.green(\"\".concat(snapshotsOutdated, \" removed\")) + ', ' : '') + (snapshotsFilesRemoved && !snapshotsDidUpdate ? (_chalk || _load_chalk()).default.bold.yellow(pluralize('file', snapshotsFilesRemoved) + ' obsolete') + ', ' : '') + (snapshotsFilesRemoved && snapshotsDidUpdate ? (_chalk || _load_chalk()).default.bold.green(pluralize('file', snapshotsFilesRemoved) + ' removed') + ', ' : '') + (snapshotsUpdated ? (_chalk || _load_chalk()).default.bold.green(\"\".concat(snapshotsUpdated, \" updated\")) + ', ' : '') + (snapshotsAdded ? (_chalk || _load_chalk()).default.bold.green(\"\".concat(snapshotsAdded, \" written\")) + ', ' : '') + (snapshotsPassed ? (_chalk || _load_chalk()).default.bold.green(\"\".concat(snapshotsPassed, \" passed\")) + ', ' : '') + \"\".concat(snapshotsTotal, \" total\");\n  var time = renderTime(runTime, estimatedTime, width);\n  return [suites, tests, snapshots, time].join('\\n');\n};\nvar renderTime = function renderTime(runTime, estimatedTime, width) {\n  // If we are more than one second over the estimated time, highlight it.\n  var renderedTime = estimatedTime && runTime >= estimatedTime + 1 ? (_chalk || _load_chalk()).default.bold.yellow(runTime + 's') : runTime + 's';\n  var time = (_chalk || _load_chalk()).default.bold(\"Time:\") + \"        \".concat(renderedTime);\n  if (runTime < estimatedTime) {\n    time += \", estimated \".concat(estimatedTime, \"s\");\n  }\n\n  // Only show a progress bar if the test run is actually going to take\n  // some time.\n  if (estimatedTime > 2 && runTime < estimatedTime && width) {\n    var availableWidth = Math.min(PROGRESS_BAR_WIDTH, width);\n    var length = Math.min(Math.floor(runTime / estimatedTime * availableWidth), availableWidth);\n    if (availableWidth >= 2) {\n      time += '\\n' + (_chalk || _load_chalk()).default.green('█').repeat(length) + (_chalk || _load_chalk()).default.white('█').repeat(availableWidth - length);\n    }\n  }\n  return time;\n};\n\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nvar wrapAnsiString = exports.wrapAnsiString = function (string, terminalWidth) {\n  if (terminalWidth === 0) {\n    // if the terminal width is zero, don't bother word-wrapping\n    return string;\n  }\n  var ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/g;\n  var tokens = [];\n  var lastIndex = 0;\n  var match;\n  while (match = ANSI_REGEXP.exec(string)) {\n    var ansi = match[0];\n    var index = match['index'];\n    if (index != lastIndex) {\n      tokens.push(['string', string.slice(lastIndex, index)]);\n    }\n    tokens.push(['ansi', ansi]);\n    lastIndex = index + ansi.length;\n  }\n  if (lastIndex != string.length - 1) {\n    tokens.push(['string', string.slice(lastIndex, string.length)]);\n  }\n  var lastLineLength = 0;\n  return tokens.reduce(function (lines, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    var kind = _ref2[0],\n      token = _ref2[1];\n    if (kind === 'string') {\n      if (lastLineLength + token.length > terminalWidth) {\n        while (token.length) {\n          var chunk = token.slice(0, terminalWidth - lastLineLength);\n          var remaining = token.slice(terminalWidth - lastLineLength, token.length);\n          lines[lines.length - 1] += chunk;\n          lastLineLength += chunk.length;\n          token = remaining;\n          if (token.length) {\n            lines.push('');\n            lastLineLength = 0;\n          }\n        }\n      } else {\n        lines[lines.length - 1] += token;\n        lastLineLength += token.length;\n      }\n    } else {\n      lines[lines.length - 1] += token;\n    }\n    return lines;\n  }, ['']).join('\\n');\n};","map":null,"metadata":{},"sourceType":"script"}