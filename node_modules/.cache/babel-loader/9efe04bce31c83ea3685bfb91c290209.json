{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _child_process;\nfunction _load_child_process() {\n  return _child_process = require('child_process');\n}\nvar _package;\nfunction _load_package() {\n  return _package = require('../package.json');\n}\nvar _worker;\nfunction _load_worker() {\n  return _worker = require('./worker');\n}\nvar _crypto;\nfunction _load_crypto() {\n  return _crypto = _interopRequireDefault(require('crypto'));\n}\nvar _events;\nfunction _load_events() {\n  return _events = _interopRequireDefault(require('events'));\n}\nvar _fs;\nfunction _load_fs() {\n  return _fs = _interopRequireDefault(require('fs'));\n}\nvar _get_mock_name;\nfunction _load_get_mock_name() {\n  return _get_mock_name = _interopRequireDefault(require('./get_mock_name'));\n}\nvar _get_platform_extension;\nfunction _load_get_platform_extension() {\n  return _get_platform_extension = _interopRequireDefault(require('./lib/get_platform_extension'));\n}\nvar _constants;\nfunction _load_constants() {\n  return _constants = _interopRequireDefault(require('./constants'));\n}\nvar _haste_fs;\nfunction _load_haste_fs() {\n  return _haste_fs = _interopRequireDefault(require('./haste_fs'));\n}\nvar _module_map;\nfunction _load_module_map() {\n  return _module_map = _interopRequireDefault(require('./module_map'));\n}\nvar _invariant;\nfunction _load_invariant() {\n  return _invariant = _interopRequireDefault(require('invariant'));\n}\nvar _node;\nfunction _load_node() {\n  return _node = _interopRequireDefault(require('./crawlers/node'));\n}\nvar _normalize_path_sep;\nfunction _load_normalize_path_sep() {\n  return _normalize_path_sep = _interopRequireDefault(require('./lib/normalize_path_sep'));\n}\nvar _os;\nfunction _load_os() {\n  return _os = _interopRequireDefault(require('os'));\n}\nvar _path;\nfunction _load_path() {\n  return _path = _interopRequireDefault(require('path'));\n}\nvar _sane;\nfunction _load_sane() {\n  return _sane = _interopRequireDefault(require('sane'));\n}\nvar _jestSerializer;\nfunction _load_jestSerializer() {\n  return _jestSerializer = _interopRequireDefault(require('jest-serializer'));\n}\nvar _watchman;\nfunction _load_watchman() {\n  return _watchman = _interopRequireDefault(require('./crawlers/watchman'));\n}\nvar _watchman_watcher;\nfunction _load_watchman_watcher() {\n  return _watchman_watcher = _interopRequireDefault(require('./lib/watchman_watcher'));\n}\nvar _jestWorker;\nfunction _load_jestWorker() {\n  return _jestWorker = _interopRequireDefault(require('jest-worker'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar CHANGE_INTERVAL = 30;\n// eslint-disable-next-line import/default\n\n// eslint-disable-next-line import/default\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nvar MAX_WAIT_TIME = 240000;\nvar NODE_MODULES = (_path || _load_path()).default.sep + 'node_modules' + (_path || _load_path()).default.sep;\nvar canUseWatchman = function () {\n  try {\n    (0, (_child_process || _load_child_process()).execSync)('watchman --version', {\n      stdio: ['ignore']\n    });\n    return true;\n  } catch (e) {}\n  return false;\n}();\nvar escapePathSeparator = function escapePathSeparator(string) {\n  return (_path || _load_path()).default.sep === '\\\\' ? string.replace(/(\\/|\\\\)/g, '\\\\\\\\') : string;\n};\nvar getWhiteList = function getWhiteList(list) {\n  if (list && list.length) {\n    return new RegExp('(' + escapePathSeparator(NODE_MODULES) + '(?:' + list.join('|') + ')(?=$|' + escapePathSeparator((_path || _load_path()).default.sep) + '))', 'g');\n  }\n  return null;\n};\n\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\nvar HasteMap = /*#__PURE__*/function (_default) {\n  _inherits(HasteMap, _default);\n  function HasteMap(options) {\n    var _this;\n    _classCallCheck(this, HasteMap);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HasteMap).call(this));\n    _this._options = {\n      cacheDirectory: options.cacheDirectory || (_os || _load_os()).default.tmpdir(),\n      computeDependencies: options.computeDependencies === undefined ? true : options.computeDependencies,\n      computeSha1: options.computeSha1 || false,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      ignorePattern: options.ignorePattern,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,\n      name: options.name,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      roots: Array.from(new Set(options.roots)),\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman == null ? true : options.useWatchman,\n      watch: !!options.watch\n    };\n    _this._console = options.console || global.console;\n    if (!(options.ignorePattern instanceof RegExp)) {\n      _this._console.warn('jest-haste-map: the `ignorePattern` options as a function is being ' + 'deprecated. Provide a RegExp instead. See https://github.com/facebook/jest/pull/4063.');\n    }\n    _this._cachePath = HasteMap.getCacheFilePath(_this._options.cacheDirectory, \"haste-map-\".concat(_this._options.name), (_package || _load_package()).version, _this._options.roots.join(':'), _this._options.extensions.join(':'), _this._options.platforms.join(':'), _this._options.computeSha1.toString(), options.mocksPattern || '', options.ignorePattern.toString());\n    _this._whitelist = getWhiteList(options.providesModuleNodeModules);\n    _this._buildPromise = null;\n    _this._watchers = [];\n    _this._worker = null;\n    return _this;\n  }\n  _createClass(HasteMap, [{\n    key: \"build\",\n    value: function build() {\n      var _this2 = this;\n      if (!this._buildPromise) {\n        this._buildPromise = this._buildFileMap().then(function (data) {\n          return _this2._buildHasteMap(data);\n        }).then(function (hasteMap) {\n          _this2._persist(hasteMap);\n          var hasteFS = new (_haste_fs || _load_haste_fs()).default(hasteMap.files);\n          var moduleMap = new (_module_map || _load_module_map()).default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks\n          });\n          var __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;\n          return _this2._watch(hasteMap, hasteFS, moduleMap).then(function () {\n            return {\n              __hasteMapForTest: __hasteMapForTest,\n              hasteFS: hasteFS,\n              moduleMap: moduleMap\n            };\n          });\n        });\n      }\n      return this._buildPromise;\n    }\n    /**\n     * 1. read data from the cache or create an empty structure.\n     */\n  }, {\n    key: \"read\",\n    value: function read() {\n      var hasteMap;\n      try {\n        hasteMap = (_jestSerializer || _load_jestSerializer()).default.readFileSync(this._cachePath);\n      } catch (err) {\n        hasteMap = this._createEmptyMap();\n      }\n      for (var key in hasteMap) {\n        Object.setPrototypeOf(hasteMap[key], null);\n      }\n      return hasteMap;\n    }\n  }, {\n    key: \"readModuleMap\",\n    value: function readModuleMap() {\n      var data = this.read();\n      return new (_module_map || _load_module_map()).default({\n        duplicates: data.duplicates,\n        map: data.map,\n        mocks: data.mocks\n      });\n    }\n    /**\n     * 2. crawl the file system.\n     */\n  }, {\n    key: \"_buildFileMap\",\n    value: function _buildFileMap() {\n      var _this3 = this;\n      var read = this._options.resetCache ? this._createEmptyMap : this.read;\n      return Promise.resolve().then(function () {\n        return read.call(_this3);\n      }).catch(function () {\n        return _this3._createEmptyMap();\n      }).then(function (cachedHasteMap) {\n        var cachedFiles = Object.keys(cachedHasteMap.files).map(function (filePath) {\n          var moduleName = cachedHasteMap.files[filePath][(_constants || _load_constants()).default.ID];\n          return {\n            moduleName: moduleName,\n            path: filePath\n          };\n        });\n        return _this3._crawl(cachedHasteMap).then(function (hasteMap) {\n          var deprecatedFiles = cachedFiles.filter(function (file) {\n            var fileData = hasteMap.files[file.path];\n            return fileData == null || file.moduleName !== fileData[(_constants || _load_constants()).default.ID];\n          });\n          return {\n            deprecatedFiles: deprecatedFiles,\n            hasteMap: hasteMap\n          };\n        });\n      });\n    }\n    /**\n     * 3. parse and extract metadata from changed files.\n     */\n  }, {\n    key: \"_processFile\",\n    value: function _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n      var _this4 = this;\n      var setModule = function setModule(id, module) {\n        if (!map[id]) {\n          // $FlowFixMe\n          map[id] = Object.create(null);\n        }\n        var moduleMap = map[id];\n        var platform = (0, (_get_platform_extension || _load_get_platform_extension()).default)(module[(_constants || _load_constants()).default.PATH], _this4._options.platforms) || (_constants || _load_constants()).default.GENERIC_PLATFORM;\n        var existingModule = moduleMap[platform];\n        if (existingModule && existingModule[(_constants || _load_constants()).default.PATH] !== module[(_constants || _load_constants()).default.PATH]) {\n          var message = \"jest-haste-map: @providesModule naming collision:\\n\" + \"  Duplicate module name: \".concat(id, \"\\n\") + \"  Paths: \".concat(module[(_constants || _load_constants()).default.PATH], \" collides with \") + \"\".concat(existingModule[(_constants || _load_constants()).default.PATH], \"\\n\\nThis \") + \"\".concat(_this4._options.throwOnModuleCollision ? 'error' : 'warning', \" \") + \"is caused by a @providesModule declaration \" + \"with the same name across two different files.\";\n          if (_this4._options.throwOnModuleCollision) {\n            throw new Error(message);\n          }\n          _this4._console.warn(message);\n          // We do NOT want consumers to use a module that is ambiguous.\n          delete moduleMap[platform];\n          if (Object.keys(moduleMap).length === 1) {\n            delete map[id];\n          }\n          var _dupsByPlatform = hasteMap.duplicates[id];\n          if (_dupsByPlatform == null) {\n            _dupsByPlatform = hasteMap.duplicates[id] = Object.create(null);\n          }\n          var dups = _dupsByPlatform[platform] = Object.create(null);\n          dups[module[(_constants || _load_constants()).default.PATH]] = module[(_constants || _load_constants()).default.TYPE];\n          dups[existingModule[(_constants || _load_constants()).default.PATH]] = existingModule[(_constants || _load_constants()).default.TYPE];\n          return;\n        }\n        var dupsByPlatform = hasteMap.duplicates[id];\n        if (dupsByPlatform != null) {\n          var _dups = dupsByPlatform[platform];\n          if (_dups != null) {\n            _dups[module[(_constants || _load_constants()).default.PATH]] = module[(_constants || _load_constants()).default.TYPE];\n          }\n          return;\n        }\n        moduleMap[platform] = module;\n      };\n      var fileMetadata = hasteMap.files[filePath];\n      var moduleMetadata = hasteMap.map[fileMetadata[(_constants || _load_constants()).default.ID]];\n      var computeSha1 = this._options.computeSha1 && !fileMetadata[(_constants || _load_constants()).default.SHA1];\n\n      // Callback called when the response from the worker is successful.\n      var workerReply = function workerReply(metadata) {\n        // `1` for truthy values instead of `true` to save cache space.\n        fileMetadata[(_constants || _load_constants()).default.VISITED] = 1;\n        var metadataId = metadata.id;\n        var metadataModule = metadata.module;\n        if (metadataId && metadataModule) {\n          fileMetadata[(_constants || _load_constants()).default.ID] = metadataId;\n          setModule(metadataId, metadataModule);\n        }\n        fileMetadata[(_constants || _load_constants()).default.DEPENDENCIES] = metadata.dependencies || [];\n        if (computeSha1) {\n          fileMetadata[(_constants || _load_constants()).default.SHA1] = metadata.sha1;\n        }\n      };\n\n      // Callback called when the response from the worker is an error.\n      var workerError = function workerError(error) {\n        if (typeof error !== 'object' || !error.message || !error.stack) {\n          error = new Error(error);\n          error.stack = ''; // Remove stack for stack-less errors.\n        }\n\n        // $FlowFixMe: checking error code is OK if error comes from \"fs\".\n        if (!['ENOENT', 'EACCES'].includes(error.code)) {\n          throw error;\n        }\n\n        // If a file cannot be read we remove it from the file list and\n        // ignore the failure silently.\n        delete hasteMap.files[filePath];\n      };\n\n      // If we retain all files in the virtual HasteFS representation, we avoid\n      // reading them if they aren't important (node_modules).\n      if (this._options.retainAllFiles && this._isNodeModulesDir(filePath)) {\n        if (computeSha1) {\n          return this._getWorker(workerOptions).getSha1({\n            computeDependencies: this._options.computeDependencies,\n            computeSha1: computeSha1,\n            filePath: filePath,\n            hasteImplModulePath: this._options.hasteImplModulePath\n          }).then(workerReply, workerError);\n        }\n        return null;\n      }\n      if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n        var mockPath = (0, (_get_mock_name || _load_get_mock_name()).default)(filePath);\n        if (mocks[mockPath]) {\n          this._console.warn(\"jest-haste-map: duplicate manual mock found:\\n\" + \"  Module name: \".concat(mockPath, \"\\n\") + \"  Duplicate Mock path: \".concat(filePath, \"\\nThis warning \") + \"is caused by two manual mock files with the same file name.\\n\" + \"Jest will use the mock file found in: \\n\" + \"\".concat(filePath, \"\\n\") + \" Please delete one of the following two files: \\n \" + \"\".concat(mocks[mockPath], \"\\n\").concat(filePath, \"\\n\\n\"));\n        }\n        mocks[mockPath] = filePath;\n      }\n      if (fileMetadata[(_constants || _load_constants()).default.VISITED]) {\n        if (!fileMetadata[(_constants || _load_constants()).default.ID]) {\n          return null;\n        }\n        if (moduleMetadata != null) {\n          var platform = (0, (_get_platform_extension || _load_get_platform_extension()).default)(filePath, this._options.platforms) || (_constants || _load_constants()).default.GENERIC_PLATFORM;\n          var _module = moduleMetadata[platform];\n          if (_module == null) {\n            return null;\n          }\n          var modulesByPlatform = map[fileMetadata[(_constants || _load_constants()).default.ID]] || (map[fileMetadata[(_constants || _load_constants()).default.ID]] = {});\n          modulesByPlatform[platform] = _module;\n          return null;\n        }\n      }\n      return this._getWorker(workerOptions).worker({\n        computeDependencies: this._options.computeDependencies,\n        computeSha1: computeSha1,\n        filePath: filePath,\n        hasteImplModulePath: this._options.hasteImplModulePath\n      }).then(workerReply, workerError);\n    }\n  }, {\n    key: \"_buildHasteMap\",\n    value: function _buildHasteMap(data) {\n      var _this5 = this;\n      var deprecatedFiles = data.deprecatedFiles,\n        hasteMap = data.hasteMap;\n      var map = Object.create(null);\n      var mocks = Object.create(null);\n      var promises = [];\n      for (var i = 0; i < deprecatedFiles.length; ++i) {\n        var file = deprecatedFiles[i];\n        this._recoverDuplicates(hasteMap, file.path, file.moduleName);\n      }\n      for (var filePath in hasteMap.files) {\n        // SHA-1, if requested, should already be present thanks to the crawler.\n        var promise = this._processFile(hasteMap, map, mocks, filePath);\n        if (promise) {\n          promises.push(promise);\n        }\n      }\n      return Promise.all(promises).then(function () {\n        _this5._cleanup();\n        hasteMap.map = map;\n        hasteMap.mocks = mocks;\n        return hasteMap;\n      }).catch(function (error) {\n        _this5._cleanup();\n        return Promise.reject(error);\n      });\n    }\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var worker = this._worker;\n\n      // $FlowFixMe\n      if (worker && typeof worker.end === 'function') {\n        worker.end();\n      }\n      this._worker = null;\n    }\n    /**\n     * 4. serialize the new `HasteMap` in a cache file.\n     */\n  }, {\n    key: \"_persist\",\n    value: function _persist(hasteMap) {\n      (_jestSerializer || _load_jestSerializer()).default.writeFileSync(this._cachePath, hasteMap);\n    }\n    /**\n     * Creates workers or parses files and extracts metadata in-process.\n     */\n  }, {\n    key: \"_getWorker\",\n    value: function _getWorker(options) {\n      if (!this._worker) {\n        if (options && options.forceInBand || this._options.maxWorkers <= 1) {\n          this._worker = {\n            getSha1: (_worker || _load_worker()).getSha1,\n            worker: (_worker || _load_worker()).worker\n          };\n        } else {\n          // $FlowFixMe: assignment of a worker with custom properties.\n          this._worker = new (_jestWorker || _load_jestWorker()).default(require.resolve('./worker'), {\n            exposedMethods: ['getSha1', 'worker'],\n            maxRetries: 3,\n            numWorkers: this._options.maxWorkers\n          });\n        }\n      }\n      return this._worker;\n    }\n  }, {\n    key: \"_crawl\",\n    value: function _crawl(hasteMap) {\n      var _this6 = this;\n      var options = this._options;\n      var ignore = this._ignore.bind(this);\n      var crawl = canUseWatchman && this._options.useWatchman ? (_watchman || _load_watchman()).default : (_node || _load_node()).default;\n      var retry = function retry(error) {\n        if (crawl === (_watchman || _load_watchman()).default) {\n          _this6._console.warn(\"jest-haste-map: Watchman crawl failed. Retrying once with node \" + \"crawler.\\n\" + \"  Usually this happens when watchman isn't running. Create an \" + \"empty `.watchmanconfig` file in your project's root folder or \" + \"initialize a git or hg repository in your project.\\n\" + \"  \" + error);\n          return (0, (_node || _load_node()).default)({\n            computeSha1: options.computeSha1,\n            data: hasteMap,\n            extensions: options.extensions,\n            forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n            ignore: ignore,\n            roots: options.roots\n          }).catch(function (e) {\n            throw new Error(\"Crawler retry failed:\\n\" + \"  Original error: \".concat(error.message, \"\\n\") + \"  Retry error: \".concat(e.message, \"\\n\"));\n          });\n        }\n        throw error;\n      };\n      try {\n        return crawl({\n          computeSha1: options.computeSha1,\n          data: hasteMap,\n          extensions: options.extensions,\n          forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n          ignore: ignore,\n          roots: options.roots\n        }).catch(retry);\n      } catch (error) {\n        return retry(error);\n      }\n    }\n    /**\n     * Watch mode\n     */\n  }, {\n    key: \"_watch\",\n    value: function _watch(hasteMap, hasteFS, moduleMap) {\n      var _this7 = this;\n      if (!this._options.watch) {\n        return Promise.resolve();\n      }\n\n      // In watch mode, we'll only warn about module collisions and we'll retain\n      // all files, even changes to node_modules.\n      this._options.throwOnModuleCollision = false;\n      this._options.retainAllFiles = true;\n      var Watcher = canUseWatchman && this._options.useWatchman ? (_watchman_watcher || _load_watchman_watcher()).default : (_os || _load_os()).default.platform() === 'darwin' ? (_sane || _load_sane()).default.FSEventsWatcher : (_sane || _load_sane()).default.NodeWatcher;\n      var extensions = this._options.extensions;\n      var ignorePattern = this._options.ignorePattern;\n      var changeQueue = Promise.resolve();\n      var eventsQueue = [];\n      // We only need to copy the entire haste map once on every \"frame\".\n      var mustCopy = true;\n      var createWatcher = function createWatcher(root) {\n        var watcher = new Watcher(root, {\n          dot: false,\n          glob: extensions.map(function (extension) {\n            return '**/*.' + extension;\n          }),\n          ignored: ignorePattern\n        });\n        return new Promise(function (resolve, reject) {\n          var rejectTimeout = setTimeout(function () {\n            return reject(new Error('Failed to start watch mode.'));\n          }, MAX_WAIT_TIME);\n          watcher.once('ready', function () {\n            clearTimeout(rejectTimeout);\n            watcher.on('all', onChange);\n            resolve(watcher);\n          });\n        });\n      };\n      var emitChange = function emitChange() {\n        if (eventsQueue.length) {\n          mustCopy = true;\n          _this7.emit('change', {\n            eventsQueue: eventsQueue,\n            hasteFS: new (_haste_fs || _load_haste_fs()).default(hasteMap.files),\n            moduleMap: new (_module_map || _load_module_map()).default({\n              duplicates: hasteMap.duplicates,\n              map: hasteMap.map,\n              mocks: hasteMap.mocks\n            })\n          });\n          eventsQueue = [];\n        }\n      };\n      var onChange = function onChange(type, filePath, root, stat) {\n        filePath = (_path || _load_path()).default.join(root, (0, (_normalize_path_sep || _load_normalize_path_sep()).default)(filePath));\n        if (stat && stat.isDirectory() || _this7._ignore(filePath) || !extensions.some(function (extension) {\n          return filePath.endsWith(extension);\n        })) {\n          return;\n        }\n        changeQueue = changeQueue.then(function () {\n          // If we get duplicate events for the same file, ignore them.\n          if (eventsQueue.find(function (event) {\n            return event.type === type && event.filePath === filePath && (!event.stat && !stat || event.stat && stat && event.stat.mtime.getTime() === stat.mtime.getTime());\n          })) {\n            return null;\n          }\n          if (mustCopy) {\n            mustCopy = false;\n            hasteMap = {\n              clocks: copy(hasteMap.clocks),\n              duplicates: copy(hasteMap.duplicates),\n              files: copy(hasteMap.files),\n              map: copy(hasteMap.map),\n              mocks: copy(hasteMap.mocks)\n            };\n          }\n          var add = function add() {\n            return eventsQueue.push({\n              filePath: filePath,\n              stat: stat,\n              type: type\n            });\n          };\n\n          // Delete the file and all of its metadata.\n          var moduleName = hasteMap.files[filePath] && hasteMap.files[filePath][(_constants || _load_constants()).default.ID];\n          var platform = (0, (_get_platform_extension || _load_get_platform_extension()).default)(filePath, _this7._options.platforms) || (_constants || _load_constants()).default.GENERIC_PLATFORM;\n          delete hasteMap.files[filePath];\n          var moduleMap = hasteMap.map[moduleName];\n          if (moduleMap != null) {\n            // We are forced to copy the object because jest-haste-map exposes\n            // the map as an immutable entity.\n            moduleMap = copy(moduleMap);\n            delete moduleMap[platform];\n            if (Object.keys(moduleMap).length === 0) {\n              delete hasteMap.map[moduleName];\n            } else {\n              hasteMap.map[moduleName] = moduleMap;\n            }\n          }\n          if (_this7._options.mocksPattern && _this7._options.mocksPattern.test(filePath)) {\n            var mockName = (0, (_get_mock_name || _load_get_mock_name()).default)(filePath);\n            delete hasteMap.mocks[mockName];\n          }\n          _this7._recoverDuplicates(hasteMap, filePath, moduleName);\n\n          // If the file was added or changed,\n          // parse it and update the haste map.\n          if (type === 'add' || type === 'change') {\n            (0, (_invariant || _load_invariant()).default)(stat, 'since the file exists or changed, it should have stats');\n            var fileMetadata = ['', stat.mtime.getTime(), 0, [], null];\n            hasteMap.files[filePath] = fileMetadata;\n            var promise = _this7._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {\n              forceInBand: true\n            });\n            // Cleanup\n            _this7._cleanup();\n            if (promise) {\n              return promise.then(add);\n            } else {\n              // If a file in node_modules has changed,\n              // emit an event regardless.\n              add();\n            }\n          } else {\n            add();\n          }\n          return null;\n        }).catch(function (error) {\n          _this7._console.error(\"jest-haste-map: watch error:\\n  \".concat(error.stack, \"\\n\"));\n        });\n      };\n      this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n      return Promise.all(this._options.roots.map(createWatcher)).then(function (watchers) {\n        _this7._watchers = watchers;\n      });\n    }\n    /**\n     * This function should be called when the file under `filePath` is removed\n     * or changed. When that happens, we want to figure out if that file was\n     * part of a group of files that had the same ID. If it was, we want to\n     * remove it from the group. Furthermore, if there is only one file\n     * remaining in the group, then we want to restore that single file as the\n     * correct resolution for its ID, and cleanup the duplicates index.\n     */\n  }, {\n    key: \"_recoverDuplicates\",\n    value: function _recoverDuplicates(hasteMap, filePath, moduleName) {\n      var dupsByPlatform = hasteMap.duplicates[moduleName];\n      if (dupsByPlatform == null) {\n        return;\n      }\n      var platform = (0, (_get_platform_extension || _load_get_platform_extension()).default)(filePath, this._options.platforms) || (_constants || _load_constants()).default.GENERIC_PLATFORM;\n      var dups = dupsByPlatform[platform];\n      if (dups == null) {\n        return;\n      }\n      dupsByPlatform = hasteMap.duplicates[moduleName] = copy(dupsByPlatform);\n      dups = dupsByPlatform[platform] = copy(dups);\n      var dedupType = dups[filePath];\n      delete dups[filePath];\n      var filePaths = Object.keys(dups);\n      if (filePaths.length > 1) {\n        return;\n      }\n      var dedupMap = hasteMap.map[moduleName];\n      if (dedupMap == null) {\n        dedupMap = hasteMap.map[moduleName] = Object.create(null);\n      }\n      dedupMap[platform] = [filePaths[0], dedupType];\n      delete dupsByPlatform[platform];\n      if (Object.keys(dupsByPlatform).length === 0) {\n        delete hasteMap.duplicates[moduleName];\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _this8 = this;\n      clearInterval(this._changeInterval);\n      if (!this._watchers.length) {\n        return Promise.resolve();\n      }\n      return Promise.all(this._watchers.map(function (watcher) {\n        return new Promise(function (resolve) {\n          return watcher.close(resolve);\n        });\n      })).then(function () {\n        _this8._watchers = [];\n      });\n    }\n    /**\n     * Helpers\n     */\n  }, {\n    key: \"_ignore\",\n    value: function _ignore(filePath) {\n      var ignorePattern = this._options.ignorePattern;\n      var ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern(filePath);\n      return ignoreMatched || !this._options.retainAllFiles && this._isNodeModulesDir(filePath);\n    }\n  }, {\n    key: \"_isNodeModulesDir\",\n    value: function _isNodeModulesDir(filePath) {\n      if (!filePath.includes(NODE_MODULES)) {\n        return false;\n      }\n      if (this._whitelist) {\n        var whitelist = this._whitelist;\n        var match = whitelist.exec(filePath);\n        var matchEndIndex = whitelist.lastIndex;\n        whitelist.lastIndex = 0;\n        if (!match) {\n          return true;\n        }\n        var filePathInPackage = filePath.substr(matchEndIndex);\n        return filePathInPackage.startsWith(NODE_MODULES);\n      }\n      return true;\n    }\n  }, {\n    key: \"_createEmptyMap\",\n    value: function _createEmptyMap() {\n      // $FlowFixMe\n      return {\n        clocks: Object.create(null),\n        duplicates: Object.create(null),\n        files: Object.create(null),\n        map: Object.create(null),\n        mocks: Object.create(null)\n      };\n    }\n  }], [{\n    key: \"getCacheFilePath\",\n    value: function getCacheFilePath(tmpdir, name) {\n      for (var _len = arguments.length, extra = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        extra[_key - 2] = arguments[_key];\n      }\n      var hash = (_crypto || _load_crypto()).default.createHash('md5').update(name + extra.join(''));\n      return (_path || _load_path()).default.join(tmpdir, name.replace(/\\W/g, '-') + '-' + hash.digest('hex'));\n    }\n  }]);\n  return HasteMap;\n}((_events || _load_events()).default);\nvar copy = function copy(object) {\n  return Object.assign(Object.create(null), object);\n};\nHasteMap.H = (_constants || _load_constants()).default;\nHasteMap.ModuleMap = (_module_map || _load_module_map()).default;\nmodule.exports = HasteMap;","map":null,"metadata":{},"sourceType":"script"}