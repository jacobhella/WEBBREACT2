{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.visitors = exports.Hub = exports.Scope = exports.NodePath = undefined;\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\nvar _path = require(\"./path\");\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_path).default;\n  }\n});\nvar _scope = require(\"./scope\");\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_scope).default;\n  }\n});\nvar _hub = require(\"./hub\");\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_hub).default;\n  }\n});\nexports.default = traverse;\nvar _context = require(\"./context\");\nvar _context2 = _interopRequireDefault(_context);\nvar _visitors = require(\"./visitors\");\nvar visitors = _interopRequireWildcard(_visitors);\nvar _babelMessages = require(\"babel-messages\");\nvar messages = _interopRequireWildcard(_babelMessages);\nvar _includes = require(\"lodash/includes\");\nvar _includes2 = _interopRequireDefault(_includes);\nvar _babelTypes = require(\"babel-types\");\nvar t = _interopRequireWildcard(_babelTypes);\nvar _cache = require(\"./cache\");\nvar cache = _interopRequireWildcard(_cache);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nexports.visitors = visitors;\nfunction traverse(parent, opts, scope, state, parentPath) {\n  if (!parent) return;\n  if (!opts) opts = {};\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(messages.get(\"traverseNeedsParent\", parent.type));\n    }\n  }\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\ntraverse.NodePath = require(\"./path\");\ntraverse.Scope = require(\"./scope\");\ntraverse.Hub = require(\"./hub\");\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  var keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  var context = new _context2.default(scope, opts, state, parentPath);\n  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n    var _ref;\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n    var key = _ref;\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\nfunction hasBlacklistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\ntraverse.hasType = function (tree, scope, type, blacklistTypes) {\n  if ((0, _includes2.default)(blacklistTypes, tree.type)) return false;\n  if (tree.type === type) return true;\n  var state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    blacklist: blacklistTypes,\n    enter: hasBlacklistedType\n  }, scope, state);\n  return state.has;\n};\ntraverse.clearCache = function () {\n  cache.clear();\n};\ntraverse.clearCache.clearPath = cache.clearPath;\ntraverse.clearCache.clearScope = cache.clearScope;\ntraverse.copyCache = function (source, destination) {\n  if (cache.path.has(source)) {\n    cache.path.set(destination, cache.path.get(source));\n  }\n};","map":null,"metadata":{},"sourceType":"script"}