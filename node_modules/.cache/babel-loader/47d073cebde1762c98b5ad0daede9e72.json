{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _fs = require('fs');\nvar _fs2 = _interopRequireDefault(_fs);\nvar _jestMessageUtil = require('jest-message-util');\nvar _utils = require('./utils');\nvar _inline_snapshots = require('./inline_snapshots');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar SnapshotState = /*#__PURE__*/function () {\n  function SnapshotState(testPath, options) {\n    _classCallCheck(this, SnapshotState);\n    this._snapshotPath = options.snapshotPath || (0, _utils.getSnapshotPath)(testPath);\n    var _getSnapshotData = (0, _utils.getSnapshotData)(this._snapshotPath, options.updateSnapshot);\n    var data = _getSnapshotData.data,\n      dirty = _getSnapshotData.dirty;\n    this._snapshotData = data;\n    this._dirty = dirty;\n    this._getBabelTraverse = options.getBabelTraverse;\n    this._getPrettier = options.getPrettier;\n    this._inlineSnapshots = [];\n    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));\n    this._counters = new Map();\n    this._index = 0;\n    this.expand = options.expand || false;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this._updateSnapshot = options.updateSnapshot;\n    this.updated = 0;\n  }\n  _createClass(SnapshotState, [{\n    key: \"markSnapshotsAsCheckedForTest\",\n    value: function markSnapshotsAsCheckedForTest(testName) {\n      var _this = this;\n      this._uncheckedKeys.forEach(function (uncheckedKey) {\n        if ((0, _utils.keyToTestName)(uncheckedKey) === testName) {\n          _this._uncheckedKeys.delete(uncheckedKey);\n        }\n      });\n    }\n  }, {\n    key: \"_addSnapshot\",\n    value: function _addSnapshot(key, receivedSerialized, options) {\n      this._dirty = true;\n      if (options.isInline) {\n        var error = options.error || new Error();\n        var lines = (0, _jestMessageUtil.getStackTraceLines)(error.stack);\n        var frame = (0, _jestMessageUtil.getTopFrame)(lines);\n        if (!frame) {\n          throw new Error(\"Jest: Couldn't infer stack frame for inline snapshot.\");\n        }\n        this._inlineSnapshots.push({\n          frame: frame,\n          snapshot: receivedSerialized\n        });\n      } else {\n        this._snapshotData[key] = receivedSerialized;\n      }\n    }\n  }, {\n    key: \"save\",\n    value: function save() {\n      var hasExternalSnapshots = Object.keys(this._snapshotData).length;\n      var hasInlineSnapshots = this._inlineSnapshots.length;\n      var isEmpty = !hasExternalSnapshots && !hasInlineSnapshots;\n      var status = {\n        deleted: false,\n        saved: false\n      };\n      if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {\n        if (hasExternalSnapshots) {\n          (0, _utils.saveSnapshotFile)(this._snapshotData, this._snapshotPath);\n        }\n        if (hasInlineSnapshots) {\n          var prettier = this._getPrettier(); // Load lazily\n          var babelTraverse = this._getBabelTraverse(); // Load lazily\n          (0, _inline_snapshots.saveInlineSnapshots)(this._inlineSnapshots, prettier, babelTraverse);\n        }\n        status.saved = true;\n      } else if (!hasExternalSnapshots && _fs2.default.existsSync(this._snapshotPath)) {\n        if (this._updateSnapshot === 'all') {\n          _fs2.default.unlinkSync(this._snapshotPath);\n        }\n        status.deleted = true;\n      }\n      return status;\n    }\n  }, {\n    key: \"getUncheckedCount\",\n    value: function getUncheckedCount() {\n      return this._uncheckedKeys.size || 0;\n    }\n  }, {\n    key: \"getUncheckedKeys\",\n    value: function getUncheckedKeys() {\n      return Array.from(this._uncheckedKeys);\n    }\n  }, {\n    key: \"removeUncheckedKeys\",\n    value: function removeUncheckedKeys() {\n      var _this2 = this;\n      if (this._updateSnapshot === 'all' && this._uncheckedKeys.size) {\n        this._dirty = true;\n        this._uncheckedKeys.forEach(function (key) {\n          return delete _this2._snapshotData[key];\n        });\n        this._uncheckedKeys.clear();\n      }\n    }\n  }, {\n    key: \"match\",\n    value: function match(_ref) {\n      var testName = _ref.testName,\n        received = _ref.received,\n        key = _ref.key,\n        inlineSnapshot = _ref.inlineSnapshot,\n        error = _ref.error;\n      this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n      var count = Number(this._counters.get(testName));\n      var isInline = inlineSnapshot !== undefined;\n      if (!key) {\n        key = (0, _utils.testNameToKey)(testName, count);\n      }\n\n      // Do not mark the snapshot as \"checked\" if the snapshot is inline and\n      // there's an external snapshot. This way the external snapshot can be\n      // removed with `--updateSnapshot`.\n      if (!(isInline && this._snapshotData[key])) {\n        this._uncheckedKeys.delete(key);\n      }\n      var receivedSerialized = (0, _utils.serialize)(received);\n      var expected = isInline ? inlineSnapshot : this._snapshotData[key];\n      var pass = expected === receivedSerialized;\n      var hasSnapshot = isInline ? inlineSnapshot !== '' : this._snapshotData[key] !== undefined;\n      var snapshotIsPersisted = isInline || _fs2.default.existsSync(this._snapshotPath);\n      if (pass && !isInline) {\n        // Executing a snapshot file as JavaScript and writing the strings back\n        // when other snapshots have changed loses the proper escaping for some\n        // characters. Since we check every snapshot in every test, use the newly\n        // generated formatted string.\n        // Note that this is only relevant when a snapshot is added and the dirty\n        // flag is set.\n        this._snapshotData[key] = receivedSerialized;\n      }\n\n      // These are the conditions on when to write snapshots:\n      //  * There's no snapshot file in a non-CI environment.\n      //  * There is a snapshot file and we decided to update the snapshot.\n      //  * There is a snapshot file, but it doesn't have this snaphsot.\n      // These are the conditions on when not to write snapshots:\n      //  * The update flag is set to 'none'.\n      //  * There's no snapshot file or a file without this snapshot on a CI environment.\n      if (hasSnapshot && this._updateSnapshot === 'all' || (!hasSnapshot || !snapshotIsPersisted) && (this._updateSnapshot === 'new' || this._updateSnapshot === 'all')) {\n        if (this._updateSnapshot === 'all') {\n          if (!pass) {\n            if (hasSnapshot) {\n              this.updated++;\n            } else {\n              this.added++;\n            }\n            this._addSnapshot(key, receivedSerialized, {\n              error: error,\n              isInline: isInline\n            });\n          } else {\n            this.matched++;\n          }\n        } else {\n          this._addSnapshot(key, receivedSerialized, {\n            error: error,\n            isInline: isInline\n          });\n          this.added++;\n        }\n        return {\n          actual: '',\n          count: count,\n          expected: '',\n          key: key,\n          pass: true\n        };\n      } else {\n        if (!pass) {\n          this.unmatched++;\n          return {\n            actual: (0, _utils.unescape)(receivedSerialized),\n            count: count,\n            expected: expected ? (0, _utils.unescape)(expected) : null,\n            key: key,\n            pass: false\n          };\n        } else {\n          this.matched++;\n          return {\n            actual: '',\n            count: count,\n            expected: '',\n            key: key,\n            pass: true\n          };\n        }\n      }\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(testName, received, key) {\n      this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n      var count = Number(this._counters.get(testName));\n      if (!key) {\n        key = (0, _utils.testNameToKey)(testName, count);\n      }\n      this._uncheckedKeys.delete(key);\n      this.unmatched++;\n      return key;\n    }\n  }]);\n  return SnapshotState;\n}();\nexports.default = SnapshotState;\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */","map":null,"metadata":{},"sourceType":"script"}