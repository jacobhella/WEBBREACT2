{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = require('path'),\n  vm = require('vm'),\n  appendTransform = require('append-transform'),\n  originalCreateScript = vm.createScript,\n  originalRunInThisContext = vm.runInThisContext,\n  originalRunInContext = vm.runInContext;\nfunction transformFn(matcher, transformer, verbose) {\n  return function (code, filename) {\n    var shouldHook = typeof filename === 'string' && matcher(path.resolve(filename)),\n      transformed,\n      changed = false;\n    if (shouldHook) {\n      if (verbose) {\n        console.error('Module load hook: transform [' + filename + ']');\n      }\n      try {\n        transformed = transformer(code, filename);\n        changed = true;\n      } catch (ex) {\n        console.error('Transformation error for', filename, '; return original code');\n        console.error(ex.message || String(ex));\n        if (verbose) {\n          console.error(ex.stack);\n        }\n        transformed = code;\n      }\n    } else {\n      transformed = code;\n    }\n    return {\n      code: transformed,\n      changed: changed\n    };\n  };\n}\n/**\n * unloads the required caches, removing all files that would have matched\n * the supplied matcher.\n * @param {Function} matcher - the match function that accepts a file name and\n *  returns if that file should be unloaded from the cache.\n */\nfunction unloadRequireCache(matcher) {\n  /* istanbul ignore else: impossible to test */\n  if (matcher && typeof require !== 'undefined' && require && require.cache) {\n    Object.keys(require.cache).forEach(function (filename) {\n      if (matcher(filename)) {\n        delete require.cache[filename];\n      }\n    });\n  }\n}\n/**\n * hooks `require` to return transformed code to the node module loader.\n * Exceptions in the transform result in the original code being used instead.\n * @method hookRequire\n * @static\n * @param matcher {Function(filePath)} a function that is called with the absolute path to the file being\n *  `require`-d. Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the associated path of the file\n *  from where the code was loaded. Should return the transformed code.\n * @param options {Object} options Optional.\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n * @param {Function} [options.postLoadHook] a function that is called with the name of the file being\n *  required. This is called after the require is processed irrespective of whether it was transformed.\n * @returns {Function} a reset function that can be called to remove the hook\n */\nfunction hookRequire(matcher, transformer, options) {\n  options = options || {};\n  var extensions,\n    disable = false,\n    fn = transformFn(matcher, transformer, options.verbose),\n    postLoadHook = options.postLoadHook && typeof options.postLoadHook === 'function' ? options.postLoadHook : null;\n  extensions = options.extensions || ['.js'];\n  extensions.forEach(function (ext) {\n    appendTransform(function (code, filename) {\n      if (disable) {\n        return code;\n      }\n      var ret = fn(code, filename);\n      if (postLoadHook) {\n        postLoadHook(filename);\n      }\n      return ret.code;\n    }, ext);\n  });\n  return function () {\n    disable = true;\n  };\n}\n/**\n * hooks `vm.createScript` to return transformed code out of which a `Script` object will be created.\n * Exceptions in the transform result in the original code being used instead.\n * @method hookCreateScript\n * @static\n * @param matcher {Function(filePath)} a function that is called with the filename passed to `vm.createScript`\n *  Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the filename passed to\n *  `vm.createScript`. Should return the transformed code.\n * @param options {Object} options Optional.\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n */\nfunction hookCreateScript(matcher, transformer, opts) {\n  opts = opts || {};\n  var fn = transformFn(matcher, transformer, opts.verbose);\n  vm.createScript = function (code, file) {\n    var ret = fn(code, file);\n    return originalCreateScript(ret.code, file);\n  };\n}\n/**\n * unhooks vm.createScript, restoring it to its original state.\n * @method unhookCreateScript\n * @static\n */\nfunction unhookCreateScript() {\n  vm.createScript = originalCreateScript;\n}\n/**\n * hooks `vm.runInThisContext` to return transformed code.\n * @method hookRunInThisContext\n * @static\n * @param matcher {Function(filePath)} a function that is called with the filename passed to `vm.createScript`\n *  Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the filename passed to\n *  `vm.createScript`. Should return the transformed code.\n * @param opts {Object} [opts={}] options\n * @param {Boolean} [opts.verbose] write a line to standard error every time the transformer is called\n */\nfunction hookRunInThisContext(matcher, transformer, opts) {\n  opts = opts || {};\n  var fn = transformFn(matcher, transformer, opts.verbose);\n  vm.runInThisContext = function (code, file) {\n    var ret = fn(code, file);\n    return originalRunInThisContext(ret.code, file);\n  };\n}\n/**\n * unhooks vm.runInThisContext, restoring it to its original state.\n * @method unhookRunInThisContext\n * @static\n */\nfunction unhookRunInThisContext() {\n  vm.runInThisContext = originalRunInThisContext;\n}\n/**\n * hooks `vm.runInContext` to return transformed code.\n * @method hookRunInContext\n * @static\n * @param matcher {Function(filePath)} a function that is called with the filename passed to `vm.createScript`\n *  Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the filename passed to\n *  `vm.createScript`. Should return the transformed code.\n * @param opts {Object} [opts={}] options\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n */\nfunction hookRunInContext(matcher, transformer, opts) {\n  opts = opts || {};\n  var fn = transformFn(matcher, transformer, opts.verbose);\n  vm.runInContext = function (code, context, file) {\n    var ret = fn(code, file);\n    var coverageVariable = opts.coverageVariable || '__coverage__';\n    // Refer coverage variable in context to global coverage variable.\n    // So that coverage data will be written in global coverage variable for unit tests run in vm.runInContext.\n    // If all unit tests are run in vm.runInContext, no global coverage variable will be generated.\n    // Thus initialize a global coverage variable here.\n    if (!global[coverageVariable]) {\n      global[coverageVariable] = {};\n    }\n    context[coverageVariable] = global[coverageVariable];\n    return originalRunInContext(ret.code, context, file);\n  };\n}\n/**\n * unhooks vm.runInContext, restoring it to its original state.\n * @method unhookRunInContext\n * @static\n */\nfunction unhookRunInContext() {\n  vm.runInContext = originalRunInContext;\n}\n/**\n * istanbul-lib-hook provides mechanisms to transform code in the scope of `require`,\n * `vm.createScript`, `vm.runInThisContext` etc.\n *\n * This mechanism is general and relies on a user-supplied `matcher` function that\n * determines when transformations should be performed and a user-supplied `transformer`\n * function that performs the actual transform. Instrumenting code for coverage is\n * one specific example of useful hooking.\n *\n * Note that both the `matcher` and `transformer` must execute synchronously.\n *\n * @module Exports\n * @example\n * var hook = require('istanbul-lib-hook'),\n *     myMatcher = function (file) { return file.match(/foo/); },\n *     myTransformer = function (code, file) {\n *         return 'console.log(\"' + file + '\");' + code;\n *     };\n *\n * hook.hookRequire(myMatcher, myTransformer);\n * var foo = require('foo'); //will now print foo's module path to console\n */\nmodule.exports = {\n  hookRequire: hookRequire,\n  hookCreateScript: hookCreateScript,\n  unhookCreateScript: unhookCreateScript,\n  hookRunInThisContext: hookRunInThisContext,\n  unhookRunInThisContext: unhookRunInThisContext,\n  hookRunInContext: hookRunInContext,\n  unhookRunInContext: unhookRunInContext,\n  unloadRequireCache: unloadRequireCache\n};","map":null,"metadata":{},"sourceType":"script"}