{"ast":null,"code":"'use strict';\n\nvar argsert = require('./lib/argsert');\nvar fs = require('fs');\nvar Command = require('./lib/command');\nvar Completion = require('./lib/completion');\nvar Parser = require('yargs-parser');\nvar path = require('path');\nvar Usage = require('./lib/usage');\nvar Validation = require('./lib/validation');\nvar Y18n = require('y18n');\nvar objFilter = require('./lib/obj-filter');\nvar setBlocking = require('set-blocking');\nvar applyExtends = require('./lib/apply-extends');\nvar YError = require('./lib/yerror');\nexports = module.exports = Yargs;\nfunction Yargs(processArgs, cwd, parentRequire) {\n  processArgs = processArgs || []; // handle calling yargs().\n\n  var self = {};\n  var command = null;\n  var completion = null;\n  var groups = {};\n  var output = '';\n  var preservedGroups = {};\n  var usage = null;\n  var validation = null;\n  var y18n = Y18n({\n    directory: path.resolve(__dirname, './locales'),\n    updateFiles: false\n  });\n  if (!cwd) cwd = process.cwd();\n  self.$0 = process.argv.slice(0, 2).map(function (x, i) {\n    // ignore the node bin, specify this in your\n    // bin file with #!/usr/bin/env node\n    if (i === 0 && /\\b(node|iojs)(\\.exe)?$/.test(x)) return;\n    var b = rebase(cwd, x);\n    return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n  }).join(' ').trim();\n  if (process.env._ !== undefined && process.argv[1] === process.env._) {\n    self.$0 = process.env._.replace(\"\".concat(path.dirname(process.execPath), \"/\"), '');\n  }\n\n  // use context object to keep track of resets, subcommand execution, etc\n  // submodules should modify and check the state of context as necessary\n  var context = {\n    resets: -1,\n    commands: [],\n    fullCommands: [],\n    files: []\n  };\n  self.getContext = function () {\n    return context;\n  };\n\n  // puts yargs back into an initial state. any keys\n  // that have been set to \"global\" will not be reset\n  // by this action.\n  var options;\n  self.resetOptions = self.reset = function resetOptions(aliases) {\n    context.resets++;\n    aliases = aliases || {};\n    options = options || {};\n    // put yargs back into an initial state, this\n    // logic is used to build a nested command\n    // hierarchy.\n    var tmpOptions = {};\n    tmpOptions.local = options.local ? options.local : [];\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : [];\n\n    // if a key has been explicitly set as local,\n    // we should reset it before passing options to command.\n    var localLookup = {};\n    tmpOptions.local.forEach(function (l) {\n      localLookup[l] = true;\n      (aliases[l] || []).forEach(function (a) {\n        localLookup[a] = true;\n      });\n    });\n\n    // preserve all groups not set to local.\n    preservedGroups = Object.keys(groups).reduce(function (acc, groupName) {\n      var keys = groups[groupName].filter(function (key) {\n        return !(key in localLookup);\n      });\n      if (keys.length > 0) {\n        acc[groupName] = keys;\n      }\n      return acc;\n    }, {});\n    // groups can now be reset\n    groups = {};\n    var arrayOptions = ['array', 'boolean', 'string', 'skipValidation', 'count', 'normalize', 'number'];\n    var objectOptions = ['narg', 'key', 'alias', 'default', 'defaultDescription', 'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce'];\n    arrayOptions.forEach(function (k) {\n      tmpOptions[k] = (options[k] || []).filter(function (k) {\n        return !localLookup[k];\n      });\n    });\n    objectOptions.forEach(function (k) {\n      tmpOptions[k] = objFilter(options[k], function (k, v) {\n        return !localLookup[k];\n      });\n    });\n    tmpOptions.envPrefix = options.envPrefix;\n    options = tmpOptions;\n\n    // if this is the first time being executed, create\n    // instances of all our helpers -- otherwise just reset.\n    usage = usage ? usage.reset(localLookup) : Usage(self, y18n);\n    validation = validation ? validation.reset(localLookup) : Validation(self, usage, y18n);\n    command = command ? command.reset() : Command(self, usage, validation);\n    if (!completion) completion = Completion(self, usage, command);\n    completionCommand = null;\n    output = '';\n    exitError = null;\n    hasOutput = false;\n    self.parsed = false;\n    return self;\n  };\n  self.resetOptions();\n\n  // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n  var frozen;\n  function freeze() {\n    frozen = {};\n    frozen.options = options;\n    frozen.configObjects = options.configObjects.slice(0);\n    frozen.exitProcess = exitProcess;\n    frozen.groups = groups;\n    usage.freeze();\n    validation.freeze();\n    command.freeze();\n    frozen.strict = strict;\n    frozen.completionCommand = completionCommand;\n    frozen.output = output;\n    frozen.exitError = exitError;\n    frozen.hasOutput = hasOutput;\n    frozen.parsed = self.parsed;\n  }\n  function unfreeze() {\n    options = frozen.options;\n    options.configObjects = frozen.configObjects;\n    exitProcess = frozen.exitProcess;\n    groups = frozen.groups;\n    output = frozen.output;\n    exitError = frozen.exitError;\n    hasOutput = frozen.hasOutput;\n    self.parsed = frozen.parsed;\n    usage.unfreeze();\n    validation.unfreeze();\n    command.unfreeze();\n    strict = frozen.strict;\n    completionCommand = frozen.completionCommand;\n    parseFn = null;\n    parseContext = null;\n    frozen = undefined;\n  }\n  self.boolean = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('boolean', keys);\n    return self;\n  };\n  self.array = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('array', keys);\n    return self;\n  };\n  self.number = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('number', keys);\n    return self;\n  };\n  self.normalize = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('normalize', keys);\n    return self;\n  };\n  self.count = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('count', keys);\n    return self;\n  };\n  self.string = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('string', keys);\n    return self;\n  };\n  self.requiresArg = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintObject(self.nargs, false, 'narg', keys, 1);\n    return self;\n  };\n  self.skipValidation = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('skipValidation', keys);\n    return self;\n  };\n  function populateParserHintArray(type, keys, value) {\n    keys = [].concat(keys);\n    keys.forEach(function (key) {\n      options[type].push(key);\n    });\n  }\n  self.nargs = function (key, value) {\n    argsert('<string|object|array> [number]', [key, value], arguments.length);\n    populateParserHintObject(self.nargs, false, 'narg', key, value);\n    return self;\n  };\n  self.choices = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintObject(self.choices, true, 'choices', key, value);\n    return self;\n  };\n  self.alias = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintObject(self.alias, true, 'alias', key, value);\n    return self;\n  };\n\n  // TODO: actually deprecate self.defaults.\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n    if (defaultDescription) options.defaultDescription[key] = defaultDescription;\n    if (typeof value === 'function') {\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value);\n      value = value.call();\n    }\n    populateParserHintObject(self.default, false, 'default', key, value);\n    return self;\n  };\n  self.describe = function (key, desc) {\n    argsert('<object|string|array> [string]', [key, desc], arguments.length);\n    populateParserHintObject(self.describe, false, 'key', key, true);\n    usage.describe(key, desc);\n    return self;\n  };\n  self.demandOption = function (keys, msg) {\n    argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n    populateParserHintObject(self.demandOption, false, 'demandedOptions', keys, msg);\n    return self;\n  };\n  self.coerce = function (keys, value) {\n    argsert('<object|string|array> [function]', [keys, value], arguments.length);\n    populateParserHintObject(self.coerce, false, 'coerce', keys, value);\n    return self;\n  };\n  function populateParserHintObject(builder, isArray, type, key, value) {\n    if (Array.isArray(key)) {\n      // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n      var temp = {};\n      key.forEach(function (k) {\n        temp[k] = value;\n      });\n      builder(temp);\n    } else if (typeof key === 'object') {\n      // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n      Object.keys(key).forEach(function (k) {\n        builder(k, key[k]);\n      });\n    } else {\n      // a single key value pair 'x', parse() {}\n      if (isArray) {\n        options[type][key] = (options[type][key] || []).concat(value);\n      } else {\n        options[type][key] = value;\n      }\n    }\n  }\n  function deleteFromParserHintObject(optionKey) {\n    // delete from all parsing hints:\n    // boolean, array, key, alias, etc.\n    Object.keys(options).forEach(function (hintKey) {\n      var hint = options[hintKey];\n      if (Array.isArray(hint)) {\n        if (~hint.indexOf(optionKey)) hint.splice(hint.indexOf(optionKey), 1);\n      } else if (typeof hint === 'object') {\n        delete hint[optionKey];\n      }\n    });\n    // now delete the description from usage.js.\n    delete usage.getDescriptions()[optionKey];\n  }\n  self.config = function config(key, msg, parseFn) {\n    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\n    // allow a config object to be provided directly.\n    if (typeof key === 'object') {\n      key = applyExtends(key, cwd);\n      options.configObjects = (options.configObjects || []).concat(key);\n      return self;\n    }\n\n    // allow for a custom parsing function.\n    if (typeof msg === 'function') {\n      parseFn = msg;\n      msg = null;\n    }\n    key = key || 'config';\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n    (Array.isArray(key) ? key : [key]).forEach(function (k) {\n      options.config[k] = parseFn || true;\n    });\n    return self;\n  };\n  self.example = function (cmd, description) {\n    argsert('<string> [string]', [cmd, description], arguments.length);\n    usage.example(cmd, description);\n    return self;\n  };\n  self.command = function (cmd, description, builder, handler, middlewares) {\n    argsert('<string|array|object> [string|boolean] [function|object] [function] [array]', [cmd, description, builder, handler, middlewares], arguments.length);\n    command.addHandler(cmd, description, builder, handler, middlewares);\n    return self;\n  };\n  self.commandDir = function (dir, opts) {\n    argsert('<string> [object]', [dir, opts], arguments.length);\n    var req = parentRequire || require;\n    command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts);\n    return self;\n  };\n\n  // TODO: deprecate self.demand in favor of\n  // .demandCommand() .demandOption().\n  self.demand = self.required = self.require = function demand(keys, max, msg) {\n    // you can optionally provide a 'max' key,\n    // which will raise an exception if too many '_'\n    // options are provided.\n    if (Array.isArray(max)) {\n      max.forEach(function (key) {\n        self.demandOption(key, msg);\n      });\n      max = Infinity;\n    } else if (typeof max !== 'number') {\n      msg = max;\n      max = Infinity;\n    }\n    if (typeof keys === 'number') {\n      self.demandCommand(keys, max, msg, msg);\n    } else if (Array.isArray(keys)) {\n      keys.forEach(function (key) {\n        self.demandOption(key, msg);\n      });\n    } else {\n      if (typeof msg === 'string') {\n        self.demandOption(keys, msg);\n      } else if (msg === true || typeof msg === 'undefined') {\n        self.demandOption(keys);\n      }\n    }\n    return self;\n  };\n  self.demandCommand = function demandCommand(min, max, minMsg, maxMsg) {\n    argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n    if (typeof min === 'undefined') min = 1;\n    if (typeof max !== 'number') {\n      minMsg = max;\n      max = Infinity;\n    }\n    self.global('_', false);\n    options.demandedCommands._ = {\n      min: min,\n      max: max,\n      minMsg: minMsg,\n      maxMsg: maxMsg\n    };\n    return self;\n  };\n  self.getDemandedOptions = function () {\n    argsert([], 0);\n    return options.demandedOptions;\n  };\n  self.getDemandedCommands = function () {\n    argsert([], 0);\n    return options.demandedCommands;\n  };\n  self.implies = function (key, value) {\n    argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n    validation.implies(key, value);\n    return self;\n  };\n  self.conflicts = function (key1, key2) {\n    argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n    validation.conflicts(key1, key2);\n    return self;\n  };\n  self.usage = function (msg, description, builder, handler) {\n    argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n    if (description !== undefined) {\n      // .usage() can be used as an alias for defining\n      // a default command.\n      if ((msg || '').match(/^\\$0( |$)/)) {\n        return self.command(msg, description, builder, handler);\n      } else {\n        throw new YError('.usage() description must start with $0 if being used as alias for .command()');\n      }\n    } else {\n      usage.usage(msg);\n      return self;\n    }\n  };\n  self.epilogue = self.epilog = function (msg) {\n    argsert('<string>', [msg], arguments.length);\n    usage.epilog(msg);\n    return self;\n  };\n  self.fail = function (f) {\n    argsert('<function>', [f], arguments.length);\n    usage.failFn(f);\n    return self;\n  };\n  self.check = function (f, _global) {\n    argsert('<function> [boolean]', [f, _global], arguments.length);\n    validation.check(f, _global !== false);\n    return self;\n  };\n  self.global = function global(globals, global) {\n    argsert('<string|array> [boolean]', [globals, global], arguments.length);\n    globals = [].concat(globals);\n    if (global !== false) {\n      options.local = options.local.filter(function (l) {\n        return globals.indexOf(l) === -1;\n      });\n    } else {\n      globals.forEach(function (g) {\n        if (options.local.indexOf(g) === -1) options.local.push(g);\n      });\n    }\n    return self;\n  };\n  self.pkgConf = function pkgConf(key, rootPath) {\n    argsert('<string> [string]', [key, rootPath], arguments.length);\n    var conf = null;\n    // prefer cwd to require-main-filename in this method\n    // since we're looking for e.g. \"nyc\" config in nyc consumer\n    // rather than \"yargs\" config in nyc (where nyc is the main filename)\n    var obj = pkgUp(rootPath || cwd);\n\n    // If an object exists in the key, add it to options.configObjects\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = applyExtends(obj[key], rootPath || cwd);\n      options.configObjects = (options.configObjects || []).concat(conf);\n    }\n    return self;\n  };\n  var pkgs = {};\n  function pkgUp(rootPath) {\n    var npath = rootPath || '*';\n    if (pkgs[npath]) return pkgs[npath];\n    var findUp = require('find-up');\n    var obj = {};\n    try {\n      var startDir = rootPath || require('require-main-filename')(parentRequire || require);\n\n      // When called in an environment that lacks require.main.filename, such as a jest test runner,\n      // startDir is already process.cwd(), and should not be shortened.\n      // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.\n      if (!rootPath && path.extname(startDir)) {\n        startDir = path.dirname(startDir);\n      }\n      var pkgJsonPath = findUp.sync('package.json', {\n        cwd: startDir\n      });\n      obj = JSON.parse(fs.readFileSync(pkgJsonPath));\n    } catch (noop) {}\n    pkgs[npath] = obj || {};\n    return pkgs[npath];\n  }\n  var parseFn = null;\n  var parseContext = null;\n  self.parse = function parse(args, shortCircuit, _parseFn) {\n    argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n    if (typeof args === 'undefined') args = processArgs;\n\n    // a context object can optionally be provided, this allows\n    // additional information to be passed to a command handler.\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit;\n      shortCircuit = _parseFn;\n    }\n\n    // by providing a function as a second argument to\n    // parse you can capture output that would otherwise\n    // default to printing to stdout/stderr.\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit;\n      shortCircuit = null;\n    }\n    // completion short-circuits the parsing process,\n    // skipping validation, etc.\n    if (!shortCircuit) processArgs = args;\n    freeze();\n    if (parseFn) exitProcess = false;\n    var parsed = self._parseArgs(args, shortCircuit);\n    if (parseFn) parseFn(exitError, parsed, output);\n    unfreeze();\n    return parsed;\n  };\n  self._getParseContext = function () {\n    return parseContext || {};\n  };\n  self._hasParseCallback = function () {\n    return !!parseFn;\n  };\n  self.option = self.options = function option(key, opt) {\n    argsert('<string|object> [object]', [key, opt], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.options(k, key[k]);\n      });\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {};\n      }\n      options.key[key] = true; // track manually set keys.\n\n      if (opt.alias) self.alias(key, opt.alias);\n      var demand = opt.demand || opt.required || opt.require;\n\n      // deprecated, use 'demandOption' instead\n      if (demand) {\n        self.demand(key, demand);\n      }\n      if (opt.demandOption) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n      }\n      if ('conflicts' in opt) {\n        self.conflicts(key, opt.conflicts);\n      }\n      if ('default' in opt) {\n        self.default(key, opt.default);\n      }\n      if ('implies' in opt) {\n        self.implies(key, opt.implies);\n      }\n      if ('nargs' in opt) {\n        self.nargs(key, opt.nargs);\n      }\n      if (opt.config) {\n        self.config(key, opt.configParser);\n      }\n      if (opt.normalize) {\n        self.normalize(key);\n      }\n      if ('choices' in opt) {\n        self.choices(key, opt.choices);\n      }\n      if ('coerce' in opt) {\n        self.coerce(key, opt.coerce);\n      }\n      if ('group' in opt) {\n        self.group(key, opt.group);\n      }\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key);\n        if (opt.alias) self.boolean(opt.alias);\n      }\n      if (opt.array || opt.type === 'array') {\n        self.array(key);\n        if (opt.alias) self.array(opt.alias);\n      }\n      if (opt.number || opt.type === 'number') {\n        self.number(key);\n        if (opt.alias) self.number(opt.alias);\n      }\n      if (opt.string || opt.type === 'string') {\n        self.string(key);\n        if (opt.alias) self.string(opt.alias);\n      }\n      if (opt.count || opt.type === 'count') {\n        self.count(key);\n      }\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global);\n      }\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription;\n      }\n      if (opt.skipValidation) {\n        self.skipValidation(key);\n      }\n      var desc = opt.describe || opt.description || opt.desc;\n      if (!opt.hidden) {\n        self.describe(key, desc);\n      }\n      if (opt.requiresArg) {\n        self.requiresArg(key);\n      }\n    }\n    return self;\n  };\n  self.getOptions = function () {\n    return options;\n  };\n  self.positional = function (key, opts) {\n    argsert('<string> <object>', [key, opts], arguments.length);\n    if (context.resets === 0) {\n      throw new YError(\".positional() can only be called in a command's builder function\");\n    }\n\n    // .positional() only supports a subset of the configuration\n    // options availble to .option().\n    var supportedOpts = ['default', 'implies', 'normalize', 'choices', 'conflicts', 'coerce', 'type', 'describe', 'desc', 'description', 'alias'];\n    opts = objFilter(opts, function (k, v) {\n      var accept = supportedOpts.indexOf(k) !== -1;\n      // type can be one of string|number|boolean.\n      if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1) accept = false;\n      return accept;\n    });\n\n    // copy over any settings that can be inferred from the command string.\n    var fullCommand = context.fullCommands[context.fullCommands.length - 1];\n    var parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\n      array: [],\n      alias: {},\n      default: {},\n      demand: {}\n    };\n    Object.keys(parseOptions).forEach(function (pk) {\n      if (Array.isArray(parseOptions[pk])) {\n        if (parseOptions[pk].indexOf(key) !== -1) opts[pk] = true;\n      } else {\n        if (parseOptions[pk][key] && !(pk in opts)) opts[pk] = parseOptions[pk][key];\n      }\n    });\n    self.group(key, usage.getPositionalGroupName());\n    return self.option(key, opts);\n  };\n  self.group = function group(opts, groupName) {\n    argsert('<string|array> <string>', [opts, groupName], arguments.length);\n    var existing = preservedGroups[groupName] || groups[groupName];\n    if (preservedGroups[groupName]) {\n      // we now only need to track this group name in groups.\n      delete preservedGroups[groupName];\n    }\n    var seen = {};\n    groups[groupName] = (existing || []).concat(opts).filter(function (key) {\n      if (seen[key]) return false;\n      return seen[key] = true;\n    });\n    return self;\n  };\n  // combine explicit and preserved groups. explicit groups should be first\n  self.getGroups = function () {\n    return Object.assign({}, groups, preservedGroups);\n  };\n\n  // as long as options.envPrefix is not undefined,\n  // parser will apply env vars matching prefix to argv\n  self.env = function (prefix) {\n    argsert('[string|boolean]', [prefix], arguments.length);\n    if (prefix === false) options.envPrefix = undefined;else options.envPrefix = prefix || '';\n    return self;\n  };\n  self.wrap = function (cols) {\n    argsert('<number|null|undefined>', [cols], arguments.length);\n    usage.wrap(cols);\n    return self;\n  };\n  var strict = false;\n  self.strict = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strict = enabled !== false;\n    return self;\n  };\n  self.getStrict = function () {\n    return strict;\n  };\n  self.showHelp = function (level) {\n    argsert('[string|function]', [level], arguments.length);\n    if (!self.parsed) self._parseArgs(processArgs); // run parser, if it has not already been executed.\n    if (command.hasDefaultCommand()) {\n      context.resets++; // override the restriction on top-level positoinals.\n      command.runDefaultBuilderOn(self, true);\n    }\n    usage.showHelp(level);\n    return self;\n  };\n  var versionOpt = null;\n  self.version = function version(opt, msg, ver) {\n    var defaultVersionOpt = 'version';\n    argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\n\n    // nuke the key previously configured\n    // to return version #.\n    if (versionOpt) {\n      deleteFromParserHintObject(versionOpt);\n      usage.version(undefined);\n      versionOpt = null;\n    }\n    if (arguments.length === 0) {\n      ver = guessVersion();\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 1) {\n      if (opt === false) {\n        // disable default 'version' key.\n        return self;\n      }\n      ver = opt;\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 2) {\n      ver = msg;\n      msg = null;\n    }\n    versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n    msg = msg || usage.deferY18nLookup('Show version number');\n    usage.version(ver || undefined);\n    self.boolean(versionOpt);\n    self.describe(versionOpt, msg);\n    return self;\n  };\n  function guessVersion() {\n    var obj = pkgUp();\n    return obj.version || 'unknown';\n  }\n  var helpOpt = null;\n  self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n    var defaultHelpOpt = 'help';\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n\n    // nuke the key previously configured\n    // to return help.\n    if (helpOpt) {\n      deleteFromParserHintObject(helpOpt);\n      helpOpt = null;\n    }\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    }\n\n    // use arguments, fallback to defaults for opt and msg\n    helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n    self.boolean(helpOpt);\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n    return self;\n  };\n  self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n    argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n    usage.showHelpOnFail(enabled, message);\n    return self;\n  };\n  var exitProcess = true;\n  self.exitProcess = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    if (typeof enabled !== 'boolean') {\n      enabled = true;\n    }\n    exitProcess = enabled;\n    return self;\n  };\n  self.getExitProcess = function () {\n    return exitProcess;\n  };\n  var completionCommand = null;\n  self.completion = function (cmd, desc, fn) {\n    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\n\n    // a function to execute when generating\n    // completions can be provided as the second\n    // or third argument to completion.\n    if (typeof desc === 'function') {\n      fn = desc;\n      desc = null;\n    }\n\n    // register the completion command.\n    completionCommand = cmd || 'completion';\n    if (!desc && desc !== false) {\n      desc = 'generate bash completion script';\n    }\n    self.command(completionCommand, desc);\n\n    // a function can be provided\n    if (fn) completion.registerFunction(fn);\n    return self;\n  };\n  self.showCompletionScript = function ($0) {\n    argsert('[string]', [$0], arguments.length);\n    $0 = $0 || self.$0;\n    _logger.log(completion.generateCompletionScript($0, completionCommand));\n    return self;\n  };\n  self.getCompletion = function (args, done) {\n    argsert('<array> <function>', [args, done], arguments.length);\n    completion.getCompletion(args, done);\n  };\n  self.locale = function (locale) {\n    argsert('[string]', [locale], arguments.length);\n    if (arguments.length === 0) {\n      guessLocale();\n      return y18n.getLocale();\n    }\n    detectLocale = false;\n    y18n.setLocale(locale);\n    return self;\n  };\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert('<object>', [obj], arguments.length);\n    detectLocale = false;\n    y18n.updateLocale(obj);\n    return self;\n  };\n  var detectLocale = true;\n  self.detectLocale = function (detect) {\n    argsert('<boolean>', [detect], arguments.length);\n    detectLocale = detect;\n    return self;\n  };\n  self.getDetectLocale = function () {\n    return detectLocale;\n  };\n  var hasOutput = false;\n  var exitError = null;\n  // maybe exit, always capture\n  // context about why we wanted to exit.\n  self.exit = function (code, err) {\n    hasOutput = true;\n    exitError = err;\n    if (exitProcess) process.exit(code);\n  };\n\n  // we use a custom logger that buffers output,\n  // so that we can print to non-CLIs, e.g., chat-bots.\n  var _logger = {\n    log: function log() {\n      var args = [];\n      for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n      if (!self._hasParseCallback()) console.log.apply(console, args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    },\n    error: function error() {\n      var args = [];\n      for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n      if (!self._hasParseCallback()) console.error.apply(console, args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    }\n  };\n  self._getLoggerInstance = function () {\n    return _logger;\n  };\n  // has yargs output an error our help\n  // message in the current execution context.\n  self._hasOutput = function () {\n    return hasOutput;\n  };\n  self._setHasOutput = function () {\n    hasOutput = true;\n  };\n  var recommendCommands;\n  self.recommendCommands = function (recommend) {\n    argsert('[boolean]', [recommend], arguments.length);\n    recommendCommands = typeof recommend === 'boolean' ? recommend : true;\n    return self;\n  };\n  self.getUsageInstance = function () {\n    return usage;\n  };\n  self.getValidationInstance = function () {\n    return validation;\n  };\n  self.getCommandInstance = function () {\n    return command;\n  };\n  self.terminalWidth = function () {\n    argsert([], 0);\n    return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null;\n  };\n  Object.defineProperty(self, 'argv', {\n    get: function get() {\n      return self._parseArgs(processArgs);\n    },\n    enumerable: true\n  });\n  self._parseArgs = function parseArgs(args, shortCircuit, _skipValidation, commandIndex) {\n    var skipValidation = !!_skipValidation;\n    args = args || processArgs;\n    options.__ = y18n.__;\n    options.configuration = pkgUp()['yargs'] || {};\n    var parsed = Parser.detailed(args, options);\n    var argv = parsed.argv;\n    if (parseContext) argv = Object.assign({}, argv, parseContext);\n    var aliases = parsed.aliases;\n    argv.$0 = self.$0;\n    self.parsed = parsed;\n    try {\n      guessLocale(); // guess locale lazily, so that it can be turned off in chain.\n\n      // while building up the argv object, there\n      // are two passes through the parser. If completion\n      // is being performed short-circuit on the first pass.\n      if (shortCircuit) {\n        return argv;\n      }\n\n      // if there's a handler associated with a\n      // command defer processing to it.\n      if (helpOpt) {\n        // consider any multi-char helpOpt alias as a valid help command\n        // unless all helpOpt aliases are single-char\n        // note that parsed.aliases is a normalized bidirectional map :)\n        var helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter(function (k) {\n          return k.length > 1;\n        });\n        // check if help should trigger and strip it from _.\n        if (~helpCmds.indexOf(argv._[argv._.length - 1])) {\n          argv._.pop();\n          argv[helpOpt] = true;\n        }\n      }\n      var handlerKeys = command.getCommands();\n      var skipDefaultCommand = argv[helpOpt] && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n      if (argv._.length) {\n        if (handlerKeys.length) {\n          var firstUnknownCommand;\n          for (var i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {\n            cmd = String(argv._[i]);\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              setPlaceholderKeys(argv);\n              // commands are executed using a recursive algorithm that executes\n              // the deepest command first; we keep track of the position in the\n              // argv._ array that is currently being executed.\n              return command.runCommand(cmd, self, parsed, i + 1);\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd;\n              break;\n            }\n          }\n\n          // run the default command, if defined\n          if (command.hasDefaultCommand() && !skipDefaultCommand) {\n            setPlaceholderKeys(argv);\n            return command.runCommand(null, self, parsed);\n          }\n\n          // recommend a command if recommendCommands() has\n          // been enabled, and no commands were found to execute\n          if (recommendCommands && firstUnknownCommand && !argv[helpOpt]) {\n            validation.recommendCommands(firstUnknownCommand, handlerKeys);\n          }\n        }\n\n        // generate a completion script for adding to ~/.bashrc.\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {\n          if (exitProcess) setBlocking(true);\n          self.showCompletionScript();\n          self.exit(0);\n        }\n      } else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n        setPlaceholderKeys(argv);\n        return command.runCommand(null, self, parsed);\n      }\n\n      // we must run completions first, a user might\n      // want to complete the --help or --version option.\n      if (completion.completionKey in argv) {\n        if (exitProcess) setBlocking(true);\n\n        // we allow for asynchronous completions,\n        // e.g., loading in a list of commands from an API.\n        var completionArgs = args.slice(args.indexOf(\"--\".concat(completion.completionKey)) + 1);\n        completion.getCompletion(completionArgs, function (completions) {\n          ;\n          (completions || []).forEach(function (completion) {\n            _logger.log(completion);\n          });\n          self.exit(0);\n        });\n        return setPlaceholderKeys(argv);\n      }\n\n      // Handle 'help' and 'version' options\n      // if we haven't already output help!\n      if (!hasOutput) {\n        Object.keys(argv).forEach(function (key) {\n          if (key === helpOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            self.showHelp('log');\n            self.exit(0);\n          } else if (key === versionOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            usage.showVersion();\n            self.exit(0);\n          }\n        });\n      }\n\n      // Check if any of the options to skip validation were provided\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(function (key) {\n          return options.skipValidation.indexOf(key) >= 0 && argv[key] === true;\n        });\n      }\n\n      // If the help or version options where used and exitProcess is false,\n      // or if explicitly skipped, we won't run validations.\n      if (!skipValidation) {\n        if (parsed.error) throw new YError(parsed.error.message);\n\n        // if we're executed via bash completion, don't\n        // bother with validation.\n        if (!argv[completion.completionKey]) {\n          self._runValidation(argv, aliases, {}, parsed.error);\n        }\n      }\n    } catch (err) {\n      if (err instanceof YError) usage.fail(err.message, err);else throw err;\n    }\n    return setPlaceholderKeys(argv);\n  };\n  self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors) {\n    if (parseErrors) throw new YError(parseErrors.message);\n    validation.nonOptionCount(argv);\n    validation.requiredArguments(argv);\n    if (strict) validation.unknownArguments(argv, aliases, positionalMap);\n    validation.customChecks(argv, aliases);\n    validation.limitedChoices(argv);\n    validation.implications(argv);\n    validation.conflicting(argv);\n  };\n  function guessLocale() {\n    if (!detectLocale) return;\n    try {\n      var osLocale = require('os-locale');\n      self.locale(osLocale.sync({\n        spawn: false\n      }));\n    } catch (err) {\n      // if we explode looking up locale just noop\n      // we'll keep using the default language 'en'.\n    }\n  }\n  function setPlaceholderKeys(argv) {\n    Object.keys(options.key).forEach(function (key) {\n      // don't set placeholder keys for dot\n      // notation options 'foo.bar'.\n      if (~key.indexOf('.')) return;\n      if (typeof argv[key] === 'undefined') argv[key] = undefined;\n    });\n    return argv;\n  }\n\n  // an app should almost always have --version and --help,\n  // if you *really* want to disable this use .help(false)/.version(false).\n  self.help();\n  self.version();\n  return self;\n}\n\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nexports.rebase = rebase;\nfunction rebase(base, dir) {\n  return path.relative(base, dir);\n}","map":null,"metadata":{},"sourceType":"script"}