{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { decodedMappings, traceSegment, TraceMap } from '@jridgewell/trace-mapping';\nimport { GenMapping, addSegment, setSourceContent, decodedMap, encodedMap } from '@jridgewell/gen-mapping';\nvar SOURCELESS_MAPPING = {\n  source: null,\n  column: null,\n  line: null,\n  name: null,\n  content: null\n};\nvar EMPTY_SOURCES = [];\nfunction Source(map, sources, source, content) {\n  return {\n    map: map,\n    sources: sources,\n    source: source,\n    content: content\n  };\n}\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\nfunction MapSource(map, sources) {\n  return Source(map, sources, '', null);\n}\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\nfunction OriginalSource(source, content) {\n  return Source(null, EMPTY_SOURCES, source, content);\n}\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\nfunction traceMappings(tree) {\n  var gen = new GenMapping({\n    file: tree.map.file\n  });\n  var rootSources = tree.sources,\n    map = tree.map;\n  var rootNames = map.names;\n  var rootMappings = decodedMappings(map);\n  for (var i = 0; i < rootMappings.length; i++) {\n    var segments = rootMappings[i];\n    var lastSource = null;\n    var lastSourceLine = null;\n    var lastSourceColumn = null;\n    for (var j = 0; j < segments.length; j++) {\n      var segment = segments[j];\n      var genCol = segment[0];\n      var traced = SOURCELESS_MAPPING;\n      // 1-length segments only move the current generated column, there's no source information\n      // to gather from it.\n      if (segment.length !== 1) {\n        var _source = rootSources[segment[1]];\n        traced = originalPositionFor(_source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n        // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n        // respective segment into an original source.\n        if (traced == null) continue;\n      }\n      // So we traced a segment down into its original source file. Now push a\n      // new segment pointing to this location.\n      var _traced = traced,\n        column = _traced.column,\n        line = _traced.line,\n        name = _traced.name,\n        content = _traced.content,\n        source = _traced.source;\n      if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n        continue;\n      }\n      lastSourceLine = line;\n      lastSourceColumn = column;\n      lastSource = source;\n      // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n      addSegment(gen, i, genCol, source, line, column, name);\n      if (content != null) setSourceContent(gen, source, content);\n    }\n  }\n  return gen;\n}\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\nfunction originalPositionFor(source, line, column, name) {\n  if (!source.map) {\n    return {\n      column: column,\n      line: line,\n      name: name,\n      source: source.source,\n      content: source.content\n    };\n  }\n  var segment = traceSegment(source.map, line, column);\n  // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n  if (segment == null) return null;\n  // 1-length segments only move the current generated column, there's no source information\n  // to gather from it.\n  if (segment.length === 1) return SOURCELESS_MAPPING;\n  return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n}\nfunction asArray(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\nfunction buildSourceMapTree(input, loader) {\n  var maps = asArray(input).map(function (m) {\n    return new TraceMap(m, '');\n  });\n  var map = maps.pop();\n  for (var i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(\"Transformation map \".concat(i, \" must have exactly one source file.\\n\") + 'Did you specify these with the most recent transformation maps first?');\n    }\n  }\n  var tree = build(map, loader, '', 0);\n  for (var _i = maps.length - 1; _i >= 0; _i--) {\n    tree = MapSource(maps[_i], [tree]);\n  }\n  return tree;\n}\nfunction build(map, loader, importer, importerDepth) {\n  var resolvedSources = map.resolvedSources,\n    sourcesContent = map.sourcesContent;\n  var depth = importerDepth + 1;\n  var children = resolvedSources.map(function (sourceFile, i) {\n    // The loading context gives the loader more information about why this file is being loaded\n    // (eg, from which importer). It also allows the loader to override the location of the loaded\n    // sourcemap/original source, or to override the content in the sourcesContent field if it's\n    // an unmodified source file.\n    var ctx = {\n      importer: importer,\n      depth: depth,\n      source: sourceFile || '',\n      content: undefined\n    };\n    // Use the provided loader callback to retrieve the file's sourcemap.\n    // TODO: We should eventually support async loading of sourcemap files.\n    var sourceMap = loader(ctx.source, ctx);\n    var source = ctx.source,\n      content = ctx.content; // If there is a sourcemap, then we need to recurse into it to load its source files.\n    if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth);\n    // Else, it's an an unmodified source file.\n    // The contents of this unmodified source file can be overridden via the loader context,\n    // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n    // the importing sourcemap's `sourcesContent` field.\n    var sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n    return OriginalSource(source, sourceContent);\n  });\n  return MapSource(map, children);\n}\n\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\nvar SourceMap = /*#__PURE__*/function () {\n  function SourceMap(map, options) {\n    _classCallCheck(this, SourceMap);\n    var out = options.decodedMappings ? decodedMap(map) : encodedMap(map);\n    this.version = out.version; // SourceMap spec says this should be first.\n    this.file = out.file;\n    this.mappings = out.mappings;\n    this.names = out.names;\n    this.sourceRoot = out.sourceRoot;\n    this.sources = out.sources;\n    if (!options.excludeContent) {\n      this.sourcesContent = out.sourcesContent;\n    }\n  }\n  _createClass(SourceMap, [{\n    key: \"toString\",\n    value: function toString() {\n      return JSON.stringify(this);\n    }\n  }]);\n  return SourceMap;\n}();\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\nfunction remapping(input, loader, options) {\n  var opts = typeof options === 'object' ? options : {\n    excludeContent: !!options,\n    decodedMappings: false\n  };\n  var tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\nexport { remapping as default };","map":null,"metadata":{},"sourceType":"module"}