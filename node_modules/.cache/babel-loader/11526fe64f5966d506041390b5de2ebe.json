{"ast":null,"code":"'use strict';\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar watchman = require('fb-watchman');\nvar captureExit = require('capture-exit');\nfunction values(obj) {\n  return Object.keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n\n/**\n * Constants\n */\n\n/**\n * Singleton that provides a public API for a connection to a watchman instance for 'sane'.\n * It tries to abstract/remove as much of the boilerplate processing as necessary\n * from WatchmanWatchers that use it. In particular, they have no idea whether\n * we're using 'watch-project' or 'watch', what the 'project root' is when\n * we internally use watch-project, whether a connection has been lost\n * and reestablished, etc. Also switched to doing things with promises and known-name\n * methods in WatchmanWatcher, so as much information as possible can be kept in\n * the WatchmanClient, ultimately making this the only object listening directly\n * to watchman.Client, then forwarding appropriately (via the known-name methods) to\n * the relevant WatchmanWatcher(s).\n *\n * Note: WatchmanWatcher also added a 'watchmanPath' option for use with the sane CLI.\n * Because of that, we actually need a map of watchman binary path to WatchmanClient instance.\n * That is set up in getInstance(). Once the WatchmanWatcher has a given client, it doesn't\n * change.\n *\n * @class WatchmanClient\n * @param String watchmanBinaryPath\n * @public\n */\n\nfunction WatchmanClient(watchmanBinaryPath) {\n  var _this = this;\n  captureExit.captureExit();\n\n  // define/clear some local state. The properties will be initialized\n  // in _handleClientAndCheck(). This is also called again in _onEnd when\n  // trying to reestablish connection to watchman.\n  this._clearLocalVars();\n  this._watchmanBinaryPath = watchmanBinaryPath;\n  this._backoffTimes = this._setupBackoffTimes();\n  this._clientListeners = null; // direct listeners from here to watchman.Client.\n\n  // Define a handler for if somehow the Node process gets interrupted. We need to\n  // close down the watchman.Client, if we have one.\n  captureExit.onExit(function () {\n    _this._clearLocalVars();\n  });\n}\n\n// Define 'wildmatch' property, which must be available when we call the\n// WatchmanWatcher.createOptions() method.\nObject.defineProperty(WatchmanClient.prototype, 'wildmatch', {\n  get: function get() {\n    return this._wildmatch;\n  }\n});\n\n/**\n * Called from WatchmanWatcher (or WatchmanClient during reconnect) to create\n * a watcherInfo entry in our _watcherMap and issue a 'subscribe' to the\n * watchman.Client, to be handled here.\n */\nWatchmanClient.prototype.subscribe = function (watchmanWatcher, root) {\n  var _this2 = this;\n  var subscription;\n  var watcherInfo;\n  return this._setupClient().then(function () {\n    watcherInfo = _this2._createWatcherInfo(watchmanWatcher);\n    subscription = watcherInfo.subscription;\n    return _this2._watch(subscription, root);\n  }).then(function () {\n    return _this2._clock(subscription);\n  }).then(function () {\n    return _this2._subscribe(subscription);\n  });\n  // Note: callers are responsible for noting any subscription failure.\n};\n\n/**\n * Remove the information about a specific WatchmanWatcher.\n * Once done, if no watchers are left, clear the local vars,\n * which will end the connection to the watchman.Client, too.\n */\nWatchmanClient.prototype.closeWatcher = function (watchmanWatcher) {\n  var watcherInfos = values(this._watcherMap);\n  var numWatchers = watcherInfos.length;\n  if (numWatchers > 0) {\n    var watcherInfo;\n    var _iterator = _createForOfIteratorHelper(watcherInfos),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var info = _step.value;\n        if (info.watchmanWatcher === watchmanWatcher) {\n          watcherInfo = info;\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (watcherInfo) {\n      delete this._watcherMap[watcherInfo.subscription];\n      numWatchers--;\n      if (numWatchers === 0) {\n        this._clearLocalVars(); // nobody watching, so shut the watchman.Client down.\n      }\n    }\n  }\n};\n\n/**\n * Simple backoff-time iterator. next() returns times in ms.\n * When it's at the last value, it stays there until reset()\n * is called.\n */\nWatchmanClient.prototype._setupBackoffTimes = function () {\n  return {\n    _times: [0, 1000, 5000, 10000, 60000],\n    _next: 0,\n    next: function next() {\n      var val = this._times[this._next];\n      if (this._next < this._times.length - 1) {\n        this._next++;\n      }\n      return val;\n    },\n    reset: function reset() {\n      this._next = 0;\n    }\n  };\n};\n\n/**\n * Set up the connection to the watchman client. Return a promise\n * that is fulfilled when we have a client that has finished the\n * capabilityCheck.\n */\nWatchmanClient.prototype._setupClient = function () {\n  var _this3 = this;\n  if (!this._clientPromise) {\n    this._clientPromise = new Promise(function (resolve, reject) {\n      _this3._handleClientAndCheck(resolve, reject);\n    });\n  }\n  return this._clientPromise;\n};\n\n/**\n * Handle the process of creating a client and doing a capability check and\n * getting a valid response, then setting up local data based on that.\n *\n * This is split from _setupClient and _createClientAndCheck so it can\n * provide the backoff handling needed during attempts to reconnect.\n */\nWatchmanClient.prototype._handleClientAndCheck = function (resolve, reject) {\n  var _this4 = this;\n  this._createClientAndCheck().then(function (value) {\n    var resp = value.resp;\n    var client = value.client;\n    try {\n      _this4._wildmatch = resp.capabilities.wildmatch;\n      _this4._relative_root = resp.capabilities.relative_root;\n      _this4._client = client;\n      client.on('subscription', _this4._onSubscription.bind(_this4));\n      client.on('error', _this4._onError.bind(_this4));\n      client.on('end', _this4._onEnd.bind(_this4));\n      _this4._backoffTimes.reset();\n      resolve(_this4);\n    } catch (error) {\n      // somehow, even though we supposedly got a valid value back, it's\n      // malformed, or some other internal error occurred. Reject so\n      // the promise itself doesn't hang forever.\n      reject(error);\n    }\n  }, function () {\n    // create & capability check failed in any of several ways,\n    // do the retry with backoff.\n\n    // XXX May want to change this later to actually reject/terminate with\n    // an error in certain of the inner errors (e.g. when we\n    // can figure out the server is definitely not coming\n    // back, or something else is not recoverable by just waiting).\n    // Could also decide after N retries to just quit.\n\n    var backoffMillis = _this4._backoffTimes.next();\n\n    // XXX may want to fact we'll attempt reconnect in backoffMillis ms.\n    setTimeout(function () {\n      _this4._handleClientAndCheck(resolve, reject);\n    }, backoffMillis);\n  });\n};\n\n/**\n * Create a promise that will only be fulfilled when either\n * we correctly get capabilities back or we get an 'error' or 'end'\n * callback, indicating a problem. The caller _handleClientAndCheck\n * then deals with providing a retry and backoff mechanism.\n */\nWatchmanClient.prototype._createClientAndCheck = function () {\n  var _this5 = this;\n  return new Promise(function (resolve, reject) {\n    var client;\n    try {\n      client = new watchman.Client(_this5._watchmanBinaryPath ? {\n        watchmanBinaryPath: _this5._watchmanBinaryPath\n      } : {});\n    } catch (error) {\n      // if we're here, either the binary path is bad or something\n      // else really bad happened. The client doesn't even attempt\n      // to connect until we send it a command, though.\n      reject(error);\n      return;\n    }\n    client.on('error', function (error) {\n      client.removeAllListeners();\n      reject(error);\n    });\n    client.on('end', function () {\n      client.removeAllListeners();\n      reject(new Error('Disconnected during client capabilities check'));\n    });\n    client.capabilityCheck({\n      optional: ['wildmatch', 'relative_root']\n    }, function (error, resp) {\n      try {\n        client.removeAllListeners();\n        if (error) {\n          reject(error);\n        } else {\n          resolve({\n            resp: resp,\n            client: client\n          });\n        }\n      } catch (err) {\n        // In case we get something weird in the block using 'resp'.\n        // XXX We could also just remove the try/catch if we believe\n        // the resp stuff should always work, but just in case...\n        reject(err);\n      }\n    });\n  });\n};\n\n/**\n * Clear out local state at the beginning and if we end up\n * getting disconnected and try to reconnect.\n */\nWatchmanClient.prototype._clearLocalVars = function () {\n  if (this._client) {\n    this._client.removeAllListeners();\n    this._client.end();\n  }\n  this._client = null;\n  this._clientPromise = null;\n  this._wildmatch = false;\n  this._relative_root = false;\n  this._subscriptionId = 1;\n  this._watcherMap = Object.create(null);\n\n  // Note that we do not clear _clientListeners or _watchmanBinaryPath.\n};\n\nWatchmanClient.prototype._genSubscription = function () {\n  var val = 'sane_' + this._subscriptionId++;\n  return val;\n};\n\n/**\n * Create a new watcherInfo entry for the given watchmanWatcher and\n * initialize it.\n */\nWatchmanClient.prototype._createWatcherInfo = function (watchmanWatcher) {\n  var watcherInfo = {\n    subscription: this._genSubscription(),\n    watchmanWatcher: watchmanWatcher,\n    root: null,\n    // set during 'watch' or 'watch-project'\n    relativePath: null,\n    // same\n    since: null,\n    // set during 'clock'\n    options: null // created and set during 'subscribe'.\n  };\n\n  this._watcherMap[watcherInfo.subscription] = watcherInfo;\n  return watcherInfo;\n};\n\n/**\n * Find an existing watcherInfo instance.\n */\nWatchmanClient.prototype._getWatcherInfo = function (subscription) {\n  return this._watcherMap[subscription];\n};\n\n/**\n * Given a watchmanWatcher and a root, issue the correct 'watch'\n * or 'watch-project' command and handle it with the callback.\n * Because we're operating in 'sane', we'll keep the results\n * of the 'watch' or 'watch-project' here.\n */\nWatchmanClient.prototype._watch = function (subscription, root) {\n  var _this6 = this;\n  return new Promise(function (resolve, reject) {\n    var watcherInfo = _this6._getWatcherInfo(subscription);\n    if (_this6._relative_root) {\n      _this6._client.command(['watch-project', root], function (error, resp) {\n        if (error) {\n          reject(error);\n        } else {\n          watcherInfo.root = resp.watch;\n          watcherInfo.relativePath = resp.relative_path ? resp.relative_path : '';\n          resolve(resp);\n        }\n      });\n    } else {\n      _this6._client.command(['watch', root], function (error, resp) {\n        if (error) {\n          reject(error);\n        } else {\n          watcherInfo.root = root;\n          watcherInfo.relativePath = '';\n          resolve(resp);\n        }\n      });\n    }\n  });\n};\n\n/**\n * Issue the 'clock' command to get the time value for use with the 'since'\n * option during 'subscribe'.\n */\nWatchmanClient.prototype._clock = function (subscription) {\n  var _this7 = this;\n  return new Promise(function (resolve, reject) {\n    var watcherInfo = _this7._getWatcherInfo(subscription);\n    _this7._client.command(['clock', watcherInfo.root], function (error, resp) {\n      if (error) {\n        reject(error);\n      } else {\n        watcherInfo.since = resp.clock;\n        resolve(resp);\n      }\n    });\n  });\n};\n\n/**\n * Do the internal handling of calling the watchman.Client for\n * a subscription.\n */\nWatchmanClient.prototype._subscribe = function (subscription) {\n  var _this8 = this;\n  return new Promise(function (resolve, reject) {\n    var watcherInfo = _this8._getWatcherInfo(subscription);\n\n    // create the 'bare' options w/o 'since' or relative_root.\n    // Store in watcherInfo for later use if we need to reset\n    // things after an 'end' caught here.\n    var options = watcherInfo.watchmanWatcher.createOptions();\n    watcherInfo.options = options;\n\n    // Dup the options object so we can add 'relative_root' and 'since'\n    // and leave the original options object alone. We'll do this again\n    // later if we need to resubscribe after 'end' and reconnect.\n    options = Object.assign({}, options);\n    if (_this8._relative_root) {\n      options.relative_root = watcherInfo.relativePath;\n    }\n    options.since = watcherInfo.since;\n    _this8._client.command(['subscribe', watcherInfo.root, subscription, options], function (error, resp) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(resp);\n      }\n    });\n  });\n};\n\n/**\n * Handle the 'subscription' (file change) event, by calling the\n * handler on the relevant WatchmanWatcher.\n */\nWatchmanClient.prototype._onSubscription = function (resp) {\n  var watcherInfo = this._getWatcherInfo(resp.subscription);\n  if (watcherInfo) {\n    // we're assuming the watchmanWatcher does not throw during\n    // handling of the change event.\n    watcherInfo.watchmanWatcher.handleChangeEvent(resp);\n  } else {\n    // Note it in the log, but otherwise ignore it\n    console.error(\"WatchmanClient error - received 'subscription' event \" + \"for non-existent subscription '\" + resp.subscription + \"'\");\n  }\n};\n\n/**\n * Handle the 'error' event by forwarding to the\n * handler on all WatchmanWatchers (errors are generally during processing\n * a particular command, but it's not given which command that was, or\n * which subscription it belonged to).\n */\nWatchmanClient.prototype._onError = function (error) {\n  values(this._watcherMap).forEach(function (watcherInfo) {\n    return watcherInfo.watchmanWatcher.handleErrorEvent(error);\n  });\n};\n\n/**\n * Handle the 'end' event by creating a new watchman.Client and\n * attempting to resubscribe all the existing subscriptions, but\n * without notifying the WatchmanWatchers about it. They should\n * not be aware the connection was lost and recreated.\n * If something goes wrong during any part of the reconnect/setup,\n * call the error handler on each existing WatchmanWatcher.\n */\nWatchmanClient.prototype._onEnd = function () {\n  var _this9 = this;\n  console.warn('[sane.WatchmanClient] Warning: Lost connection to watchman, reconnecting..');\n\n  // Hold the old watcher map so we use it to recreate all subscriptions.\n  var oldWatcherInfos = values(this._watcherMap);\n  this._clearLocalVars();\n  this._setupClient().then(function () {\n    var promises = oldWatcherInfos.map(function (watcherInfo) {\n      return _this9.subscribe(watcherInfo.watchmanWatcher, watcherInfo.watchmanWatcher.root);\n    });\n    Promise.all(promises).then(function () {\n      console.log('[sane.WatchmanClient]: Reconnected to watchman');\n    }, function (error) {\n      console.error('[sane.WatchmanClient]: Reconnected to watchman, but failed to ' + 'reestablish at least one subscription, cannot continue');\n      console.error(error);\n      oldWatcherInfos.forEach(function (watcherInfo) {\n        return watcherInfo.watchmanWatcher.handleErrorEvent(error);\n      });\n      // XXX not sure whether to clear all _watcherMap instances here,\n      // but basically this client is inconsistent now, since at least one\n      // subscribe failed.\n    });\n  }, function (error) {\n    console.error('[sane.WatchmanClient]: Lost connection to watchman, ' + 'reconnect failed, cannot continue');\n    console.error(error);\n    oldWatcherInfos.forEach(function (watcherInfo) {\n      return watcherInfo.watchmanWatcher.handleErrorEvent(error);\n    });\n  });\n};\nmodule.exports = {\n  /**\n   * Create/retrieve an instance of the WatchmanClient. See the header comment\n   * about the map of client instances, one per watchmanPath.\n   * Export the getInstance method by itself so the callers cannot do anything until\n   * they get a real WatchmanClient instance here.\n   */\n  getInstance: function getInstance(watchmanBinaryPath) {\n    var clientMap = WatchmanClient.prototype._clientMap;\n    if (!clientMap) {\n      clientMap = Object.create(null);\n      WatchmanClient.prototype._clientMap = clientMap;\n    }\n    if (watchmanBinaryPath == undefined || watchmanBinaryPath === null) {\n      watchmanBinaryPath = '';\n    }\n    var watchmanClient = clientMap[watchmanBinaryPath];\n    if (!watchmanClient) {\n      watchmanClient = new WatchmanClient(watchmanBinaryPath);\n      clientMap[watchmanBinaryPath] = watchmanClient;\n    }\n    return watchmanClient;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}