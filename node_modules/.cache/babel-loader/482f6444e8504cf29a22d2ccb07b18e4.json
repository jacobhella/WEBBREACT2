{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _jestUtil;\nfunction _load_jestUtil() {\n  return _jestUtil = require('jest-util');\n}\nvar _chalk;\nfunction _load_chalk() {\n  return _chalk = _interopRequireDefault(require('chalk'));\n}\nvar _base_reporter;\nfunction _load_base_reporter() {\n  return _base_reporter = _interopRequireDefault(require('./base_reporter'));\n}\nvar _Status;\nfunction _load_Status() {\n  return _Status = _interopRequireDefault(require('./Status'));\n}\nvar _get_result_header;\nfunction _load_get_result_header() {\n  return _get_result_header = _interopRequireDefault(require('./get_result_header'));\n}\nvar _get_snapshot_status;\nfunction _load_get_snapshot_status() {\n  return _get_snapshot_status = _interopRequireDefault(require('./get_snapshot_status'));\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n/* global stream$Writable, tty$WriteStream */\n\nvar TITLE_BULLET = (_chalk || _load_chalk()).default.bold(\"\\u25CF \");\nvar DefaultReporter = /*#__PURE__*/function (_default) {\n  _inherits(DefaultReporter, _default);\n  function DefaultReporter(globalConfig) {\n    var _this;\n    _classCallCheck(this, DefaultReporter);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultReporter).call(this));\n    _this._globalConfig = globalConfig;\n    _this._clear = '';\n    _this._out = process.stdout.write.bind(process.stdout);\n    _this._err = process.stderr.write.bind(process.stderr);\n    _this._status = new (_Status || _load_Status()).default();\n    _this._bufferedOutput = new Set();\n    _this._wrapStdio(process.stdout);\n    _this._wrapStdio(process.stderr);\n    _this._status.onChange(function () {\n      _this._clearStatus();\n      _this._printStatus();\n    });\n    return _this;\n  } // ANSI clear sequence for the last printed status\n  _createClass(DefaultReporter, [{\n    key: \"_wrapStdio\",\n    value: function _wrapStdio(stream) {\n      var _this2 = this;\n      var originalWrite = stream.write;\n      var buffer = [];\n      var timeout = null;\n      var flushBufferedOutput = function flushBufferedOutput() {\n        var string = buffer.join('');\n        buffer = [];\n\n        // This is to avoid conflicts between random output and status text\n        _this2._clearStatus();\n        if (string) {\n          originalWrite.call(stream, string);\n        }\n        _this2._printStatus();\n        _this2._bufferedOutput.delete(flushBufferedOutput);\n      };\n      this._bufferedOutput.add(flushBufferedOutput);\n      var debouncedFlush = function debouncedFlush() {\n        // If the process blows up no errors would be printed.\n        // There should be a smart way to buffer stderr, but for now\n        // we just won't buffer it.\n        if (stream === process.stderr) {\n          flushBufferedOutput();\n        } else {\n          if (!timeout) {\n            timeout = setTimeout(function () {\n              flushBufferedOutput();\n              timeout = null;\n            }, 100);\n          }\n        }\n      };\n\n      // $FlowFixMe\n      stream.write = function (chunk) {\n        buffer.push(chunk);\n        debouncedFlush();\n        return true;\n      };\n    } // Don't wait for the debounced call and flush all output immediately.\n  }, {\n    key: \"forceFlushBufferedOutput\",\n    value: function forceFlushBufferedOutput() {\n      var _iterator = _createForOfIteratorHelper(this._bufferedOutput),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var flushBufferedOutput = _step.value;\n          flushBufferedOutput();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_clearStatus\",\n    value: function _clearStatus() {\n      if ((_jestUtil || _load_jestUtil()).isInteractive) {\n        if (this._globalConfig.useStderr) {\n          this._err(this._clear);\n        } else {\n          this._out(this._clear);\n        }\n      }\n    }\n  }, {\n    key: \"_printStatus\",\n    value: function _printStatus() {\n      var _status$get = this._status.get();\n      var content = _status$get.content,\n        clear = _status$get.clear;\n      this._clear = clear;\n      if ((_jestUtil || _load_jestUtil()).isInteractive) {\n        if (this._globalConfig.useStderr) {\n          this._err(content);\n        } else {\n          this._out(content);\n        }\n      }\n    }\n  }, {\n    key: \"onRunStart\",\n    value: function onRunStart(aggregatedResults, options) {\n      this._status.runStarted(aggregatedResults, options);\n    }\n  }, {\n    key: \"onTestStart\",\n    value: function onTestStart(test) {\n      this._status.testStarted(test.path, test.context.config);\n    }\n  }, {\n    key: \"onRunComplete\",\n    value: function onRunComplete() {\n      this.forceFlushBufferedOutput();\n      this._status.runFinished();\n      // $FlowFixMe\n      process.stdout.write = this._out;\n      // $FlowFixMe\n      process.stderr.write = this._err;\n      (0, (_jestUtil || _load_jestUtil()).clearLine)(process.stderr);\n    }\n  }, {\n    key: \"onTestResult\",\n    value: function onTestResult(test, testResult, aggregatedResults) {\n      this.testFinished(test.context.config, testResult, aggregatedResults);\n      if (!testResult.skipped) {\n        this.printTestFileHeader(testResult.testFilePath, test.context.config, testResult);\n        this.printTestFileFailureMessage(testResult.testFilePath, test.context.config, testResult);\n      }\n      this.forceFlushBufferedOutput();\n    }\n  }, {\n    key: \"testFinished\",\n    value: function testFinished(config, testResult, aggregatedResults) {\n      this._status.testFinished(config, testResult, aggregatedResults);\n    }\n  }, {\n    key: \"printTestFileHeader\",\n    value: function printTestFileHeader(testPath, config, result) {\n      this.log((0, (_get_result_header || _load_get_result_header()).default)(result, this._globalConfig, config));\n      var consoleBuffer = result.console;\n      if (consoleBuffer && consoleBuffer.length) {\n        this.log('  ' + TITLE_BULLET + 'Console\\n\\n' + (0, (_jestUtil || _load_jestUtil()).getConsoleOutput)(config.cwd, !!this._globalConfig.verbose, consoleBuffer));\n      }\n    }\n  }, {\n    key: \"printTestFileFailureMessage\",\n    value: function printTestFileFailureMessage(testPath, config, result) {\n      if (result.failureMessage) {\n        this.log(result.failureMessage);\n      }\n      var didUpdate = this._globalConfig.updateSnapshot === 'all';\n      var snapshotStatuses = (0, (_get_snapshot_status || _load_get_snapshot_status()).default)(result.snapshot, didUpdate);\n      snapshotStatuses.forEach(this.log);\n    }\n  }]);\n  return DefaultReporter;\n}((_base_reporter || _load_base_reporter()).default);\nexports.default = DefaultReporter;","map":null,"metadata":{},"sourceType":"script"}