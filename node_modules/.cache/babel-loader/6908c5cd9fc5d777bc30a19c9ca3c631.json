{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}(); /*\n      Copyright 2012-2015, Yahoo Inc.\n      Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n      */\n\nvar _babylon = require('babylon');\nvar babylon = _interopRequireWildcard(_babylon);\nvar _babelTypes = require('babel-types');\nvar t = _interopRequireWildcard(_babelTypes);\nvar _babelTraverse = require('babel-traverse');\nvar _babelTraverse2 = _interopRequireDefault(_babelTraverse);\nvar _babelGenerator = require('babel-generator');\nvar _babelGenerator2 = _interopRequireDefault(_babelGenerator);\nvar _visitor = require('./visitor');\nvar _visitor2 = _interopRequireDefault(_visitor);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction defaultOpts() {\n  return {\n    coverageVariable: \"__coverage__\",\n    preserveComments: false,\n    compact: true,\n    esModules: false,\n    autoWrap: false,\n    produceSourceMap: false,\n    sourceMapUrlCallback: null,\n    debug: false\n  };\n}\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on\n */\n\nvar Instrumenter = function () {\n  function Instrumenter() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOpts();\n    _classCallCheck(this, Instrumenter);\n    this.opts = this.normalizeOpts(opts);\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * normalize options passed in and assign defaults.\n   * @param opts\n   * @private\n   */\n\n  _createClass(Instrumenter, [{\n    key: 'normalizeOpts',\n    value: function normalizeOpts(opts) {\n      var normalize = function normalize(name, defaultValue) {\n        if (!opts.hasOwnProperty(name)) {\n          opts[name] = defaultValue;\n        }\n      };\n      var defOpts = defaultOpts();\n      Object.keys(defOpts).forEach(function (k) {\n        normalize(k, defOpts[k]);\n      });\n      return opts;\n    }\n    /**\n     * instrument the supplied code and track coverage against the supplied\n     * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n     * is supported. To instrument ES6 modules, make sure that you set the\n     * `esModules` property to `true` when creating the instrumenter.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     * @returns {string} the instrumented code.\n     */\n  }, {\n    key: 'instrumentSync',\n    value: function instrumentSync(code, filename, inputSourceMap) {\n      if (typeof code !== 'string') {\n        throw new Error('Code must be a string');\n      }\n      filename = filename || String(new Date().getTime()) + '.js';\n      var opts = this.opts;\n      var ast = babylon.parse(code, {\n        allowReturnOutsideFunction: opts.autoWrap,\n        sourceType: opts.esModules ? \"module\" : \"script\",\n        plugins: ['asyncGenerators', 'dynamicImport', 'objectRestSpread', 'flow', 'jsx']\n      });\n      var ee = (0, _visitor2.default)(t, filename, {\n        coverageVariable: opts.coverageVariable,\n        inputSourceMap: inputSourceMap\n      });\n      var output = {};\n      var visitor = {\n        Program: {\n          enter: ee.enter,\n          exit: function exit(path) {\n            output = ee.exit(path);\n          }\n        }\n      };\n      (0, _babelTraverse2.default)(ast, visitor);\n      var generateOptions = {\n        compact: opts.compact,\n        comments: opts.preserveComments,\n        sourceMaps: opts.produceSourceMap,\n        sourceFileName: filename\n      };\n      var codeMap = (0, _babelGenerator2.default)(ast, generateOptions, code);\n      this.fileCoverage = output.fileCoverage;\n      this.sourceMap = codeMap.map;\n      var cb = this.opts.sourceMapUrlCallback;\n      if (cb && output.sourceMappingURL) {\n        cb(filename, output.sourceMappingURL);\n      }\n      return codeMap.code;\n    }\n    /**\n     * callback-style instrument method that calls back with an error\n     * as opposed to throwing one. Note that in the current implementation,\n     * the callback will be called in the same process tick and is not asynchronous.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {Function} callback - the callback\n     * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     */\n  }, {\n    key: 'instrument',\n    value: function instrument(code, filename, callback, inputSourceMap) {\n      if (!callback && typeof filename === 'function') {\n        callback = filename;\n        filename = null;\n      }\n      try {\n        var out = this.instrumentSync(code, filename, inputSourceMap);\n        callback(null, out);\n      } catch (ex) {\n        callback(ex);\n      }\n    }\n    /**\n     * returns the file coverage object for the last file instrumented.\n     * @returns {Object} the file coverage object.\n     */\n  }, {\n    key: 'lastFileCoverage',\n    value: function lastFileCoverage() {\n      return this.fileCoverage;\n    }\n    /**\n     * returns the source map produced for the last file instrumented.\n     * @returns {null|Object} the source map object.\n     */\n  }, {\n    key: 'lastSourceMap',\n    value: function lastSourceMap() {\n      return this.sourceMap;\n    }\n  }]);\n  return Instrumenter;\n}();\nexports.default = Instrumenter;","map":null,"metadata":{},"sourceType":"script"}