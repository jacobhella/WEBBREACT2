{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.install = install;\nvar _isGeneratorFn = require('is-generator-fn');\nvar _isGeneratorFn2 = _interopRequireDefault(_isGeneratorFn);\nvar _co = require('co');\nvar _co2 = _interopRequireDefault(_co);\nvar _is_error = require('./is_error');\nvar _is_error2 = _interopRequireDefault(_is_error);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n/**\n * This module adds ability to test async promise code with jasmine by\n * returning a promise from `it/test` and `before/afterEach/All` blocks.\n */\n\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\nfunction promisifyLifeCycleFunction(originalFn, env) {\n  return function (fn, timeout) {\n    if (!fn) {\n      return originalFn.call(env);\n    }\n    var hasDoneCallback = fn.length > 0;\n    if (hasDoneCallback) {\n      // Jasmine will handle it\n      return originalFn.call(env, fn, timeout);\n    }\n    var extraError = new Error();\n\n    // We make *all* functions async and run `done` right away if they\n    // didn't return a promise.\n    var asyncJestLifecycle = function asyncJestLifecycle(done) {\n      var wrappedFn = (0, _isGeneratorFn2.default)(fn) ? _co2.default.wrap(fn) : fn;\n      var returnValue = wrappedFn.call({});\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), function (error) {\n          var _checkIsError = (0, _is_error2.default)(error);\n          var isError = _checkIsError.isError,\n            message = _checkIsError.message;\n          if (message) {\n            extraError.message = message;\n          }\n          done.fail(isError ? error : extraError);\n        });\n      } else {\n        done();\n      }\n    };\n    return originalFn.call(env, asyncJestLifecycle, timeout);\n  };\n}\n\n// Similar to promisifyLifeCycleFunction but throws an error\n// when the return value is neither a Promise nor `undefined`\nfunction promisifyIt(originalFn, env) {\n  return function (specName, fn, timeout) {\n    if (!fn) {\n      var spec = originalFn.call(env, specName);\n      spec.pend('not implemented');\n      return spec;\n    }\n    var hasDoneCallback = fn.length > 0;\n    if (hasDoneCallback) {\n      return originalFn.call(env, specName, fn, timeout);\n    }\n    var extraError = new Error();\n    var asyncJestTest = function asyncJestTest(done) {\n      var wrappedFn = (0, _isGeneratorFn2.default)(fn) ? _co2.default.wrap(fn) : fn;\n      var returnValue = wrappedFn.call({});\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), function (error) {\n          var _checkIsError2 = (0, _is_error2.default)(error);\n          var isError = _checkIsError2.isError,\n            message = _checkIsError2.message;\n          if (message) {\n            extraError.message = message;\n          }\n          done.fail(isError ? error : extraError);\n        });\n      } else if (returnValue === undefined) {\n        done();\n      } else {\n        done.fail(new Error('Jest: `it` and `test` must return either a Promise or undefined.'));\n      }\n    };\n    return originalFn.call(env, specName, asyncJestTest, timeout);\n  };\n}\nfunction makeConcurrent(originalFn, env) {\n  return function (specName, fn, timeout) {\n    if (env != null && !env.specFilter({\n      getFullName: function getFullName() {\n        return specName || '';\n      }\n    })) {\n      return originalFn.call(env, specName, function () {\n        return Promise.resolve();\n      }, timeout);\n    }\n    var promise;\n    try {\n      promise = fn();\n      if (!isPromise(promise)) {\n        throw new Error(\"Jest: concurrent test \\\"\".concat(specName, \"\\\" must return a Promise.\"));\n      }\n    } catch (error) {\n      return originalFn.call(env, specName, function () {\n        return Promise.reject(error);\n      });\n    }\n    return originalFn.call(env, specName, function () {\n      return promise;\n    }, timeout);\n  };\n}\nfunction install(global) {\n  var jasmine = global.jasmine;\n  var env = jasmine.getEnv();\n  env.it = promisifyIt(env.it, env);\n  env.fit = promisifyIt(env.fit, env);\n  global.it.concurrent = makeConcurrent(env.it, env);\n  global.it.concurrent.only = makeConcurrent(env.fit, env);\n  global.it.concurrent.skip = makeConcurrent(env.xit, env);\n  global.fit.concurrent = makeConcurrent(env.fit);\n  env.afterAll = promisifyLifeCycleFunction(env.afterAll, env);\n  env.afterEach = promisifyLifeCycleFunction(env.afterEach, env);\n  env.beforeAll = promisifyLifeCycleFunction(env.beforeAll, env);\n  env.beforeEach = promisifyLifeCycleFunction(env.beforeEach, env);\n}","map":null,"metadata":{},"sourceType":"script"}