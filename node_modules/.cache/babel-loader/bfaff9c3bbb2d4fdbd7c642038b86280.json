{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\"use strict\";\n\nvar Path = require('./path'),\n  util = require('util'),\n  tree = require('./tree'),\n  coverage = require('istanbul-lib-coverage'),\n  BaseNode = tree.Node,\n  BaseTree = tree.Tree;\nfunction ReportNode(path, fileCoverage) {\n  this.path = path;\n  this.parent = null;\n  this.fileCoverage = fileCoverage;\n  this.children = [];\n}\nutil.inherits(ReportNode, BaseNode);\nReportNode.prototype.addChild = function (child) {\n  child.parent = this;\n  this.children.push(child);\n};\nReportNode.prototype.asRelative = function (p) {\n  /* istanbul ignore if */\n  if (p.substring(0, 1) === '/') {\n    return p.substring(1);\n  }\n  return p;\n};\nReportNode.prototype.getQualifiedName = function () {\n  return this.asRelative(this.path.toString());\n};\nReportNode.prototype.getRelativeName = function () {\n  var parent = this.getParent(),\n    myPath = this.path,\n    relPath,\n    i,\n    parentPath = parent ? parent.path : new Path([]);\n  if (parentPath.ancestorOf(myPath)) {\n    relPath = new Path(myPath.elements());\n    for (i = 0; i < parentPath.length; i += 1) {\n      relPath.shift();\n    }\n    return this.asRelative(relPath.toString());\n  }\n  return this.asRelative(this.path.toString());\n};\nReportNode.prototype.getParent = function () {\n  return this.parent;\n};\nReportNode.prototype.getChildren = function () {\n  return this.children;\n};\nReportNode.prototype.isSummary = function () {\n  return !this.fileCoverage;\n};\nReportNode.prototype.getFileCoverage = function () {\n  return this.fileCoverage;\n};\nReportNode.prototype.getCoverageSummary = function (filesOnly) {\n  var cacheProp = 'c_' + (filesOnly ? 'files' : 'full'),\n    summary;\n  if (this.hasOwnProperty(cacheProp)) {\n    return this[cacheProp];\n  }\n  if (!this.isSummary()) {\n    summary = this.getFileCoverage().toSummary();\n  } else {\n    var count = 0;\n    summary = coverage.createCoverageSummary();\n    this.getChildren().forEach(function (child) {\n      if (filesOnly && child.isSummary()) {\n        return;\n      }\n      count += 1;\n      summary.merge(child.getCoverageSummary(filesOnly));\n    });\n    if (count === 0 && filesOnly) {\n      summary = null;\n    }\n  }\n  this[cacheProp] = summary;\n  return summary;\n};\nfunction treeFor(root, childPrefix) {\n  var tree = new BaseTree(),\n    visitor,\n    maybePrefix = function maybePrefix(node) {\n      if (childPrefix && !node.isRoot()) {\n        node.path.unshift(childPrefix);\n      }\n    };\n  tree.getRoot = function () {\n    return root;\n  };\n  visitor = {\n    onDetail: function onDetail(node) {\n      maybePrefix(node);\n    },\n    onSummary: function onSummary(node) {\n      maybePrefix(node);\n      node.children.sort(function (a, b) {\n        var astr = a.path.toString(),\n          bstr = b.path.toString();\n        return astr < bstr ? -1 : astr > bstr ? 1 : /* istanbul ignore next */0;\n      });\n    }\n  };\n  tree.visit(visitor);\n  return tree;\n}\nfunction findCommonParent(paths) {\n  if (paths.length === 0) {\n    return new Path([]);\n  }\n  var common = paths[0],\n    i;\n  for (i = 1; i < paths.length; i += 1) {\n    common = common.commonPrefixPath(paths[i]);\n    if (common.length === 0) {\n      break;\n    }\n  }\n  return common;\n}\nfunction toInitialList(coverageMap) {\n  var ret = [],\n    commonParent;\n  coverageMap.files().forEach(function (filePath) {\n    var p = new Path(filePath),\n      coverage = coverageMap.fileCoverageFor(filePath);\n    ret.push({\n      filePath: filePath,\n      path: p,\n      fileCoverage: coverage\n    });\n  });\n  commonParent = findCommonParent(ret.map(function (o) {\n    return o.path.parent();\n  }));\n  if (commonParent.length > 0) {\n    ret.forEach(function (o) {\n      o.path.splice(0, commonParent.length);\n    });\n  }\n  return {\n    list: ret,\n    commonParent: commonParent\n  };\n}\nfunction toDirParents(list) {\n  var nodeMap = {},\n    parentNodeList = [];\n  list.forEach(function (o) {\n    var node = new ReportNode(o.path, o.fileCoverage),\n      parentPath = o.path.parent(),\n      parent = nodeMap[parentPath.toString()];\n    if (!parent) {\n      parent = new ReportNode(parentPath);\n      nodeMap[parentPath.toString()] = parent;\n      parentNodeList.push(parent);\n    }\n    parent.addChild(node);\n  });\n  return parentNodeList;\n}\nfunction foldIntoParents(nodeList) {\n  var ret = [],\n    i,\n    j;\n\n  // sort by longest length first\n  nodeList.sort(function (a, b) {\n    return -1 * Path.compare(a.path, b.path);\n  });\n  for (i = 0; i < nodeList.length; i += 1) {\n    var first = nodeList[i],\n      inserted = false;\n    for (j = i + 1; j < nodeList.length; j += 1) {\n      var second = nodeList[j];\n      if (second.path.ancestorOf(first.path)) {\n        second.addChild(first);\n        inserted = true;\n        break;\n      }\n    }\n    if (!inserted) {\n      ret.push(first);\n    }\n  }\n  return ret;\n}\nfunction createRoot() {\n  return new ReportNode(new Path([]));\n}\nfunction createNestedSummary(coverageMap) {\n  var flattened = toInitialList(coverageMap),\n    dirParents = toDirParents(flattened.list),\n    topNodes = foldIntoParents(dirParents),\n    root;\n  if (topNodes.length === 0) {\n    return treeFor(new ReportNode([]));\n  }\n  if (topNodes.length === 1) {\n    return treeFor(topNodes[0]);\n  }\n  root = createRoot();\n  topNodes.forEach(function (node) {\n    root.addChild(node);\n  });\n  return treeFor(root);\n}\nfunction createPackageSummary(coverageMap) {\n  var flattened = toInitialList(coverageMap),\n    dirParents = toDirParents(flattened.list),\n    common = flattened.commonParent,\n    prefix,\n    root;\n  if (dirParents.length === 1) {\n    root = dirParents[0];\n  } else {\n    root = createRoot();\n    // if one of the dirs is itself the root,\n    // then we need to create a top-level dir\n    dirParents.forEach(function (dp) {\n      if (dp.path.length === 0) {\n        prefix = 'root';\n      }\n    });\n    if (prefix && common.length > 0) {\n      prefix = common.elements()[common.elements().length - 1];\n    }\n    dirParents.forEach(function (node) {\n      root.addChild(node);\n    });\n  }\n  return treeFor(root, prefix);\n}\nfunction createFlatSummary(coverageMap) {\n  var flattened = toInitialList(coverageMap),\n    list = flattened.list,\n    root;\n  root = createRoot();\n  list.forEach(function (o) {\n    var node = new ReportNode(o.path, o.fileCoverage);\n    root.addChild(node);\n  });\n  return treeFor(root);\n}\nmodule.exports = {\n  createNestedSummary: createNestedSummary,\n  createPackageSummary: createPackageSummary,\n  createFlatSummary: createFlatSummary\n};","map":null,"metadata":{},"sourceType":"script"}