{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\legoj\\\\OneDrive\\\\Dokument\\\\Uni\\\\VT 2023\\\\Webbteknik\\\\hemsidan\\\\reactp\\\\myprojectapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\nfunction resolve(input, base) {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n  return resolveUri(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n  if (!path) return '';\n  var index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\nvar REV_GENERATED_LINE = 1;\nvar REV_GENERATED_COLUMN = 2;\nfunction maybeSort(mappings, owned) {\n  var unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n  for (var i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (var i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (var j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\nvar found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    var mid = low + (high - low >> 1);\n    var cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (var i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (var i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  var lastKey = state.lastKey,\n    lastNeedle = state.lastNeedle,\n    lastIndex = state.lastIndex;\n  var low = 0;\n  var high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n  var sources = memos.map(buildNullArray);\n  for (var i = 0; i < decoded.length; i++) {\n    var line = decoded[i];\n    for (var j = 0; j < line.length; j++) {\n      var seg = line[j];\n      if (seg.length === 1) continue;\n      var sourceIndex = seg[SOURCES_INDEX];\n      var sourceLine = seg[SOURCE_LINE];\n      var sourceColumn = seg[SOURCE_COLUMN];\n      var originalSource = sources[sourceIndex];\n      var originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n      var memo = memos[sourceIndex];\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      var index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n      insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n  return sources;\n}\nfunction insert(array, index, value) {\n  for (var i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n  return {\n    __proto__: null\n  };\n}\nvar AnyMap = function AnyMap(map, mapUrl) {\n  var parsed = typeof map === 'string' ? JSON.parse(map) : map;\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n  var mappings = [];\n  var sources = [];\n  var sourcesContent = [];\n  var names = [];\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n  var joined = {\n    version: 3,\n    file: parsed.file,\n    names: names,\n    sources: sources,\n    sourcesContent: sourcesContent,\n    mappings: mappings\n  };\n  return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n  var sections = input.sections;\n  for (var i = 0; i < sections.length; i++) {\n    var _sections$i = sections[i],\n      map = _sections$i.map,\n      offset = _sections$i.offset;\n    var sl = stopLine;\n    var sc = stopColumn;\n    if (i + 1 < sections.length) {\n      var nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n    addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n  }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n  if ('sections' in input) return recurse.apply(void 0, arguments);\n  var map = new TraceMap(input, mapUrl);\n  var sourcesOffset = sources.length;\n  var namesOffset = names.length;\n  var decoded = decodedMappings(map);\n  var resolvedSources = map.resolvedSources,\n    contents = map.sourcesContent;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);else for (var i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n  for (var _i = 0; _i < decoded.length; _i++) {\n    var lineI = lineOffset + _i;\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    var out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    var cOffset = _i === 0 ? columnOffset : 0;\n    var line = decoded[_i];\n    for (var j = 0; j < line.length; j++) {\n      var seg = line[j];\n      var column = cOffset + seg[COLUMN];\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n      var sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      var sourceLine = seg[SOURCE_LINE];\n      var sourceColumn = seg[SOURCE_COLUMN];\n      out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n    }\n  }\n}\nfunction append(arr, other) {\n  for (var i = 0; i < other.length; i++) arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n  for (var i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\nvar LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nvar COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nvar LEAST_UPPER_BOUND = -1;\nvar GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nvar encodedMappings;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nvar decodedMappings;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nvar traceSegment;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nvar originalPositionFor;\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nvar generatedPositionFor;\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nvar allGeneratedPositionsFor;\n/**\n * Iterates each mapping in generated position order.\n */\nvar eachMapping;\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nvar sourceContentFor;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nvar presortedDecodedMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nvar decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nvar encodedMap;\nvar TraceMap = function TraceMap(map, mapUrl) {\n  _classCallCheck(this, TraceMap);\n  var isString = typeof map === 'string';\n  if (!isString && map._decodedMemo) return map;\n  var parsed = isString ? JSON.parse(map) : map;\n  var version = parsed.version,\n    file = parsed.file,\n    names = parsed.names,\n    sourceRoot = parsed.sourceRoot,\n    sources = parsed.sources,\n    sourcesContent = parsed.sourcesContent;\n  this.version = version;\n  this.file = file;\n  this.names = names;\n  this.sourceRoot = sourceRoot;\n  this.sources = sources;\n  this.sourcesContent = sourcesContent;\n  var from = resolve(sourceRoot || '', stripFilename(mapUrl));\n  this.resolvedSources = sources.map(function (s) {\n    return resolve(s || '', from);\n  });\n  var mappings = parsed.mappings;\n  if (typeof mappings === 'string') {\n    this._encoded = mappings;\n    this._decoded = undefined;\n  } else {\n    this._encoded = undefined;\n    this._decoded = maybeSort(mappings, isString);\n  }\n  this._decodedMemo = memoizedState();\n  this._bySources = undefined;\n  this._bySourceMemos = undefined;\n};\n(function () {\n  encodedMappings = function encodedMappings(map) {\n    var _a;\n    return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = encode(map._decoded);\n  };\n  decodedMappings = function decodedMappings(map) {\n    return map._decoded || (map._decoded = decode(map._encoded));\n  };\n  traceSegment = function traceSegment(map, line, column) {\n    var decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length) return null;\n    var segments = decoded[line];\n    var index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    return index === -1 ? null : segments[index];\n  };\n  originalPositionFor = function originalPositionFor(map, _ref) {\n    var line = _ref.line,\n      column = _ref.column,\n      bias = _ref.bias;\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    var decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length) return OMapping(null, null, null, null);\n    var segments = decoded[line];\n    var index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n    if (index === -1) return OMapping(null, null, null, null);\n    var segment = segments[index];\n    if (segment.length === 1) return OMapping(null, null, null, null);\n    var names = map.names,\n      resolvedSources = map.resolvedSources;\n    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n  };\n  allGeneratedPositionsFor = function allGeneratedPositionsFor(map, _ref2) {\n    var source = _ref2.source,\n      line = _ref2.line,\n      column = _ref2.column,\n      bias = _ref2.bias;\n    // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n  };\n  generatedPositionFor = function generatedPositionFor(map, _ref3) {\n    var source = _ref3.source,\n      line = _ref3.line,\n      column = _ref3.column,\n      bias = _ref3.bias;\n    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n  };\n  eachMapping = function eachMapping(map, cb) {\n    var decoded = decodedMappings(map);\n    var names = map.names,\n      resolvedSources = map.resolvedSources;\n    for (var i = 0; i < decoded.length; i++) {\n      var line = decoded[i];\n      for (var j = 0; j < line.length; j++) {\n        var seg = line[j];\n        var generatedLine = i + 1;\n        var generatedColumn = seg[0];\n        var source = null;\n        var originalLine = null;\n        var originalColumn = null;\n        var name = null;\n        if (seg.length !== 1) {\n          source = resolvedSources[seg[1]];\n          originalLine = seg[2] + 1;\n          originalColumn = seg[3];\n        }\n        if (seg.length === 5) name = names[seg[4]];\n        cb({\n          generatedLine: generatedLine,\n          generatedColumn: generatedColumn,\n          source: source,\n          originalLine: originalLine,\n          originalColumn: originalColumn,\n          name: name\n        });\n      }\n    }\n  };\n  sourceContentFor = function sourceContentFor(map, source) {\n    var sources = map.sources,\n      resolvedSources = map.resolvedSources,\n      sourcesContent = map.sourcesContent;\n    if (sourcesContent == null) return null;\n    var index = sources.indexOf(source);\n    if (index === -1) index = resolvedSources.indexOf(source);\n    return index === -1 ? null : sourcesContent[index];\n  };\n  presortedDecodedMap = function presortedDecodedMap(map, mapUrl) {\n    var tracer = new TraceMap(clone(map, []), mapUrl);\n    tracer._decoded = map.mappings;\n    return tracer;\n  };\n  decodedMap = function decodedMap(map) {\n    return clone(map, decodedMappings(map));\n  };\n  encodedMap = function encodedMap(map) {\n    return clone(map, encodedMappings(map));\n  };\n  function generatedPosition(map, source, line, column, bias, all) {\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    var sources = map.sources,\n      resolvedSources = map.resolvedSources;\n    var sourceIndex = sources.indexOf(source);\n    if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n    if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n    var generated = map._bySources || (map._bySources = buildBySources(decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));\n    var segments = generated[sourceIndex][line];\n    if (segments == null) return all ? [] : GMapping(null, null);\n    var memo = map._bySourceMemos[sourceIndex];\n    if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n    var index = traceSegmentInternal(segments, memo, line, column, bias);\n    if (index === -1) return GMapping(null, null);\n    var segment = segments[index];\n    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n  }\n})();\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings: mappings\n  };\n}\nfunction OMapping(source, line, column, name) {\n  return {\n    source: source,\n    line: line,\n    column: column,\n    name: name\n  };\n}\nfunction GMapping(line, column) {\n  return {\n    line: line,\n    column: column\n  };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  var index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n  var min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!found && bias === LEAST_UPPER_BOUND) min++;\n  if (min === -1 || min === segments.length) return [];\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  var matchedColumn = found ? column : segments[min][COLUMN];\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!found) min = lowerBound(segments, matchedColumn, min);\n  var max = upperBound(segments, matchedColumn, min);\n  var result = [];\n  for (; min <= max; min++) {\n    var segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };","map":null,"metadata":{},"sourceType":"module"}